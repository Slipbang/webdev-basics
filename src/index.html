<!DOCTYPE html>
<html lang="ru" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="UTF-8">

    <!-- Document title in browser tabs -->
    <title>WebDev Basics</title>
    <!-- Document Favicon in browser tabs -->
    <!--    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon">-->
    <!-- Additional approach to add favicon -->
    <!--    <link rel="apple-touch-icon" href="apple-touch-icon.png">-->
    <!--    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72x72.png">-->
    <!--    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114x114.png">-->
    <!-- SEO -->
    <meta name="description"
          content="Web Development Workbook: Definitions, code examples, core concepts, and practice exercises for learning HTML, CSS, JavaScript, and other technologies.">
    <meta name="keywords" content="html, css, js, react, typeScript">
    <meta name="author" content="Slipbang">
    <!-- For mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- Use latest version of IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For external styles -->
    <link rel="stylesheet" href="styles/styles.css">
    <!-- Google fonts -->
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">


    <!-- Local scripts -->
    <!--    <script src="../src/scripts/UI.js" defer></script>-->
    <!--    <script src="../src/scripts/tasks.js" defer></script>-->
    <!--    <script src="../src/scripts/OOPClasses.js" defer></script>-->
</head>
<body>
<header>
    <h1>Основы Front-End</h1>
    <div class="headerLinks"></div>
    <div id="navButtons" class="headerSvg">
        <svg
                width="36"
                height="36"
                viewBox="0 0 24 24"
                fill="none"
                xmlns="http://www.w3.org/2000/svg"
        >
            <path d="M2 6C2 5.44772 2.44772 5 3 5H21C21.5523 5 22 5.44772 22 6C22 6.55228 21.5523 7 21 7H3C2.44772 7 2 6.55228 2 6Z"
                  fill="currentColor"/>
            <path d="M2 12.0322C2 11.4799 2.44772 11.0322 3 11.0322H21C21.5523 11.0322 22 11.4799 22 12.0322C22 12.5845 21.5523 13.0322 21 13.0322H3C2.44772 13.0322 2 12.5845 2 12.0322Z"
                  fill="currentColor"/>
            <path d="M3 17.0645C2.44772 17.0645 2 17.5122 2 18.0645C2 18.6167 2.44772 19.0645 3 19.0645H21C21.5523 19.0645 22 18.6167 22 18.0645C22 17.5122 21.5523 17.0645 21 17.0645H3Z"
                  fill="currentColor"/>
        </svg>
    </div>
</header>
<main>
    <div class="mainContainer">

        <section id="HTMLnav">
            <h2 id="htmlBasicsHeaderLink">Основы HTML</h2>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/01QJmn0vDxs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        -->
            <section>
                <h4 id="bsHTMLd">Базовая структура HTML документа</h4>
                <hr>
                <p>Некоторые из ниже приведенных тегов устарели!.</p>
                <h1>заголовок, обозначается тегом "h1"; (размер текста уменьшается от 1 до 6, "hr" - тэг отделяет
                    линией,
                    как под этим заголовком)</h1>
                <hr>
                <h2>Заголовок h2; (тэг "br" добавляет межстрочный интервал как под этой строкой)</h2>
                <h3>Заголовок h3</h3>
                <h4>Заголовок h4</h4>
                <h5>Заголовок h5</h5>
                <h6>Заголовок h6</h6>
                <p> тэг "p" - обычный текст любой величины</p>
                <address> тэг "address" - ссылка на автора</address>
                <br>
                <q>
                    Тэг <code>&lt;q&gt;</code> - какая-то умная мысль автора, кавычки ставит сам тэг
                </q>
                <address>Тэг <code>&lt;adress&gt;</code>. Вкупе с тегом <code>&lt;q&gt;</code> дает семантически
                    правильное построение цитаты с
                    авторством
                </address>
                <blockquote>
                    <p>
                        Тэг &lt;blockquote&gt; применяется совместно с тегом "p", для каких-то ну очень умных и
                        соответственно длинных мыслей автора
                    </p>
                </blockquote>
                <address>Конфуций</address>
                <br>
                <p>Тэг &lt;time&gt; предназначен для обозначения дат:
                    <time datetime="2022-08-03">2022-08-03</time>
                </p>
                <br>
                <time datetime="2022-08-03">Тег <code>&lt;time&gt;</code> с атрибутом " datetime='дата' ", данный
                    атрибут считывается
                    поисковым роботом или скрин ридером. Дата присвоенная к атрибуту не отображается.
                </time>
                <br>
                <b>Тэг "b", по семантической составляющей эквивалентно тэгу "p", изменяет только визуальную составляющую
                    (делает текст жирным), лучше редактировать стиль с помощью CSS дабы не было путаницы</b>
                <br>
                <i>Тег "i", та же, что и с "b",но в данном случае меняет шрифт</i>
                <br>
                <br>
                <s>Тег "s", зачеркнутый текст.</s>
                <br>
                <strong>Тег "strong"- а вот тут уже присутствует семантическое выделение, помимо визуального</strong>
                <br>
                <p>Тэг <code>&lt;code&gt;</code> - записанный этим тегом код будет отображаться как текст, но без
                    сохранения форматирования:</p>
                <code>
                    const args = {
                    name: "Yauhen",
                    age: 30
                    };
                    const getDate = () =&gt; new Date;
                </code>
                <br>
                <p>Тэг <code>&lt;pre&gt;</code>, внутри которого помещают тэг &lt;code&gt; Ссылка задается тегом с
                    атрибутом:</p>
                <pre>
            <code>
const args = {
     name: "Yauhen",
     age: 30
};
const getDate = () =&gt; new Date;
            </code>
                </pre>
                <br>
                <P>Тэг <code>&lt;small&gt;</code>-<small>Cемантическое выделение</small> в тексте, с его уменьшением.
                    Якобы используется
                    для сносок. <small>Но это не точно (сейчас deprecated).</small></P>
                <br>
                <del>Тэг <code>&lt;del&gt;&lt;del&gt;</code>-зачеркивает текст, имеет семантический смысл неактуальности
                    текста.
                </del>
                <br>
                <ins>Тэг <code>&lt;ins&gt;</code> - подчеркивает текст, симантическое выделение текста</ins>
                <br>
                <p>Тэг <code>&lt;sub&gt;</code> выводит букву или слово в нижний индекс, как правило используется для
                    написания
                    формул:
                    H<sub>2</sub>O
                </p>
                <br>
                <p>Тэг <code>&lt;sup&gt;</code> выводит букву или слово уже в верхний индекс, так же используется для
                    написания
                    формул:
                    x<sup>2</sup>=9
                </p>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/RTqHlz8VsQA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        -->
            <section>
                <h4 id="metadata">Мета-данные и внешние импорты</h4>

                <hr>
                <p>Пример метаданных вебстраницы</p>
                <div class="smallScreenContainer">
                    <img src="./assets/meta.png" alt="meta">
                </div>
                <p>Тэг "meta" нужен для установки кодировки документа. Так же с помощью этого тега и атрибута "name" и
                    "content" можно описать различную SEO информацию, "name" задает тип данных, описание, ключевые
                    слова,
                    имя автора, а атрибут "content" описывает эти данные. В пикче-примере всего лишь часть данных.</p>
                <p>Тэг "meta" c атрибутом name="viewport" и content="width=device-width, initial-scale=1" добавляет
                    респонсив дизайн на вебстраницу, тоесть размер элементов будет меняться пропорционально экрану
                    девайса:</p>
                <pre>
&lt;meta name="viewport" content="width=device-width, initial-scale=1&gt;
//(так же есть атрибут"user-scalable=no", но им лучше пользоваться аккуратно)
                </pre>
                <br>
                <p>Следующая конструкция поможет корректно отобразить сайт в Internet explorer и Edge</p>
                <pre>&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</pre>
                <br>
                <p>Тэг "title" определяет заголовок вкладки в браузере.</p>
                <p>"link" универсальный одиночный тэг, описывается атрибутом "rel" который содержит в себе следующие
                    значения:</p>
                <p>Добавление иконки на вкладке вебстраницы:</p>
                <pre>&lt;link rel="shortcut icon" href="icon.ico" type="image/x-icon"&gt;</pre>
                <br>
                <p>Следующая конструкция позволяет добавить иконки различного разрешения на вкладке вебстраницы в
                    зависимости от физических параметров экрана девайса, на котором открыта страница:</p>
                <pre>
&lt;link rel="apple-touch-icon" href="apple-touch-icon.png"&gt;
&lt;link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72x72.png"&gt;
&lt;link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114x114.png"&gt;
                </pre>
                <br>
                <p>Конструкция ниже позволяет подключить таблицу стилей CSS:</p>
                <pre>&lt;link rel="stylesheet" href="styles.css"&gt;</pre>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/6-9m0I19_Hc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
            <section>
                <h4 id="Validsemaccess">Валидация, семантика и доступность</h4>

                <p>Данный урок лучше смотреть на ютубе, в текстовом варианте можно лишь показать структуру вебстраницы и
                    расписать разве что пару определений:</p>
                <pre>
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;title&gt;Название HTML странице на вкладке&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div&gt;Блочный текст&lt;/div&gt;
&lt;span&gt;Текст выделение которого распространяется во всю линию&lt;/span&gt;
&lt;header&gt;Шапка сайта&lt;/header&gt;
&lt;nav&gt;Навигация&lt;/nav&gt;
&lt;article&gt;Блок с новостями или информацией&lt;/article&gt;
&lt;footer&gt;Подвал&lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
                </pre>
                <p>Валидность- соответствие HTML документа установленным веб стандартам. Валидацию можно пройти на <a
                        href="https://validator.w3.org" target="_blank">сайте консорциума всемирной паутины W3C</a></p>
                <p> Семантичный тег это тег который носит смысловое объяснение. Теги делятся на блочные и строчные.
                    (<code>&lt;тэг&gt;</code>...<code>&lt;/тэг&gt;</code> и <code>&lt;тэг&gt;</code>)</p>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/xXCOXsBzm48" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> -->
            <section>
                <h4 id="lists">Списки</h4>
                <p>Непронумерованные списки задаются тэгом "ul", каждый отдельный элемент списка задается тегом "li"</p>
                <p>пример:</p>
                <pre>
&lt;ul&gt;
    &lt;li&gt;Фронтэнд&lt;/li&gt;
    &lt;li&gt;Бэкэнд&lt;/li&gt;
    &lt;li&gt;фулстэк&lt;/li&gt;
&lt;/ul&gt;
                </pre>
                <ul>
                    <li>Фронтэнд</li>
                    <li>Бэкэнд</li>
                    <li>фулстэк</li>
                </ul>
                <p>Пронумерованные же списки задаются тегом "ol", каждый отдельный элемент списка так же задается тэгом
                    "li", из особенностей- имеет два атрибута: start="число с которого нужно начать отсчет списка" и
                    reversed - ведет нумерацию списка в обратном порядке.</p>
                <p>примеры:</p>
                <p>без атрибутов</p>
                <pre>
&lt;ol&gt;
    &lt;li&gt;Фронтэнд&lt;/li&gt;
    &lt;li&gt;Бэкэнд&lt;/li&gt;
    &lt;li&gt;фулстэк&lt;/li&gt;
&lt;/ol&gt;
                </pre>
                <ol>
                    <li>Фронтэнд</li>
                    <li>Бэкэнд</li>
                    <li>фулстэк</li>
                </ol>
                <p>атрибут start="10"</p>
                <pre>
&lt;ol start="10"&gt;
   &lt;li&gt;Фронтэнд&lt;/li&gt;
   &lt;li&gt;Бэкэнд&lt;/li&gt;
   &lt;li&gt;фулстэк&lt;/li&gt;
&lt;/ol&gt;
                </pre>
                <ol start="10">
                    <li>Фронтэнд</li>
                    <li>Бэкэнд</li>
                    <li>фулстэк</li>
                </ol>
                <p>атрибут reversed</p>
                <ol reversed>
                    <li>Фронтэнд</li>
                    <li>Бэкэнд</li>
                    <li>фулстэк</li>
                </ol>
                <p>Так же списки можно вкладывать друг в друга, при этом абсолютно неважна нумерация или ее отсутствие,
                    а
                    так же наличие атрибутов.</p>
                <p>Пример маркированного списка с вложенным нумерным реверсивным:</p>
                <ul>
                    <li>
                        Фронтэнд
                        <ol reversed>
                            <li>Mobile</li>
                            <li>UI</li>
                            <li>Node.js</li>
                        </ol>
                    </li>
                    <li>Бэкэнд</li>
                    <li>фулстэк</li>
                </ul>
                <p>Список определений включает себя тэг-контейнер "dl", вложенный в него тэг "dt", который содержит в
                    себе
                    термин, и тэг "dd", который содержит в себе определение </p>
                <p>пример:</p>
                <dl>
                    <dt>Front-end Developer</dt>
                    <dd>It's a person who works with the visible part of website</dd>
                    <dt>Back-end Developer</dt>
                    <dd>It's a person who works with hidden part of a website, including databases and environments</dd>
                </dl>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/nZ8XPmXn2Jk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
            <section>
                <h4 id="makingpictures">Оформление картинок</h4>

                <p>Стандартная конструкция для отображение пикчи: &lt;img src="ссылка на пикчу" alt="Just image"&gt; где
                    с
                    помощью "img src=" мы подгружаем картинку, а "alt='Just image'"- описание пикчи в случае если
                    браузер не
                    может ее отрисовать по каким-то причинам()</p>
                <p id="Billy">
                <pre>&lt;img src="../src/assets/imageExample.png" alt="image example"&gt;</pre>
                <div class="smallScreenContainer">
                    <img src="./assets/imageExample.png" alt="image example">
                </div>
                <br>
                <p>Тк вебстраница может быть просмотрена на разных устройствах, то требуется оптимизация картинок под
                    различные экраны, в данном случае можно использовать тэг-контейнер "picture"</p>
                <p>Пример верстки:</p>
                <pre>
&lt;picture&gt;
    &lt;source media="(min-width: 1024px)" srcset="https://picsum.photos/600/600"&gt;
    &lt;source media="(min-width: 768px)" srcset="https://picsum.photos/300/300"&gt;
    &lt;source media="(min-width: 360px)" srcset="https://picsum.photos/100/100"&gt;
    &lt;img src="https://picsum.photos/300/300" alt="Just image"&gt;
&lt;/picture&gt;
        </pre>
                <!--        <picture>-->
                <!--                <source media="(min-width: 1024px)" srcset="https://picsum.photos/600/600">-->
                <!--                <source media="(min-width: 768px)" srcset="https://picsum.photos/300/300">-->
                <!--                <source media="(min-width: 360px)" srcset="https://picsum.photos/100/100">-->
                <!--                <img src="https://picsum.photos/300/300" alt="Just image">-->
                <!--        </picture>-->
                <br>
                <p>Если нужно дать коммент к пикче то используется тэг-контейнер "fugure", а так же тэг "figcaption",
                    который и задает собственно описание пикчи. Данная конструкция может описать сразу несколько
                    картинок.</p>
                <p>Пример верстки:</p>
                <pre>
&lt;figure&gt;
   &lt;img src="../src/assets/imageExample.png" alt="Just image" /&gt;
   &lt;figcaption&gt;It is a simple description for a picture above&lt;/figcaption&gt;
&lt;/figure&gt;
        </pre>
                <figure>
                    <div class="smallScreenContainer">
                        <img src="./assets/imageExample.png" alt="Just image">
                    </div>
                    <figcaption>It is a simple description for a picture above</figcaption>
                </figure>
                <figure class="figureExampleStyle">
                    <img src="./assets/imageExample.png" alt="Just image">
                    <img src="./assets/imageExample.png" alt="Just image">
                    <img src="./assets/imageExample.png" alt="Just image">
                    <figcaption>
                        <p>It is a simple description for a couple pictures above.</p>
                    </figcaption>
                </figure>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/Fm0gSGQFmec" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
            <section>
                <h4 id="tables">Таблицы</h4>

                <p>Теги для создания таблиц.</p>
                <p>Таблицы строятся последовательно вложенными тегами:</p>
                <ol>
                    <li>Во-первых идёт главный образующий тег <code>&lt;table&gt;&lt;/table&gt;</code></li>
                    <li>После тега table идёт тег заголовка <code>&lt;caption&gt;&lt;/caption&gt;</code> (если
                        требуется)
                    </li>
                    <li>Далее таблица делится на три основные части:
                        <ul>
                            <li>
                                Cтрока заголовка/шапка таблицы: <code>&lt;thead&gt;&lt;/thead&gt;</code>. Нужен для
                                хранения одной или нескольких
                                строк, которые представлены вверху таблицы. Используется только 1 раз в 1 таблице. Чтобы
                                заголовок был выделен жирным шрифтом, вместо тега td нужно использовать тег <code>&lt;th&gt;&lt;/th&gt;</code>.
                            </li>
                            <li>
                                Основная часть таблицы: <code>&lt;tbody&gt;&lt;/tbody&gt;</code>. Предназначен для
                                хранения основного контента
                                таблицы. Может содержать неограниченное количество строк. Может повторятся несколько раз
                                в 1
                                таблице.
                            </li>
                            <li>
                                Низ таблицы/футер/”подвал” (итоги, результаты): <code>&lt;tfoot&gt;&lt;/tfoot&gt;</code>.
                                Нужен для хранения
                                одной или нескольких строк, которые идут внизу таблицы. Используется только 1 раз в 1
                                таблице.
                            </li>
                        </ul>
                    </li>
                </ol>
                <p>Эти теги идут строго друг за другом!</p>
                <p>Внутренная организация таблицы</p>
                <ul>
                    <li>Чтобы образовать строку таблицы, используется тег <code>&lt;tr&gt;&lt;/tr&gt;</code> (table row,
                        табличная
                        строка).
                    </li>
                    <li>Чтобы образовать ряд таблицы (ячейку с информацией), используется тег <code>&lt;td&gt;&lt;/td&gt;</code>
                        (table data, данные). Ячейка таблицы записывается уже с какой-либо информацией.
                    </li>
                    <li>Чтобы объединить несколько ячеек, используется тег td с атрибутами:
                        <ul>
                            <li>Colspan – объединяет ячейки по горизонтали.</li>
                            <li>Rowspan – объединяет ячейки по вертикали.</li>
                            <li>В качестве значений указываются числа, которые отображают сколько ячеек должно быть
                                объединено.
                            </li>
                        </ul>
                    </li>
                </ul>
                <p>Примеры верстки таблиц</p>
                <table>
                    <caption>Team members list</caption>
                    <thead>
                    <tr>
                        <td>Speciality</td>
                        <td>Quantity</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>Front-end</td>
                        <td>1 Person</td>
                    </tr>
                    <tr>
                        <td>Back-end</td>
                        <td>7 Persons</td>
                    </tr>
                    <tr>
                        <td>Full-stack</td>
                        <td>2 Persons</td>
                    </tr>
                    <tr>
                        <td>QA</td>
                        <td>5 Persons</td>
                    </tr>
                    </tbody>
                    <tfoot>
                    <tr>
                        <td></td>
                        <td>15</td>
                    </tr>
                    </tfoot>
                </table>
                <p>с обьединенными ячейками и семантическим выделением наименований столбцов:</p>
                <table>
                    <caption>Team members list</caption>
                    <thead>
                    <tr>
                        <th>Speciality</th>
                        <th>Quantity</th>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>Front-end</td>
                        <td>1 Person</td>
                    </tr>
                    <tr>
                        <td>Back-end</td>
                        <td>7 Persons</td>
                    </tr>
                    <tr>
                        <td>Full-stack</td>
                        <td>2 Persons</td>
                    </tr>
                    <tr>
                        <td>QA</td>
                        <td>5 Persons</td>
                    </tr>
                    </tbody>

                    <tfoot>
                    <tr>
                        <td colspan="2">15</td>
                    </tr>
                    </tfoot>
                </table>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/FA0jjOjTChA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
            <section>
                <h4 id="linksandbuttons">Ссылки и кнопки</h4>

                <p>Ссылки:</p>
                <p>Ссылка задается тегом с атрибутом:</p>
                <pre>&lt;а href="ссылка на сайт"&gt;Имя ссылки&lt;/a&gt;</pre>
                <p>Пример с переходом в текущей странице браузера:</p>
                <a href="https://youtube.com/YauhenKavalchuk">EXAMPLE</a>
                <hr>
                <p>Приоритетно, чтобы ссылка открывалась на новой странице браузера, тогда в этом случае нужно задать
                    атрибут:</p>
                <pre>&lt;a и функции id=href="ссылка на сайт" target="_blank"&gt;Имя ссылки&lt;/a&gt;</pre>
                <a href="https://youtube.com/YauhenKavalchuk" target="_blank">Канал webDev Кавальчука</a>
                <hr>
                <p>Так же для функции href есть значения tel/mailto/skype.</p>
                <p>Пример верстки и результирующие:</p>
                <pre>&lt;a href="tel:номер телефона"&gt;текст который будет виден на вебстрке &lt;/a&gt;</pre>
                <a href="tel:88005553535">88005553535</a>
                <pre>&lt;a href="mailto:емейл на который хотим написать"&gt;текст который будет виден на вебстр&lt;/a&gt;</pre>
                <a href="mailto:someEmail@mail.ru">someEmail@mail.ru</a>
                <pre>&lt;a href="skype:скайп на который хотим позвонить"&gt;текст который будет виден на вебстр&lt;/a&gt;</pre>
                <a href="skype:someSkype">someSkype</a>
                <hr>
                <p>Чтобы было удобно передвигаться по странице с ключевой точки, например с некоего примера, на текст
                    описывающий этот пример, можно создать кнопку следующего типа:
                <pre>&lt;а href="#айди атрибут"&gt;Отображаемый текст&lt;/а&gt;</pre>
                <pre>&lt;p id="айди атрибут"&gt;...&lt;/p&gt;</pre>
                <a href="#Billy">ссылка на картинку</a>
                <hr>
                <p>Кнопки:</p>
                <p>Что же касается кнопок - это не самостоятельный элемент который задается следующей конструкцией:</p>
                <pre>&lt;button type="button/submit/reset(выбрать одно из)"&gt;Имя кнопки&lt;/button&gt;</pre>
                <p>Тип button определяет просто кнопку, далее ей объявляют логику в JS. Тип submit может отправить
                    форму,
                    а reset очистить введеные данные.</p>
                <button type="button">Просто кнопка</button>
                <button type="reset">Кнопка reset</button>
                <button type="submit">Кнопка submit</button>
                <p>Так же для кнопок есть функция autofocus, при открытии страницы кнопка с этим атрибутом сразу
                    выделится:</p>
                <button type="button">Кнопка</button>
                <p>Функция disabled делает кнопку не активной:</p>
                <button type="button" disabled>Заблокированная кнопка</button>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/I8VAlRiGpq4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
            <section>
                <h4 id="usefultags">Полезные тэги</h4>

                <p>Тэг "abbr"- пользуется для расшифровки аббревиатур:</p>
                <pre>&lt;abbr title="HyperText Markup Language"&gt;<code><abbr
                        title="HyperText Markup Language">HTML</abbr></code>&lt;/abbr&gt;</pre>
                <hr>
                <p>Тэг "datalist" позволяет создать список опций из которых можно выбрать одну опцию, создается список
                    при
                    помощи связки тэгов "input","datalist" и "option":</p>
                <pre>
&lt;input list="list"&gt;
&lt;datalist id="list"&gt;
    &lt;option value="Front-end"&gt;&lt;/option&gt;
    &lt;option value="Back-end"&gt;&lt;/option&gt;
    &lt;option value="Full-stack"&gt;&lt;/option&gt;
    &lt;option value="Boy Next Door"&gt;&lt;/option&gt;
&lt;/datalist&gt;
        </pre>

                <input aria-label="list input" list="list">
                <datalist id="list">
                    <option value="Front-end"></option>
                    <option value="Back-end"></option>
                    <option value="Full-stack"></option>
                    <option value="Boy Next Door"></option>
                </datalist>
                <p>Тег "meter"- визуальное отображение некоего прогресса в неком диапазоне:</p>
                <pre>&lt;meter value="0" max="100" low="10" high="60"&gt;Course Progress&lt;/meter&gt;</pre>
                <br>

                <meter value="0" max="100" low="10" high="60">Course Progress</meter>
                <br>
                <meter value="20" max="100" low="40" high="60">Course Progress</meter>
                <br>
                <meter value="80" max="100" low="10" high="60">Course Progress</meter>
                <br>
                <meter value="100" max="100">Course Progress</meter>
                <hr>
                <p>Тэг "progress" визуально задает некий прогресс какой-то выполняемой операции:
                <pre>&lt;progress value="30" max="100"&gt;&lt;/progress&gt;</pre>
                <progress value="30" max="100"></progress>
                <hr>
                <p>Тэг "marked" позволяет выделить важный момент в тексте</p>
                <h2>To know HTML
                    <mark>semantic</mark>
                    is important
                </h2>
                <hr>
                <p>Тэг "canvas" создает область в которой можно рисовать при помощи JS</p>
                <canvas id="example" width="200" height="200"></canvas>
                <pre>
            <code>
&lt;script&gt;
    const drawingCanvas = document.getElementById('example');
    if(drawingCanvas && drawingCanvas.getContext) {
        const context = drawingCanvas.getContext('2d');
        context.fillStyle = "#000";
        context.beginPath();
        context.arc(100,100,100,0,Math.PI*2,true);
        context.closePath();
        context.stroke();
        context.fill();
    }
&lt;/script&gt;
            </code>
        </pre>
                <script>
                    const drawingCanvas = document.getElementById('example');
                    if (drawingCanvas && drawingCanvas.getContext) {
                        const context = drawingCanvas.getContext('2d');
                        context.fillStyle = "#969f15";
                        context.beginPath();
                        context.arc(100, 100, 100, 0, Math.PI * 2, true);
                        context.closePath();
                        context.stroke();
                        context.fill();
                    }
                </script>
            </section>


            <section>
                <h4 id="globsitestruct">Глобальная структура сайта</h4>

                <p>Глобальная структура сайта создается при помощи набора тегов хронящих в себе различные разделы
                    сайта:</p>
                <ul>
                    <li>"header"- Задает шапку сайта или раздел в котором обычно распологается заголовок</li>
                    <li>"nav"-Задает навигацию по сайту(допустимо использование несколько nav в одном документе</li>
                    <li>"main"- тег предназначенный для основного содержимого в документе</li>
                    <li>"section"- применяется для блока новостей, контактной информации, глав текста, различных
                        описаний,
                        самый универсальный тег для хранения информации
                    </li>
                    <li>"aside"- т.н. СайдБар или боковая панель. Определяет блок сбоку от основного контента,
                        предназначен
                        для размещения ссылок, банеров, дополнительной навигации и меток.
                    </li>
                    <li>"footer"- он же подвал сайта. Содержит в себе имя автора, дату документа, контактную информацию,
                        копирайт и ссылки на соцсети.
                    </li>
                </ul>
                <p>Все глобальные теги можно разделить на две группы: теги расположения и теги содержания.</p>
                <p>Теги расположения отвечают за то, где находится тот или иной элемент на странице, к ним относятся
                    "header", "main", "nav", "aside" и "footer". Предназначены для определения позиции группы
                    элементов</p>
                <p>К тегам содержания можно отнести: "article", "figure", а так же аудио и видео теги. Эти же теги
                    сообщают
                    о типе контента.</p>
                <a href="./public/flexboxExample.html" target="_blank">Пример flexbox верстки страницы.</a>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/N-2-kF1q6j4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
            <section>
                <h4 id="form">Форма</h4>
                <p>Пример самой элементарной формы:</p>

                <pre>
&lt;form action="formhander.php" name="single form" autocomplete="on"&gt;
    &lt;input type="text"&gt;
    &lt;br&gt;
    &lt;select&gt;
        &lt;option value="Front-end"&gt;Front-end&lt;/option&gt;
        &lt;option value="Back-end"&gt;Back-end&lt;/option&gt;
    &lt;/select&gt;
    &lt;br&gt;
    &lt;textarea rows="10" cols="45" name="text"&gt;&lt;/textarea&gt;
    &lt;br&gt;
    &lt;input type="submit"&gt;
    &lt;br&gt;
&lt;/form&gt;
        </pre>

                <form action="formHandler.php" name="single form" autocomplete="on">
                    <input aria-label="text input" type="text">
                    <br>
                    <select aria-label="selector">
                        <option value="Front-end">Front-end</option>
                        <option value="Back-end">Back-end</option>
                    </select>
                    <br>
                    <textarea style="width: 250px" aria-label="textarea" rows="10" cols="45" name="text"></textarea>
                    <br>
                    <input type="submit">
                    <br>
                </form>
                <hr>

                <pre>
&lt;form action="formhander.php" name="simple form2" autocomplete="on"&gt;
    &lt;fieldset&gt;
        &lt;legend&gt;Simple form legend&lt;/legend&gt;
        &lt;input type="text"&gt;
        &lt;br&gt;
        &lt;select&gt;
            &lt;option value="Front-end"&gt;Front-end&lt;/option&gt;
            &lt;option value="Back-end"&gt;Back-end&lt;/option&gt;
        &lt;/select&gt;
        &lt;br&gt;
        &lt;textarea rows="10" cols="45" name="text"&gt;&lt;/textarea&gt;
        &lt;br&gt;
        &lt;input type="submit"&gt;
        &lt;br&gt;
    &lt;/fieldset&gt;
&lt;/form&gt;
        </pre>

                <form action="formHandler.php" name="simple form2" autocomplete="on">
                    <fieldset>
                        <legend>Simple form legend</legend>
                        <input aria-label="text input" type="text">
                        <br>
                        <select aria-label="selector">
                            <option value="Front-end">Front-end</option>
                            <option value="Back-end">Back-end</option>
                        </select>
                        <br>
                        <textarea aria-label="textarea" rows="10" cols="45" name="text" style="width: 250px"></textarea>
                        <br>
                        <input type="submit">
                        <br>
                    </fieldset>
                </form>
                <hr>
                <p>Так же "fieldset" можно применять для визуального разделения форм на составные:</p>
                <form action="formHandler.php" name="simple form3">

                    <fieldset>
                        <legend>Personal data</legend>
                        <input aria-label="text input" type="text"><br>
                        <select aria-label="selector">
                            <option value="Front-end">Front-end</option>
                            <option value="Back-end">Back-end</option>
                        </select><br>
                    </fieldset>
                    <fieldset>
                        <legend>Personal Message</legend>
                        <textarea style="width: 250px" aria-label="textarea" rows="10" cols="45" name="text"></textarea><br>
                    </fieldset>
                    <input type="submit">
                </form>
                <hr>
                <p> Тэг "label" добавляет метку для элемента формы и устанавливает связь между этой меткой и полем, при
                    нажатии на элемент - курсор устанавливается на форме:</p>
                <p> Пример использования тэга "label":</p>

                <pre>
&lt;form action="formHandler.php" name="simple form3"&gt;
   &lt;fieldset&gt;
      &lt;legend&gt;Personal data&lt;/legend&gt;
      &lt;label for="name"&gt;Your name&lt;/label&gt;
      &lt;input type="text" id="name" /&gt;&lt;br&gt;
      &lt;label for="speciality"&gt;Choose your speciality&lt;/label&gt;
      &lt;select id="speciality"&gt;
         &lt;option value="Front-end"&gt;Front-end&lt;/option&gt;
         &lt;option value="Back-end"&gt;Back-end&lt;/option&gt;
      &lt;/select&gt;&lt;br&gt;
   &lt;/fieldset&gt;
   &lt;fieldset&gt;
      &lt;legend&gt;Personal Message&lt;/legend&gt;
      &lt;label for="message"&gt;Enter your message&lt;/label&gt;
      &lt;textarea id="message" rows="10" cols="45" name="text"&gt;&lt;/textarea&gt;&lt;br&gt;
   &lt;/fieldset&gt;
   &lt;input type="submit"&gt;
   &lt;br&gt;
&lt;/form&gt;
&lt;hr&gt;
        </pre>
                <hr>
                <form action="formHandler.php" name="simple form3">
                    <fieldset>
                        <legend>Personal data</legend>
                        <label for="name">Your name</label>
                        <input type="text" id="name"><br>
                        <label for="speciality">Choose your speciality</label>
                        <select id="speciality">
                            <option value="Front-end">Front-end</option>
                            <option value="Back-end">Back-end</option>
                        </select><br>
                    </fieldset>
                    <fieldset>
                        <legend>Personal Message</legend>
                        <label for="message">Enter your message</label>
                        <textarea style="width: 250px" id="message" rows="10" cols="45" name="text"></textarea><br>
                    </fieldset>
                    <input type="submit">
                    <br>
                </form>
                <hr>
                <p>Тэг "textarea" имеет множество атрибутов, например "rows" и "cols", которые задают размер формы:</p>
                <pre>&lt;textarea rows="10" cols="45"&gt;&lt;/textarea&gt;&lt;textarea rows="5" cols="20"&gt;&lt;/textarea&gt;</pre>
                <textarea style="width: 250px" aria-label="textarea" rows="10" cols="45"></textarea>
                <textarea style="width: 250px" aria-label="textarea" rows="5" cols="20"></textarea>
                <br>
                <p>Атрибут name="" задает имя форме:</p>
                <pre>&lt;textarea rows="5" cols="20" name="test"&gt;&lt;/textarea&gt;&lt;br&gt;</pre>
                <textarea aria-label="textarea" rows="5" cols="20" name="test"></textarea><br>
                <p>Атрибут autofocus автоматически фокусирует поле</p>
                <pre>&lt;textarea rows="5" cols="20" autofocus&gt;&lt;/textarea&gt;&lt;br&gt;</pre>
                <textarea aria-label="textarea" rows="5" cols="20"></textarea><br>
                <p>Тэг "disabled" блокирует форму:</p>
                <pre>&lt;textarea rows="5" cols="20" disabled>&lt;/textarea&gt;&lt;br&gt;</pre>
                <textarea aria-label="textarea" rows="5" cols="20" disabled></textarea><br>
                <p>Тэг "readonly" записывает в форму текст, который невозможно изменить:</p>
                <pre>&lt;textarea rows="5" cols="20" readonly&gt;This text you can't change&lt;/textarea&gt;&lt;br&gt;</pre>
                <textarea aria-label="textarea" rows="5" cols="20" readonly>This text you can't change</textarea><br>
                <p>Тэг "placeholder" добавляет текст-заменитель,самый используемый атрибут:</p>
                <pre>&lt;textarea rows="5" cols="20" placeholder="your message..."&gt;&lt;/textarea&gt;&lt;br&gt;</pre>
                <textarea aria-label="textarea" rows="5" cols="20" placeholder="your message..."></textarea><br>
                <p>Тэг "maxlength" устанавливает для вводимых символов</p>
                <pre>&lt;textarea rows="5" cols="20" maxlength="5"&gt;&lt;/textarea&gt;&lt;br&gt;</pre>
                <textarea aria-label="textarea" rows="5" cols="20" maxlength="5"></textarea><br>
                <p>Тэг "required" задает обязательным заполнение поля:</p>
                <pre>
&lt;form&gt;
    &lt;textarea rows="5" cols="20" required&gt;&lt;/textarea&gt;&lt;br&gt;
    &lt;input type="submit" value="send"&gt;
&lt;/form&gt;
        </pre>

                <form>
                    <textarea aria-label="textarea" rows="5" cols="20" required></textarea><br>
                    <input type="submit" value="send">
                </form>
                <hr>
                <p>Тэг "select" создает поле с выпадающим списком, имеет все ранее рассмотренные атрибуты, а так же
                    дополнительно следующие:</p>
                <p>Тэг "multiple", позволяет сделать несколько выборов из списка:</p>
                <pre>
&lt;select multiple&gt;
   &lt;option value="Front-end"&gt;Front-end&lt;/option&gt;
   &lt;option value="Back-end"&gt;Back-end&lt;/option&gt;
&lt;/select&gt;
        </pre>
                <select aria-label="selector" multiple>
                    <option value="Front-end">Front-end</option>
                    <option value="Back-end">Back-end</option>
                </select>
                <hr>
                <p>Атрибуты "sel" и "dis" автоматически выбирают или блокируют элементы из списка</p>
                <select aria-label="selector">
                    <option value="Front-end">Front-end</option>
                    <option value="Back-end" label="Back-end"></option>
                    <option value="sel" selected>Selected</option>
                    <option value="dis" disabled>Disabled</option>
                </select>
                <p>Тэг "optgroup" разделяет выбор по группам:</p>
                <pre>
&lt;select&gt;
   &lt;optgroup label="Speciality"&gt;
      &lt;option value="Front-end"&gt;Front-end&lt;/option&gt;
      &lt;option value="Back-end"&gt;Back-end&lt;/option&gt;
   &lt;/optgroup&gt;
   &lt;optgroup label="Direction"&gt;
      &lt;option value="Mobile"&gt;Mobile development&lt;/option&gt;
      &lt;option value="Node"&gt;Node.js development&lt;/option&gt;
   &lt;/optgroup&gt;
&lt;/select&gt;
&lt;hr&gt;
        </pre>
                <select aria-label="selector">
                    <optgroup label="Speciality">
                        <option value="Front-end">Front-end</option>
                        <option value="Back-end">Back-end</option>
                    </optgroup>
                    <optgroup label="Direction">
                        <option value="Mobile">Mobile development</option>
                        <option value="Node">Node.js development</option>
                    </optgroup>
                </select>
                <hr>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/JSmINYpl5B4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        -->
            <section>
                <h4 id="inputtypes">Типы полей ввода</h4>

                <p>Элемент "number" у тега "input" предназначен для введения ТОЛЬКО числовых значений. "min"/"max"-
                    миним/максимальные значения, "step"- шаг изменения числа:</p>
                <pre>&lt;input type="number" min="0" max="100" step="2"&gt;</pre>
                <input aria-label="number input" type="number" min="0" max="100" step="2">
                <br>
                <hr>
                <p>Элемент "password" предназначен для задания поля пароля</p>
                <pre>&lt;input type="password"&gt;</pre>
                <input aria-label="password input" type="password">
                <hr>
                <p>Элемент "date" задает поле выбора даты</p>
                <pre>&lt;input type="date"&gt;</pre>
                <input aria-label="date input" type="date">
                <hr>
                <p>Элемент "color" предназначен для поля выбора цвета:</p>
                <pre>&lt;input type="color"&gt;</pre>
                <input aria-label="color input" type="color">
                <hr>
                <p>Элемент "submit" и "reset",создают кнопки "отправить" и "сбросить" соответственно. Работают только
                    внутри
                    компонента формы. Для изменения названия кнопки используется атрибут "value":</p>
                <pre>&lt;input type="submit" value="отправить"&gt;&lt;input type="reset" value="сбросить"&gt;</pre>
                <input type="submit" value="отправить"><input type="reset" value="сбросить">
                <hr>
                <p>Элемент "text" совместно с "list" задают выпадающий список опций:</p>
                <pre>
&lt;input type="text" list="list1"&gt;
&lt;datalist id="list1"&gt;
   &lt;option value="Front-end"&gt;&lt;/option&gt;
   &lt;option value="Back-end"&gt;&lt;/option&gt;
   &lt;option value="Full-stack"&gt;&lt;/option&gt;
&lt;/datalist&gt;
        </pre>
                <input aria-label="list1" type="text" list="list1">
                <datalist id="list1">
                    <option value="Front-end"></option>
                    <option value="Back-end"></option>
                    <option value="Full-stack"></option>
                </datalist>
                <hr>
                <p>Элемент "emmail" предназначен для создания поля ввода емейл. Автоматически валидирует введенное в
                    строку
                    на предмет @ и точки:</p>
                <pre>
&lt;form action="formhander.php" name="simple form5" autocomplete="on"&gt;
    &lt;input type="email"&gt;
    &lt;input type="submit"&gt;
&lt;/form&gt;
        </pre>
                <form action="formHandler.php" name="simple form5" autocomplete="on">
                    <input aria-label="email input" type="email">
                    <input type="submit">
                </form>
                <hr>
                <p>Элемент "url" предназначен для создания поля ввода адреса вебстраницы, так же валидирует введенное
                    значение:</p>
                <pre>
&lt;form action="formhander.php" name="simple form6" autocomplete="on"&gt;
    &lt;input type="url"&gt;
    &lt;input type="submit"&gt;
&lt;/form&gt;
        </pre>
                <form action="formHandler.php" name="simple form6" autocomplete="on">
                    <input aria-label="url input" type="url">
                    <input type="submit">
                </form>
                <hr>
                <p>Элемент "image" создает своеобразную кнопку из картинки:</p>
                <pre>
&lt;form action="formhander.php" name="simple form7" autocomplete="on"&gt;
   &lt;input type="image" src="../src/assets/imageExample.png" width="50" height="30" alt="just gachiimage"&gt;
&lt;/form&gt;
        </pre>
                <form action="formHandler.php" name="simple form7" autocomplete="on">
                    <input type="image" src="./assets/imageExample.png" width="50"
                           height="30" alt="imageExample">
                </form>
                <hr>
                <p>Элемент "tel" создает поле ввода для номера телефона, если открыть ссылку в браузере телефона, то при
                    выборе поля откроется клавиатура для набора номера:</p>
                <pre>&lt;imput type="tel"&gt;</pre>
                <input aria-label="tel input" type="tel">
                <hr>
                <p>Элемент "search" создает поле для введения поисковых запросов:</p>
                <pre>&lt;input type="search"&gt;</pre>
                <input aria-label="search input" type="search">
                <hr>
                <p>Элемент "datetime-local" похож на "date", но использует формат времени пользователя и дополнительно
                    имеет
                    время*:</p>
                <pre>&lt;input type="datetime-local"&gt;</pre>
                <input aria-label="datetime-local input" type="datetime-local">
                <hr>
                <p>Элемент "month" относится к предыдущим и позволяет выбрать только месяц´*:</p>
                <pre>&lt;input type="month"&gt;</pre>
                <input aria-label="month input" type="month">
                <hr>
                <p>Элемент "time" предназначен для введения только времени*:</p>
                <pre>&lt;input type="time"&gt;</pre>
                <input aria-label="time input" type="time">
                <hr>
                <p>Элемент "week" выводит только неделю*:</p>
                <pre>&lt;input type="week"&gt;</pre>
                <input aria-label="week input" type="week">
                <hr>
                <p>*ВАЖНО!!! элементы дат поддерживаются не всеми браузерами!</p>
                <p>Элемент "hidden" c атрибутом "value"- данный элемент скрывает дополнительное значение "value",
                    используется для корректной работы скриптов или трекинга информации:</p>
                <pre>&lt;input type="hidden" value="webDew"&gt;</pre>
                <p>(внизу под скриптом между двумя <code>&lt;hr&gt;</code> невидимый результат)</p>
                <hr>
                <input type="hidden" value="webDew">
                <hr>
                <p>Элемент "file"- предназначен для хранения и передачи пользовательских файлов на сервер. Имеет атрибут
                    "multiple"(позволяет загружать несколько файлов):</p>
                <pre>&lt;input type="file" multiple&gt;</pre>
                <input type="file" multiple>
                <hr>
                <p>Элемент "checkbox" и "radio" предназначены для выбора каких-то дополнительных опций, "checkbox"
                    позволяет
                    выбрать несколько опций, а "radio" только одну, атрибут checked позволяет выбрать опцию по
                    умолчанию:</p>
                <pre>&lt;label&gt;&lt;input type="checkbox" value="обозначениe checkbox(z.B. option1)" checked(опция поумолчанию)&gt;Имя опции&lt;label&gt;</pre>
                <pre>&lt;label&gt;&lt;input type="radio" name="value" value="z.B. option1" checked(опция по умолчанию, у radio толькоодин раз)&gt;Имя опции&lt;/label&gt;</pre>
                <label><input type="checkbox" value="option1" checked>Front-end</label>
                <br>
                <label><input type="checkbox" value="option2">Back-end</label>
                <br>
                <label><input type="checkbox" value="option3">Full-stack</label>
                <br>
                <label><input type="radio" name="value" value="option1" checked>Front-end</label>
                <br>
                <label><input type="radio" name="value" value="option2">Back-end</label>
                <br>
                <label><input type="radio" name="value" value="option3">Full-stack</label>
                <hr>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/t4y7atN_RJY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
            <section>
                <h4 id="vaf">Видео и аудио файлы</h4>

                <p>Теги "audio src=" и "video src=" добавляют аудио и видео файлы на страницу. Есть два способа
                    подключения:</p>

                <pre>&lt;audio controls src="аудиофайл.формат"&gt;Отображаемый текст в случае невозможности воспроизведения&lt;/audio&gt;</pre>
                <audio preload="none" controls src="./assets/example.mp3">Your browser does not support the audio tag.
                </audio>
                <pre>
&lt;audio controls&gt;
   &lt;source src="аудиофайл.формат" type="audio/формат"&gt;
&lt;/audio&gt;:
        </pre>
                <audio controls preload="none">
                    <source src="./assets/example.mp3" type="audio/mp3">
                </audio>

                <pre>&lt;video controls width="560" height="315" src="видеофайл.формат"&gt;Отображаемый текст в случае невозможности воспроизведения&lt;/video&gt;</pre>
                <div class="smallScreenContainer">
                    <video preload="none" src="./assets/example.mp4" muted controls></video>
                </div>
                <pre>
&lt;video poster="preview.png" preload="auto" muted controls width="560" height="315"&gt;
    &lt;source src="видеофайл.формат" type="video/ogg(f.e.)"&gt;
    &lt;source src="видеофайл.формат" type="video/mp4(f.e.)"&gt;
    "Отображаемый текст в случае невозможности воспроизведения"
&lt;/video&gt;:
        </pre>
                <!-- width="560" height="315" -->
                <div class="smallScreenContainer">
                    <video class="smallScreenContainer" poster="assets/preview.png" preload="none" muted controls>
                        <!-- <source src="example.ogg" type="video/ogg"> -->
                        <source src="./assets/example.mp4" type="video/mp4">
                        "Your browser does not support the audio tag."
                    </video>
                </div>
                <p>Набор поддерживаемых тегов практически одинаковый:</p>
                <ol>
                    <li>width/height- размер окна видео.</li>
                    <li>controls- добавляет элементы контроля для медийных файлов.</li>
                    <li>loop- запускает бесконечное воспроизведение аудио/видео файлов.</li>
                    <li>autoplay- автоматическое воспроизведение аудио/видео файла.(использовать осторожно!)</li>
                    <li>muted- позволяет убрать звук у файла по умолчанию при загрузке страницы</li>
                    <li>poster="адрес картинки" - добавляет постер к видео пока оно грузится или не доступно.</li>
                    <li>preload="auto/metadata/none"- auto-Загрузить видео целиком при загрузке страницы;
                        metadata-Загрузить
                        только служебную информацию (размеры видео, первый кадр, продолжительность и др.); none-Не
                        загружать
                        видео.
                    </li>
                </ol>
            </section>

            <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/EfiZ4RUOm_o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
            <section>
                <h4 id="comusfattrib">Общие и полезные атрибуты.</h4>

                <p>Атрибут "id=" используется для подключения навигации и JS.</p>
                <p>Атрибут "class=" используется для связывания тега с определенными стилями. Классов может быть
                    несколько:</p>
                <pre>&lt;p class="text idea"&gt;текст&lt;/p&gt;</pre>
                <p>Атрибут
                    <ins title="добавляет всплывающую подсказку для текста если на него навести курсор.">"title="</ins>
                    добавляет всплывающую подсказку для текста если на него навести курсор.
                </p>
                <p>Атрибут "style" - с помощью этого атрибута можно добавить стили. Лучше использовать CSS ибо приоритет
                    отдается "style" и в CSS нужно будет городить колхоз в виде атрибута important.</p>
                <p>Атрибут "contenteditable=" добавляет возможность пользователю изменить текст под этим атрибутом, сам
                    по
                    себе текст в HTML не изменяется, изменение видит только пользователь:<span contenteditable="true">Этот текст можно изменить</span>
                </p>
                <p>Атрибут "spellcheck=true" включает проверку правописания. Применяется к тегам "imput", "textarea", а
                    так
                    же к тегам у которых есть атрибут "contenteditable". В браузере должна быть включена проверка
                    правописания:<span contenteditable="true" spellcheck="true">Этат текст можна изминить.</span></p>
                <p>Атрибут "tabindex" позволяет передвигать курсор по странице при помощи tab по заданным меткам.
                    Используется для улучшения аксесебилити.</p>
                <p>Атрибуты "dir" и "lang" используются при работе с нюансами разных языков. "dir" задает направление
                    тексту, "lang" позволяет задать код языка, в резуьтате чего включаются грамматические особенности
                    выбранного языка.</p>
            </section>
        </section>

        <section id="CSSnav">
            <h2 id="CSSBasics">Основы CSS</h2>

            <section id="CSSBasicsNav">
                <h3 id="baseCSS">Базовый CSS</h3>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/qxAnaoPI8cE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="basesintCSSappl">Базовый синтаксис и применение стилей</h4>

                    <p>Пример задания стиля однострочным вариантом:</p>
                    <pre>
&lt;style&gt;
   h1(f.e.) { color: red; }
&lt;/style&gt;
        </pre>
                    <p>либо многострочным вариантом:</p>
                    <pre>
&lt;style&gt;
   h1(f.e.) {
      color: red;
   }
&lt;/style&gt;
        </pre>
                    <p>Где "h1" является селектором, к которому мы обращаемся и стилизируем, а "color: red;"- блок
                        объявлений из
                        набора правил/declaration, правил может быть неограниченное количество. "color"- объявление
                        своства/property(то что планируем менять), "red"- значение/value на которое будет изменено
                        свойство.</p>
                    <p>Варианты подключения стилей</p>
                    <ol>
                        <li>Внутренние стили. Тэг "style" указывается внутри тэга "head" непосредственно в HTML
                            документе.
                            Пример:
                            <div class="smallScreenContainer">
                                <img src="./assets/example1.png" alt="example1">
                            </div>
                        </li>
                        <li>Инлайновые стили применяются непосредственно к определенному элементу. Не рекомендуется к
                            использованию!
                            Пример с результатом:
                            <ul>
                                <li><code>&lt;bb style="color:blue"&gt;</code>Hello World!<code>&lt;/bb&gt;</code></li>
                                <li>
                                    <p style="color:blue">Hello World!</p>
                                </li>
                            </ul>
                        <li>При подключение внешних стилей создается отдельный файл с расширением .css в котором
                            описывается
                            весь
                            CSS код. Пример подключения:
                            <ul>
                                <li><code>&lt;link rel="stylesheet" href="styles.css"&gt;Базовый пример подключения
                                    middleware</code></li>
                            </ul>
                        <li>Импорт стилей из уже существующих файлов CSS. Импорт встраивается в текущий файл CSS.
                            Пример:
                            <div class="smallScreenContainer">
                                <img src="./assets/example2.png" alt="example2">
                            </div>
                        </li>
                    </ol>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/vnmfn31G988" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="simpsel">Простые селекторы</h4>

                    <p>Селектор это синтаксис который помогает выбрать элемент в HTML разметке и добавить на него
                        необходимые
                        стили.
                        Селектора делятся на простые и составные.</p>
                    <p>Простые селектора:</p>
                    <p>Селектор "*" именуемый универсальным селектором. Применяет стили ко всем элементам на
                        странице.</p>
                    <p>Селектор по имени тега. Применяет стили к выбранному тэгу.</p>
                    <p>Для более точного описания стилизируемого элемента применяются классы (class=""). Пример:</p>
                    <pre>
&lt;h2 class="heading1"&gt;Заголовок&lt;/h2&gt;
   .heading1 {
      text-decoration: underline;
   }
        </pre>
                    <h2 class="heading1">Заголовок</h2>
                    <p>Так же можно добавить стилизацию по "id" атрибуту. Пример:</p>
                    <pre>
&lt;p id="idAttributeExample"&gt;Условный текст&lt;/p&gt;
   #idAttributeExample {
      front-size: 25px
      border: 2px solid black;
   }
        </pre>
                    <p id="cond">Условный текст</p>
                    <p>Чтобы стилистика класса применялась к нужному тегу, нужно указать этот тег перед классом в
                        CSS:</p>
                    <pre>
искомый тег .заданный класс {
   заданный стиль
}
        </pre>
                    <p>Какой именно стиль будет применен в случае если к одному элементу их несколько, зависит от веса
                        примененных
                        стилей. У инлайнового стиля вес 1000, у стиля заданного id атрибутом вес 100, у стиля заданного
                        классом
                        атрибутом и псевдоатрибутом вес 10 и у стиля заданного тэгом(элементом) и псевдоэлементом вес
                        1.</p>
                    <pre>
body q.simple {
   color: aqua
}
        </pre>
                    <p>Вес селектора выше равен 12, по одному на два тега(body и q), и десять на класс(simple). Данная
                        конструкция называется составным селектором.</p>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/fyI_K_Oya74" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                -->
                <section>
                    <h4 id="compsel">Составные селекторы</h4>

                    <p>Составной селектор это комбинация селекторов, образующие новый более конкретный селектор.</p>
                    <ol>
                        <li>Групповые селектора:
                            <pre>
h1,
h2,
span {
   color: red;
}
                </pre>
                            <h2 class="example1">Hello world!(h2)</h2>
                            <h3 class="example1">Heading 1!(h3)</h3>
                            <span class="example1">Simple span element(span)</span>
                        </li>
                        <li>Селектор вложенности:
                            <pre>
div p {
  color: green;
}
div p span {
  color: blue;
}

&lt;div&gt;
   &lt;p&gt;Super &lt;span&gt;Paragraph&lt;/span&gt; 1&lt;/p&gt;
&lt;/div&gt;
                </pre>
                            <p class="example2">Super<span class="example3"> Paragraph</span> 1</p>
                            <p>Где "span" является дочерним элементом для "p", а "p"- для "div", "div" является
                                родительским
                                элементом для обоих.</p>
                        </li>
                        <li>Элемент прямого потомка:
                            <pre>
&lt;,&gt;
ul li > example4 {
    font-weight: bold;
}
&lt;ul&gt;
   &lt;li&gt;&lt;p&gt;&lt;span class="example4"&gt;Span 1&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
   &lt;li&gt;&lt;span class="example4"&gt;Span 2&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
                </pre>
                            <hr>
                            <ul>
                                <li><p><span class="example4">Span 1</span></p></li>
                                <li><span class="example4">Span 2</span></li>
                            </ul>
                            <hr>
                        </li>
                        <li>Элемент соседнего селектора:
                            <pre>
ul .example5 + .example5 {
   color: aqua;
}
&lt;ul&gt;
   &lt;li class="example5"&gt;Li 1&lt;/li&gt;
   &lt;li class="example5"&gt;Li 2&lt;/li&gt;
   &lt;li class="example5"&gt;Li 3&lt;/li&gt;
   &lt;li class="example5"&gt;Li 4&lt;/li&gt;
&lt;/ul&gt;
            </pre>
                            <hr>
                            <ul>
                                <li class="example5">Li 1</li>
                                <li class="example5">Li 2</li>
                                <li class="example5">Li 3</li>
                                <li class="example5">Li 4</li>
                            </ul>
                            <hr>
                        </li>
                        <li>Селектор "следующий элемент":
                            <pre>
br ~ .example6 {
font-size: 20px;
}

&lt;p class="example6"&gt;Paragraph 1&lt;/p&gt;
&lt;p class="example6"&gt;Paragraph 2&lt;/p&gt;
&lt;br /&gt;
&lt;p class="example6"&gt;Paragraph 3&lt;/p&gt;
&lt;p class="example6"&gt;Paragraph 4&lt;/p&gt;
                </pre>
                            <hr>
                            <p class="example6">Paragraph 1</p>
                            <p class="example6">Paragraph 2</p>
                            <br>
                            <p class="example6">Paragraph 3</p>
                            <p class="example6">Paragraph 4</p>
                        </li>
                        <li>Селектор атрибута:
                            <pre>
a[target] {
   backgroung-color: yellow;
}
a[target="_blank"] {
   backgroung-color: blue;
}

Проверка начала ссылки на соответствие:

a[href^="https://123"] {
   backgroung-color: aqua;
}

Проверка конца ссылки на соответствие:

a[href$=".jpg"] {
   backgroung-color: teal;
}

Проверка на наличие указанных символов:

a[href*="link1"] {
   backgroung-color: rebeccapurple;
}

&lt;div&gt;
    &lt;a href="http://test1.com">Test Link 1&lt;/a&gt;
    &lt;a href="http://test2.com" target="_blank"&gt;Test Link 2&lt;/a&gt;
    &lt;a href="http://test3.org" target="_top"&gt;Test Link 3&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;a href="http://test1.com"&gt;Test Link 1&lt;/a&gt;
    &lt;a href="http://test2.com" target="_blank"&gt;Test Link 2&lt;/a&gt;
    &lt;a href="http://test3.org" target="_top"&gt;Test Link 3&lt;/a&gt;
&lt;/div&gt;

&lt;div&gt;
    &lt;a href="http://123.com"&gt;Test Link 1&lt;/a&gt;
    &lt;a href="http://4link56.com" target="_blank"&gt;Test Link 2&lt;/a&gt;
    &lt;a href="http://678.jpg" target="_top"&gt;Test Link 3&lt;/a&gt;
&lt;/div&gt;
                </pre>
                            <div>
                                <a href="http://test1.com">Test Link 1</a>
                                <a href="http://test2.com" style="background-color: blue" target="_blank">Test Link
                                    2</a>
                                <a href="http://test3.com" style="background-color: yellow" target="_top">Test Link
                                    3</a>
                            </div>

                            <div>
                                <a href="http://test1.com">Test Link 1</a>
                                <a href="http://test2.com" style="background-color: blue" target="_blank">Test Link
                                    2</a>
                                <a href="http://test3.com" style="background-color: yellow" target="_top">Test Link
                                    3</a>
                            </div>

                            <div>
                                <a href="http://123.com" style="background-color: aqua">Test Link 1</a>
                                <a href="http://4link156.com" style="background-color: rebeccapurple" target="_blank"
                                   class="hrefWithLink">Test Link 2</a>
                                <a href="http://678.jpg" style="background-color: teal" target="_top">Test Link 3</a>
                            </div>
                        </li>
                    </ol>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/C40ePbYJxmM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="pseeleclass">Псевдоэлементы и псевдоклассы</h4>

                    <p>Псевдоклассы.</p>
                    <p class="example7">Чтобы цвет текста менялся по наведению мыши используют псевдокласс "hover":</p>
                    <pre>
.example7:hover {
   color: red;
}
                    </pre>
                    <a class="example7" href="https://www.youtube.com/YauhenKavalchuk" target="_blank">webDev YouTube
                        Chanel</a>
                    <p>Чтобы цвет ссылки менялся после посещения сайта используют псевдокласс "visited":</p>
                    <pre>
.example8:visited {
   color: aqua;
}
                    </pre>
                    <a class="example8" href="https://www.youtube.com/YauhenKavalchuk" target="_blank">webDev YouTube
                        Chanel</a>
                    <p>Чтобы цвет ссылки/кнопки менялся при клике мыши используют псевдокласс "active":</p>
                    <pre>
.example9:active {
    color: qreen;
}
                    </pre>
                    <a class="example9" href="https://www.youtube.com/YauhenKavalchuk" target="_blank">webDev YouTube
                        Chanel</a>
                    <hr>
                    <p>Псевдоэлементы.</p>
                    <p>Чтобы при передвижении по странице при помощи таба выделенный текст менялся- используют
                        псевдоэлемент
                        "focus":</p>
                    <pre>
.example10:focus {
   font-weight: bold;
}
                    </pre>
                    <a class="example10" href="https://www.youtube.com/YauhenKavalchuk" target="_blank">webDev YouTube
                        Chanel</a>
                    <p>При стилизации фрагмента текста используются два псевдоэлемента- "first-letter" и
                        "first-line":</p>
                    <pre>
.example11::first-letter {
   font-size: 30px;
}
.example11::first-line {
   text-decoration: underline;
}
                    </pre>
                    <p class="example11">Wer fremde Sprachen nicht kennt, weiß nichts von seiner eigenen.</p>
                    <p>Чтобы стилизировать выделение текста используют селектор "selection"(!размер текста увеличить
                        нельзя!):</p>
                    <pre>
.example12::selection {
   background-color: yellow;
   color: red;
}
                    </pre>
                    <p class="example12">Wer fremde Sprachen nicht kennt, weiß nichts von seiner eigenen.</p>
                    <p>Для добавления дополнительного текста и раздельной его стилизации используют псевдоэлементы
                        "before"
                        и
                        "after":
                    <pre>
.example13::before {
  content: "This is "
  text-transform: uppercase;
}
.example13::after {
  content: " lesson"
  color: red;
}
&lt;p clas="example13"&gt;CSS&lt;/p&gt;
        </pre>
                    <p class="example13">CSS</p>
                    <hr>
                    <p>Селектора для работы со списками "first-child", "last-child", и дополнительными значениями в
                        скобках
                        "even",
                        "odd", и номер элемента:</p>
                    <pre>
.list1 li:first-child {
   color: blue;
}
.list1 li:last-child {
   color: green;
}

&lt;ul class="list1"&gt;
   &lt;li&gt;One&lt;/li&gt;
   &lt;li&gt;Two&lt;/li&gt;
   &lt;li&gt;Three&lt;/li&gt;
   &lt;li&gt;Four&lt;/li&gt;
   &lt;li&gt;Five&lt;/li&gt;
   &lt;li&gt;Six&lt;/li&gt;
&lt;/ul&gt;
        </pre>
                    <ul class="list1">
                        <li>One</li>
                        <li>Two</li>
                        <li>Three</li>
                        <li>Four</li>
                        <li>Five</li>
                        <li>Six</li>
                    </ul>
                    <pre>
.list2 li:nth-child(even) {
   color: blue;
}
.list2 li:nth-child(odd) {
   color: green;
}
.list2 li:nth-child(3) {
   color: red !important;
}

&lt;ul class="list2"&gt;
   &lt;li&gt;One&lt;/li&gt;
   &lt;li&gt;Two&lt;/li&gt;
   &lt;li&gt;Three&lt;/li&gt;
   &lt;li&gt;Four&lt;/li&gt;
   &lt;li&gt;Five&lt;/li&gt;
   &lt;li&gt;Six&lt;/li&gt;
&lt;/ul&gt;
        </pre>
                    <ul class="list2">
                        <li>One</li>
                        <li>Two</li>
                        <li>Three</li>
                        <li>Four</li>
                        <li>Five</li>
                        <li>Six</li>
                    </ul>
                    <pre>
.list3 li:nth-child(3n+1) {
   text-transform: uppercase;
}
.list3 li:nth-child(2n+1) {
   color: aqua;
}

&lt;ul class="list3"&gt;
   &lt;li&gt;One&lt;/li&gt;
   &lt;li&gt;Two&lt;/li&gt;
   &lt;li&gt;Three&lt;/li&gt;
   &lt;li&gt;Four&lt;/li&gt;
   &lt;li&gt;Five&lt;/li&gt;
   &lt;li&gt;Six&lt;/li&gt;
&lt;/ul&gt;
        </pre>
                    <ul class="list3">
                        <li>One</li>
                        <li>Two</li>
                        <li>Three</li>
                        <li>Four</li>
                        <li>Five</li>
                        <li>Six</li>
                    </ul>
                    <br>
                    <p>"first-of-type", "last-of-type" и "nth-of-type()":</p>
                    <pre>
.text1 p:first-of-type {
   color: red;
}
.text1 p:nth-of-type(2) {
   text-transform: uppercase;
}
.text1 p:last-of-type {
   color: aqua;
}

&lt;div class="text1"&gt;
   &lt;p&gt;First paragraph&lt;/p&gt;
   &lt;span&gt;First span text.&lt;/span&gt;
   &lt;span&gt;Second span text&lt;/span&gt;
   &lt;p&gt;Second paragraph&lt;/p&gt;
   &lt;p&gt;Third paragrapf&lt;/p&gt;
&lt;/div&gt;
        </pre>
                    <div class="text1">
                        <p>First paragraph</p>
                        <span>First span text.</span>
                        <span>Second span text</span>
                        <p>Second paragraph</p>
                        <p>Third paragrapf</p>
                    </div>
                    <p>Псевдоклассическое отрицание "not()"</p>
                    <pre>
.list4 li:not(.item) {
   text-transofm: uppercase;
   color: red;
}

&lt;ul class="list4"&gt;
   &lt;li class="item"&gt;One&lt;/li&gt;
   &lt;li class="item"&gt;Two&lt;/li&gt;
   &lt;li&gt;Three&lt;/li&gt;
   &lt;li&gt;Four&lt;/li&gt;
   &lt;li class="item"&gt;Five&lt;/li&gt;
   &lt;li&gt;Six&lt;/li&gt;
&lt;/ul&gt;
        </pre>
                    <ul class="list4">
                        <li class="item">One</li>
                        <li class="item">Two</li>
                        <li>Three</li>
                        <li>Four</li>
                        <li class="item">Five</li>
                        <li>Six</li>
                    </ul>
                </section>


                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/Y8UFzOoKkvQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="cascinher">Каскадность и наследование</h4>

                    <p>Каскадность- это ряд правил которое определяет какие именно свойства должны быть добавлены на
                        элемент
                        если в
                        нем определено несколько конфликтующих свойств.</p>
                    <p>Факторы приоритета стилей:</p>
                    <ol>
                        <li>Важность. Если помечено !important, то безоговорочно применяется данный стиль.</li>
                        <li>Специфичность. Применяется тот стиль, специфичность которого больше.</li>
                        <li>Порядок в документе. Если селектора имеют одинаковый вес то применяется свойство которое
                            ниже.
                        </li>
                    </ol>
                    <pre>
tt p { (специфичность 2)
   background-color: green;
   color: white;
   padding: 10px;
}
.styleq { (специфичность 10)
   background-color: aqua;
   color: black;
   border: none !important;
}
   #stylew { (специфичность 100)
   background-color: pink;
   border: 2px solid black;
}
tt p{
   background-color: gray;
}
        </pre>
                    <tt>
                        <p>Просто tt параграф</p>
                        <p class="styleq">класс styleq описывает этот tt параграф.</p>
                        <p class="styleq">а айди stylew этот tt параграф.</p>
                        <p id="stylew">и этот.</p>
                        <p>DEPRECATED</p>
                    </tt>
                    <p>Как видно стили применяются строго по специфичности, исключение составляет значение "border:
                        none;"
                        так
                        как
                        он помечен !important.</p>
                    <p>Наследование в CSS это способность элементов потомков перенимать правило форматирования которое
                        присвоено
                        их
                        предкам.</p>
                    <pre>
.example14 {
    color: red;
    margin-bottom: 10px;
    border: 1px solid black;
}
big p {
    border: inherit;
    margin: inherit;
}
        </pre>

                    <big class="example14">
                        <p>First paragraph</p>
                        <p>Second paragraph</p>
                        <p>Third paragraph</p>
                        <p>Fours paragraph</p>
                        <p>DEPRECATED</p>
                    </big>
                    <p>В данном случае все параграфы наследовали все значения родительского класса "example14" включая
                        нетекстовое
                        оформление. Без "inherit" от родителя наследуется только стиль текста!</p>
                    <p>У каждого браузера свои дефолтные стили ссылок, отступов и тд, чтобы прийти к одному стилю в
                        любом
                        браузере
                        используют сброс или нормализацию стилей. Нормализуют или сбрасывают стиль при помощи
                        подключения
                        отдельного
                        CSS документа со стилями или при помощи копии кода в текущий CSS документ. Важно чтобы
                        подключение
                        или
                        копия нормализующего стиля были первее задаваемых вебразрабом.</p>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/1jvIi039-i4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="boxmodpadmar">Блочная модель и отступы</h4>

                    <pre>
.example15 {
   display: inline;
}
        </pre>
                    <p>"padding" это промежуток между контентом и его границами.</p>
                    <p>"margin" это пустое пространство которое отделяет один тег от другого и находится за пределами их
                        границ</p>
                    <div class="example15"> Div элемент example15 со значением "display: inline;"</div>
                    <br>
                    <pre>
.example16, .example17 {
   border: 5px solid red;
   margin: 10px 20px 30px 40px;
   padding: 10px 20px 30px 40px;
}
        </pre>
                    <div class="example16">Div элемент example16</div>
                    <br>
                    <span class="example17">Span элемент example17</span>
                    <br><br> <!-- дада бэдпрактис. пошел на###. -->
                    <p>Для строчных элементов не работает свойство "margin-top"и"margin-bottom"</p>
                    <p>Схлопывание отступов - если два элемента с разными "margin" стоят рядом, то промежуток между ними
                        будет
                        равен большему "margin", без суммирования и т.д.:</p>
                    <pre>
.example18 {
   border: 1px solid red;
   margin: 30px 0;
}
.example19 {
   border: 1px solid red;
   margin-top: 50px;
}
        </pre>
                    <div class="example18">div элемент example18</div>
                    <div class="example19">div элемент example19</div>
                    <br>
                    <p>Для строчного элемента нельзя задать размеры:</p>
                    <pre>
.example20 {
   margin-top: 100px 0;
   width: 100px;
   height: 100px;
}
        </pre>
                    <span class="example20">span элемент example20</span>
                    <br>
                    <p>А для блочного можно("display: inline-block;" смесь блока и строки и к нему применяется все
                        ствойства
                        обоих
                        типов при этом размер коробки будет не 100на100 а больше тк в него будет включен "padding" и
                        "border"):</p>
                    <pre>
.example21 {
   border: 5px solid red;
   margin: 50px;
   padding: 50px;
   width: 100px;
   height: 100px;
}
        </pre>
                    <div class="example21">div элемент example21</div>
                    <p>Чтобы размеры не приходилось считать самому есть свойство "box-sizing: border-box", в данном
                        случае
                        размер
                        коробки будет ровно 100на100:</p>
                    <pre>
.example22 {
    border: 5px solid red;
    margin: 20px;
    padding: 10px;
    width: 100px;
    height: 100px;
    box-sizing: border-box;
}
        </pre>
                    <div class="example22">div элемент example22</div>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/iydD985acAc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="possiz">Позиционирование и размеры</h4>

                    <p>Позиционирование элемента объявляется с помощью "position" который имеет 5 значений:
                        "static"(дефолтное
                        состояние элементов, применять не нужно); "relative"; "absolute"; "fixed" и "sticky":</p>
                    <p>"position: relative;"- В данном случае элемент отделяется от основного потока и формирует новый,
                        и
                        его
                        положением можно управлять с помощью "top/bottom/left/right", на пустом месте, где ранее
                        располагался
                        элемент остается "shadow-element":</p>
                    <pre>
.example23 {
    border: 5px solid red;
    margin: 20px;
    padding: 10px;
    width: 100px;
    height: 100px;
    box-sizing: border-box;
    position: relative;
    top: 20px;
    left: 150px;
}
                    </pre>
                    <div> Просто текст Просто текст Просто текст Просто текст
                        <div class="example23">div элемент example23</div>
                        Просто текст Просто текст Просто текст Просто текст
                    </div>
                    <br>
                    <p>"position: absolute;"- В данном случае основной поток теряет связь с элементом и его место
                        заполняется,
                        его
                        положением так же можно управлять с помощью "top/bottom/left/right". В случае если родительский
                        элемент
                        имеет дефолтное позиционирование, то элемент с "absolute" будет позиционироваться относительно
                        окна
                        браузера, если же у родительского элемента задано иное позиционирование, то тогда элемент с
                        "absolute"
                        будет позиционироваться относительно родительского элемента, связка "position: relative;" и
                        "position:
                        absolute;" используется часто:</p>
                    <pre>
.example24 {
    border: 5px solid red;
    margin: 20px;
    padding: 10px;
    width: 100px;
    height: 100px;
    box-sizing: border-box;
    position: absolute;
    top: 30px;
    left: 250px;
}
                    </pre>
                    <div class="example25"> Просто текст Просто текст Просто текст Просто текст
                        <div class="example24">div элемент example24</div>
                        Просто текст Просто текст Просто текст Просто текст
                    </div>
                    <br><br><br><br><br><br><br>
                    <p>"position: fixed;" аналог "position: absolute;" с тем различием, что позиционирование будет
                        ВСЕГДА
                        отсчитываться от края окна браузера!!! Изменить ничего нельзя какие бы типы позиционирования ни
                        были
                        у родительского элемента!</p>
                    <pre>
.example26 {
    border: 5px solid red;
    margin: 20px;
    padding: 10px;
    width: 100px;
    height: 100px;
    box-sizing: border-box;
    position: fixed;
    top: 50px;
    right: 150px;
}
        </pre>
                    <div class="example26">div элемент example26</div>
                    <button id="buttonexample" type="button">Показать пример</button>
                    <br>
                    <p>"position: sticky;" прикрепляется к родительскому элементу и передвигается вдоль всего его
                        периметра
                        пока
                        скролится экран:</p>
                    <pre>
.example28 {
    border: 5px solid red;
    display: inline-block;
    width: 100px;
    height: 100px;
    box-sizing: border-box;
    position: sticky;
}
        </pre>
                    <div class="example29">
                        <div class="example28">div элемент example28</div>
                        Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст
                        Просто
                        текст
                        Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст
                        Просто
                        текст
                        Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст
                        Просто
                        текст
                        Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст
                        Просто
                        текст
                        Просто текстv Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст
                    </div>
                    <br>
                    <p>Практически для каждого элемента можно задать размер, размер может быть как фиксированным
                        "width/height"так и диапазонными "min-width/height" и "max-width/height";</p>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/pEdt0afL2-o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="unitsoverflowzindex">Единицы, переполнение и уровни элементов</h4>

                    <table class="bor1">
                        <caption class="bor1">Размеры элементов</caption>
                        <thead>
                        <tr>
                            <th>Абсолютные</th>
                            <th>Относительные</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>Pixels(px)</td>
                            <td>Percentages(%)</td>
                        </tr>
                        <tr>
                            <td>Centimeters(cm)</td>
                            <td>Font-sizes(em&rem)</td>
                        </tr>
                        <tr>
                            <td>Millimeters(mm)</td>
                            <td>Character-sizes(ex&ch)</td>
                        </tr>
                        <tr>
                            <td>Inches(in)</td>
                            <td>Vievport Dimensions(vw&vh)</td>
                        </tr>
                        <tr>
                            <td>Points(pt)</td>
                            <td>Vievport Max(vmax)</td>
                        </tr>
                        <tr>
                            <td>Picas(pc)</td>
                            <td>Vievport Min(vmin)</td>
                        </tr>
                        </tbody>
                    </table>
                    <p>При задании относительной величины для элементов списка (li) в процентах (или любого другого
                        элемента
                        у
                        которого есть дочерние элементы), то будет пошаговое снижение на заданную величину у каждого
                        последующего
                        уровня/элемента. Если у любого родителя объявлен размер шрифта, то процент отталкивается от
                        него,
                        если
                        нет - берется дефолтное браузерное значение:</p>
                    <pre>
.example30 {
    font-size: 24px;
}
.example30 li {
    font-size: 80%;
}
        </pre>

                    <ul class="example30">
                        <li>First element
                            <ul>
                                <li>Second element
                                    <ul>
                                        <li>Third element
                                            <ul>
                                                <li>Fourth element
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <br>
                    <p>Значение "em" увеличивает шрифт каждого последующего дочернего элемента в 2 раза:</p>
                    <pre>
.example31 {
    font-size: 2px;
}
.example30 li {
    font-size: 2em;
}
        </pre>
                    <ul class="example31">
                        <li>First element
                            <ul>
                                <li>Second element
                                    <ul>
                                        <li>Third element
                                            <ul>
                                                <li>Fourth element
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <br>
                    <p>Значение "rem" задает размер ОДИНАКОВЫЙ для всех элементов и расчет размера идет от БАЗОВОГО
                        шрифта
                        HTML!:</p>
                    <ul class="example32">
                        <li>First element
                            <ul>
                                <li>Second element
                                    <ul>
                                        <li>Third element
                                            <ul>
                                                <li>Fourth element
                                                </li>
                                            </ul>
                                        </li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                    <br>
                    <p>Что абсолютные, что относительные величины можно применять как к тексту, так и к отступам и для
                        определения
                        положения элемента, НО для последних принято использовать только абсолютные величины!(px)</p>
                    <p>"vw/vh" используется для создания оверлея под модальные окна:</p>
                    <div class="overlay1">
                        <div class="modal1">Модальное окно
                            <button id="closebutton1" type="button">x</button>
                        </div>
                    </div>
                    <pre>
.modal1 {
    position: absolute;
    margin: 0;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: blue;
    color: white;
    border: 1px solid black;
    width: 300px;
    height: 100px;
    display: flex;
    justify-content: center;
    align-items: center;
}
.overlay1 {
    background-color: rgba(0,0,0,0.5);
    color: white;
    width: 100vw;
    height: 100vh;
    box-sizing: border-box;
    position: fixed;
    top: 0;
    left: 0;
    visibility: hidden;
}

                    </pre>
                    <button id="buttonexample1" type="button">Показать пример модального окна</button>
                    <br>
                    <p>Для того чтобы управлять уровнями элементов есть специальное свойство "z-index", присваивая ему
                        значения
                        вплоть до 9999 мы задаем уровня которые будут позиционироваться друг относительно друга при
                        отображении
                        на
                        странице</p>
                    <p>Если контент выходит за пределы блока в котором он расположен, то происходит переполнение
                        элемента,
                        дабы
                        исправить эту ситуацию используют либо min/max и height/width либо "overflow-x/y" "overflow:
                        auto/scroll/hidden;":</p>
                    <blockquote class="example33">
            <pre>
Do not go gentle into that good night,
Old age should burn and rave at close of day;
Rage, rage against the dying of the light.

Though wise men at their end know dark is right,
Because their words had forked no lightning they
Do not go gentle into that good night.

Good men, the last wave by, crying how bright
Their frail deeds might have danced in a green bay,
Rage, rage against the dying of the light.

Wild men who caught and sang the sun in flight,
And learn, too late, they grieved it on its way,
Do not go gentle into that good night.

Grave men, near death, who see with blinding sight
Blind eyes could blaze like meteors and be gay,
Rage, rage against the dying of the light.

And you, my father, there on that sad height,
Curse, bless, me now with your fierce tears, I pray.
Do not go gentle into that good night.
Rage, rage against the dying of the light.
            </pre>
                        <address>D. Thomas</address>
                    </blockquote>
                </section>


                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/1kZ9FTp2IiE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        -->
                <section class="sec8">
                    <h4 id="floatelemclear">Плавающие элементы и очистка потока</h4>

                    <p>Чтобы добавить обтекание текста слева или справа используют "float: left/right":</p>
                    <pre>
.example34 {
    float: right;
}
                    </pre>
                    <p>"float" вырывает элемент из нормального потока документа, т.е. остальные элементы перестают его
                        видеть, так же теряется наследственная связь</p>
                    <p>Для предотвращения схлопывания родительского элемента используется "overflow: auto;", добавление
                        пустого
                        элемента со свойством "clear: both;" или Clearfix- создание псевдоэлемента .class:after {
                        content:
                        '';
                        display: block; clear: both; }</p>
                    <p>Если задать свойство "float" строчному элементу, то он начинает вести себя как блочный!</p>
                    <a href="./public/floatExample.html" target="_blank">Примеры верстки с float.</a>
                    <hr>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/TAB8pVUKiI4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="fnttxtstl">Шрифты и текст</h4>

                    <p>Безопасные шрифты – это набор шрифтов, устанавливаемый вместе с операционной системой. Чтобы сайт
                        в
                        любой
                        операционной системе открывался одинаково, принято в CSS-свойстве font-family задавать несколько
                        названий
                        шрифтов, перечисленных через запятую.</p>
                    <p>Применить нужный шрифт можно при помощи "font-family: шрифт"</p>
                    <p>"font-size: ЧИСЛОpx" задает размер текста.</p>
                    <p>"font-weihgt: ЧИСЛО" задает толщину шрифта.</p>
                    <p>"font-style: СТИЛЬ" задает стиль текста</p>
                    <p>"color: ЦВЕТ" задает цвет тексту.</p>
                    <p>"text-decoration: underline/overline/line-through/none" задает различные варианты подчеркиваний
                        текста.</p>
                    <p>"letter-spacing: px" и "word-spacing: px" задают расстояние между символами и словами.</p>
                    <p>"line-height: px" позволяет задать межстрочный интервал.</p>
                    <p>"text-transform: uppercase/lowercase/capitalize/none" позволяет вывести текст в верхний/нижний
                        регистр
                        или
                        вывести каждый первый символ предложения в верхний регистр.</p>
                    <p>Шрифты делятся на шрифты с засечками "serif" и без засечек "sans-serif"</p>
                    <p>"text-indent: px" задает красную строку.</p>
                    <p>Подключить шрифты можно с сайта <a class="goglink" href="https://fonts.google.com/"
                                                          target="_blank">fonts.google.com</a>
                    </p>
                    <p>"text-align: left/center/right/justify" позволяет выравнять текст по левому краю, по центру или
                        по
                        правому
                        краю. Justify позволяет выравнять текст по левому и по правому краю растягивая текст в
                        середине.</p>
                    <p>Для того чтобы подключить шрифт локально, его нужно скачать, сохранить в папку с проектом, с
                        помощью
                        директивы "@font-face { "ШРИФТ"; src: url("путь до файла.ttf") format("truetype"); font-weight:
                        500;
                        font-style: normal; }"</p>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/dAHu16pgBrg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="bordshad">Границы и тени</h4>

                    <p>Значения "border-widht: px" "border-style: solid/.../" "border-color: ЦВЕТ" задают рамку
                        определенного
                        стиля
                        определенного цвета, коротко это записывается как в следующем примере: "border: 1px solid red;",
                        если
                        нужно
                        указать только одну сторону границы то используют "border-top/right/bottom/left: ...; или
                        "border-сторона(right z.B.)-параметр(color z.B.): ...;"</p>
                    <p>Значение "outline: ..." задает обводку элементам, имеет те же параметры, но в отличии от "border"
                        нельзя
                        задать свойства каждой отдельной стороне:</p>
                    <pre>
#outlineexample:focus {
    outline: 2px solid green;
}
        </pre>
                    <button id="outlineexample" type="button">для показа примера "outline" нужно сфокусировать табом
                    </button>
                    <p class="shadowexample">Для того чтобы выделить текст с помощью тени существует свойство
                        "text-shadow:
                        горизонт_значение_px вертикальное_значение_px степень_размытости_px цвет". Так же через запятую
                        можно
                        добавить новую тень и количество таковых ничем не ограничено:</p>
                    <pre>
.shadowexample {
    text-shadow: 4px 4px 5px crimson, -4px -4px 5px cyan;
}
        </pre>
                    <p>Для элементов же применяется "box-shadow: ...;", параметры принимает точно такие же как и в
                        "text-shadow:
                        ...;", но присутствует дополнительное значение "inset" которое создает эффект вдавленности:</p>
                    <pre>
.boxshadow {
    width: 100px;
    height: 100px;
    background-color: gray;
    margin: 20px;
    box-shadow: inset 4px 4px 5px green, 4px 4px 5px yellow;
}
        </pre>
                    <div class="boxshadow"></div>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/zaJh6CymejM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="bordradlistscol">Скругление углов, списки и цвета</h4>

                    <p>Чтобы скруглить углы элементов использует "border-radius:верхний_левый_угол_px/%
                        верхний_правый_угол_px/%
                        нижний_правый_угол_px/% нижний_левый_угол_px/%;" или коротко "border-radius: ...px/%;" или
                        "border-radius:
                        ...px/% ...px/%;", так же можно задавать значение скругления отдельно по горизонтали и отдельно
                        по
                        вертикали: "border-radius: ...px/...px;" для определенного угла "border-top-left-radius:
                        ...px/%":</p>
                    <pre>
.borderradiusexample {
    width: 100px;
    height: 100px;
    background-color: gray;
    margin: 20px;
    border-radius: 50% 40px 30px 20%;
}
        </pre>
                    <div class="borderradiusexample"></div>
                    <pre>
.borderradiusexample1 {
    width: 100px;
    height: 100px;
    background-color: gray;
    margin: 20px;
    border-radius: 20px/40px;
}
            </pre>
                    <div class="borderradiusexample1"></div>
                    <p>Чтобы определить маркер списка используют "list-style-type: disc/circle/square/decimal...":</p>
                    <pre>
.lielem1 {
    list-style: disc;
}
.lielem2 {
    list-style-type: circle;
}
.lielem3 {
    list-style-type: square;
}
.lielem4 {
    list-style-type: decimal;
}
.lielem5 {
    list-style-type: upper-alpha;
}
.lielem6 {
    list-style-type: lower-alpha;
}
.lielem7 {
    list-style-type: upper-roman;
}
.lielem8 {
    list-style-type: lower-roman;
}
.lielem9 {
    list-style-type: decimal-leading-zero;
}
.lielem10 {
    list-style-type: none;
}
        </pre>
                    <ul>
                        <li class="lielem1">lielem1</li>
                        <li class="lielem2">lielem2</li>
                        <li class="lielem3">lielem3</li>
                        <li class="lielem4">lielem4</li>
                        <li class="lielem5">lielem5</li>
                        <li class="lielem6">lielem6</li>
                        <li class="lielem7">lielem7</li>
                        <li class="lielem8">lielem8</li>
                        <li class="lielem9">lielem9</li>
                        <li class="lielem10">lielem10</li>
                    </ul>
                    <p>Положение маркера относительно списка мы можем задать с помощью "list-style-position:
                        outside(значение по
                        умолчанию)/inside;"</p>
                    <p>Если нужно задать в качестве маркера некую иконку, то используют "list-style-image:
                        url(http://...);":
                    <p>Если нужно тексту задать цвет, то используют "color: COLOR-NAME/#HEX/rgba(..., ..., ...,
                        ...)/hsla(...,
                        ...%, ...%, ...);"</p>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/pyBjcMRLMoQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="dispvisvendpref">Отображение элементов и вендорные префиксы</h4>

                    <p>Чтобы скрыть элемент со страницы, используют "display: none;" и "visibility: hidden;", при этом
                        первый
                        вариант полностью убирает элемент со страницы(из основного потока документа), а во втором
                        элемент
                        остается
                        на месте, его может видеть поисковик, но не видит юзверь.</p>
                    <p>Второй подход скрытия элемента это использование прозрачности: "opacity: 0;" или "color:
                        transparent"</p>
                    <p>Вендерные префексы это приставка к CSS свойству, которая обеспечивает его поддержку в браузерах,
                        где
                        это
                        свойство пока не добавлено на постоянной основе:</p>
                    <pre>
.exapmleprefix {
    -webkit-opacity: 0.5;  (-webkit- Safari/Chrome)
    -moz-opacity: 0.5;     (-moz- Firefox)
    -ms-opacity: 0.5;      (-ms- IE/Edge)
    -o-opacity: 0.5;       (-o- Opera)
    opacity: 0,5;
}
        </pre>
                    <p>Проверить насколько хорошо поддерживается свойство можно на сайте<a href="https://caniuse.com/"
                                                                                           target="_blank">Can I use</a>
                    </p>
                    <p>При помощи плагина "Gulp" настроив его на нужный браузер префиксы можно задавать
                        автоматически.</p>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/5k-x7FUnDuE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="Background">Фон</h4>

                    <p>Чтобы задать фон цветом или изображением используют "background-color: ...;" либо
                        "background-image:
                        url(http://...);"</p>
                    <p>Размерами изображений выбранных в качестве фона можно управлять с помощью "background-size: ...",
                        оно
                        принимает как точное значение в пикселях или %(так же комбинации пикселей и процентов), так и
                        слова-значения
                        например "contain/cover". Так же если не требуется повторения изображения используют
                        "background-repeat:
                        no-repeat;", если же наоборот нужно применить повторение, но по одной из осей, то применяют
                        "background-repeat: repeat-x/y;"</p>
                    <p>Чтобы управлять позицией фона используют "background-position: .../...;" в ней нужно задавать две
                        позиции
                        right/left/center, а так же top/bottom/center, либо же использовать точные значения в пикселях
                        или
                        процентах.</p>
                    <p>Чтобы зафиксировать фоновое изображение в определенном месте ЭКРАНА, используют
                        "background-attachment:
                        fixed;"</p>
                    <p>Чтобы не городить огород из всех этих значений их можно поместить в "background" в определенном
                        порядке,
                        а именно
                        1) "color", "background-image", "background-position", "background-repeat" и
                        "background-attachment":</p>
                    <pre>
.backgroundsiteexample {
    gainsboro
    url(http://...)
    50% 50% no-repeat fixed;
}
        </pre>
                    <p>Так же в "background" можно добавлять хоть сколько разных фоновых фотографий через запятую, и их
                        наложение друг на друга будет зависеть от порядка добавления в CSS коде.</p>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/8mzap9y6ECE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="gradients">Градиенты</h4>

                    <p>Градиент- переход одного цвета в другой. Чтобы задать градиент, применяют "background-image:
                        linear-gradient(...deg, цвет, цвет, .......);"(либо просто "background"), так же направление
                        градиента
                        можно указать с помощью значения "to top/bottom right/left":</p>
                    <pre>
.gradientexample {
    max-width: 500px;
    height: 500px;
    background-image: linear-gradient(45deg,red,aqua);
}
        </pre>
                    <div class="gradientexample"></div>
                    <br>
                    <p>Опорные точки это дополнительные значения задаваемые сразу после текста - "background-image:
                        linear-gradient(...deg, цвет ...%, цвет ...%, ...%, .....)</p>
                    <pre>
.gradientexample1 {
    max-width: 500px;
    height: 500px;
    background-image: repeating-linear-gradient(45deg, yellow 25px,black 25px, black 50px,yellow 50px, yellow 75px, black 75px);
}
        </pre>
                    <div class="gradientexample1"></div>
                    <br>
                    <p>Для задания радиального градиента используют "background-image/background:
                        radial-gradient(ellipse/circle
                        closest/farthest-side/corner, цвет px/%, цвет px/%);":</p>
                    <pre>
.gradientexample2 {
    max-width: 500px;
    height: 300px;
    background-image: repeating-radial-gradient(ellipse, aqua 20px, red 80px);
}
        </pre>
                    <div class="gradientexample2"></div>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/k-qqZ7rcy-E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="filters">Фильтры</h4>

                    <p>Фильтр это свойство которое добавляет визуальные эффекты на изображение, добавляется с помощью
                        "filter:
                        свойство;":</p>
                    <div class="smallScreenContainer">
                        <img class="imagefilter" src="./assets/imageExample.png" alt="пикча">
                    </div>

                    <br>
                    <button id="blurbutton" type="button">filter: blur(2px);</button>
                    <br>
                    <button id="shadowbutton" type="button">filter: drop-shadow(5px 6px 4px rgba(0, 0, 0, 0.5));
                    </button>
                    <br>
                    <button id="grayscalebutton" type="button">filter: grayscale(100%);</button>
                    <br>
                    <button id="brightnessbutton" type="button">filter: brightness(50%);</button>
                    <br>
                    <button id="contrastbutton" type="button">filter: contrast(150%);</button>
                    <br>
                    <button id="rotatebutton" type="button">filter: hue-rotate(180deg);</button>
                    <br>
                    <button id="invertbutton" type="button">filter: invert(100%);</button>
                    <br>
                    <button id="saturatebutton" type="button">filter: saturate(300%);</button>
                    <br>
                    <button id="sepiabutton" type="button">filter: sepia(100%);</button>
                    <br>
                    <button id="opacitybutton" type="button">filter: opacity(50%);</button>
                    <br>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/vbdw3iHzkFo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="transform">Транcформации</h4>

                    <p>Все свойства трансформации задаются с помощью свойства "transform: ..." и имеют следующие
                        значения:</p>

                    <button class="rotate">transform: rotate(180deg);</button>
                    <button class="scale">transform: scale(x, y);</button>
                    <button class="translate">transform: translate(...px/%, ...px/%);</button>
                    <button class="skew">transform: skew(...deg, ...deg);</button>
                    <p>Дефолтная опорная точка находится по центру элемента, чтобы управлять опорной точкой, используют
                        "transform-origin: right/left bottom/top" или "transform-origin: ...px ...px"</p>
                    <button class="rotateorigin">transform: rotate(180deg);<br>transorm-origin: right bottom;</button>
                </section>

                <!-- <iframe width="560" height="315" src="https://www.youtube.com/embed/hwWIm6DSSoE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h3 Id="transition">Плавные переходы</h3>

                    <p>управлением переходов управляют "transition-duration: ...s/ms, ...s/ms;"(длительность перехода
                        для
                        выбранных
                        свойств), "transition-property: all/свойства"(какое свойство будет осуществлять плавный
                        переход),
                        "transition-delay: ...s/ms, ...s/ms;" (с какой задержкой будет осуществляться переход),
                        "transition-timing-function:
                        ease/ease-in/ease-out/ease-in-out/linear/step-start/step-end/steps(10,
                        start)/steps(10, end)/cubic-bezier(0.1, -0.3, 0.2, 0)". Чтобы записать все эти значения в одну
                        строку,
                        используют "transition: свойство длительность тип_анимации задержка":</p>
                    <pre>
.transitionexample {
    color: red;
    border: 2px solid black;
    width: 200px;
    height: 200px;
    Background-color: aqua;
    margin: 50px;
    transition-duration: 500ms, 2s, 500ms;
    transition-property: transform, background-color, color;
    transition-delay: 0ms, 500ms, 500ms;
    transition-timing-function: linear;
    display: flex;
    justify-content: center;
    align-items: center;
}
.transitionexample:hover {
    background-color: red;
    transform: scale(1.2);
    color: aqua;
}
        </pre>
                    <div class="transitionexample">transitionexample</div>
                </section>

                <section>
                    <h3 Id="animations">Анимации</h3>

                    <p>Анимацию обьявляют следующим образом: "animation-name: имя анимации;" "animation-duration:
                        ...s/ms;"
                        "animation-timing-function:
                        ease/ease-in/ease-out/ease-in-out/linear/step-start/step-end/steps(10,
                        start)/steps(10, end)/cubic-bezier(0.1, -0.3, 0.2, 0);" "animation-iteration-count:
                        число/infinite;"
                        и
                        "animation-direction: normal/reverse/alternate/alternate-reverse;"</p>
                    <p>Все описание анимации можно скомпоновать в: "animation: name duration timing-function delay
                        iteration-count
                        direction fill-mode"</p>
                    <p>Далее описываются шаги анимации: @keyframes имяАнимации { from {свойства} шаг_два(25%){}
                        шаг_три(50%){свойства} ... to{свойства} }</p>
                    <pre>
.animationexample {
    color: red;
    border: 2px solid black;
    width: 200px;
    height: 200px;
    Background-color: aqua;
    margin: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    animation-name: myAnimation;
    animation-duration: 2s;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
    animation-direction: normal;
    animation-fill-mode: none;
}
.animationexample:hover {
    animation-play-state: paused;
}
@keyframes myAnimation {
    from {
        background-color: aqua;
        color: red;
    }
    50% {
        background-color: red;
        color: aqua;
        transform: scale(1.2);
    }
    to {
        background-color: yellow;
        color: darkslateblue;
    }
}
    </pre>
                    <div class="animationexample">animationexample</div>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/Y5MwssNWetI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h3 Id="tablcurs">Таблицы и курсор</h3>

                    <p>Таблице можно задать следующие параметры:</p>
                    <ul>
                        <li>border: ...;</li>
                        <li>width/height: ...px;</li>
                        <li>border-collapse: collapse/separate;</li>
                        <li>caption-side: top(default)/bottom;</li>
                        <li>text-align: left/center/right;</li>
                        <li>vertical-align: baseline/bottom/middle/sub/super/text-bottom/text-top/top;</li>
                        <li>empty-cells: show/hide;</li>
                    </ul>
                    <p>Чтобы управлять стилизацией курсора используют команду "cursor: ...;", команда имеет множество
                        видов
                        курсоров.</p>
                    <br>
                    <table class="table1">
                        <caption>Team members price-list</caption>
                        <thead>
                        <tr>
                            <th>Position</th>
                            <th class="dis1" onclick="(function (){console.log('!!!')})()">Price</th>
                            <th>Description</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>Front-end</td>
                            <td>1000$</td>
                            <td>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
                                incididunt
                                ut
                                labore
                                et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco
                                laboris
                                nisi
                                ut
                                aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
                                velit
                                esse
                                cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident,
                                sunt
                                in
                                culpa qui officia deserunt mollit anim id est laborum."
                            </td>
                        </tr>
                        <tr>
                            <td>Full-stack</td>
                            <td>1500$</td>
                            <td>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
                                incididunt
                                ut
                                labore
                                et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco
                                laboris
                                nisi
                                ut
                                aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
                                velit
                                esse
                                cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident,
                                sunt
                                in
                                culpa qui officia deserunt mollit anim id est laborum."
                            </td>
                        </tr>
                        <tr>
                            <td>QA</td>
                            <td>700$</td>
                            <td>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
                                incididunt
                                ut
                                labore
                                et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco
                                laboris
                                nisi
                                ut
                                aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate
                                velit
                                esse
                                cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident,
                                sunt
                                in
                                culpa qui officia deserunt mollit anim id est laborum."
                            </td>
                        </tr>
                        </tbody>
                    </table>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/6sc-gmz_MYQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h3 Id="texteffectsmulticolumnstext">Текстовые эффекты и многоколоночный текст</h3>

                    <div class="example35">CSS is Awesooooooooome!</div>
                    <button id="overflowexample">overflow: hidden;<br>text-overflow: ellipsis;<br>white-space: nowrap;
                    </button>
                    <button id="wordwrapexample">word-wrap: break-word;<br>word-break: break-all;</button>
                    <button id="writingmodeexample">writing-mode: vertical-lr;</button>
                    <p>Чтобы разбить текст на колонки используют "column-count: ...;", Чтобы визуально разделить колонки
                        используют
                        "column-rule: ...px solid/(ect) color", чтобы задать ширину колонки используют "column-width:
                        ...px",
                        чтобы
                        увеличить расстояние между колонками используют "column-gap: ...px"</p>
                    <div class="textcontainer">
                        <h2>Title 1</h2>
                        <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut
                            labore
                            et
                            dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi
                            ut
                            aliquip
                            ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
                            cillum
                            dolore eu
                            fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
                            officia
                            deserunt mollit anim id est laborum."</p>
                        <h2>Title 2</h2>
                        <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut
                            labore
                            et
                            dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi
                            ut
                            aliquip
                            ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
                            cillum
                            dolore eu
                            fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
                            officia
                            deserunt mollit anim id est laborum."</p>
                        <h2>Title 3</h2>
                        <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut
                            labore
                            et
                            dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi
                            ut
                            aliquip
                            ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
                            cillum
                            dolore eu
                            fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
                            officia
                            deserunt mollit anim id est laborum."</p>
                    </div>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/lv47xClJolw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="mediaqueries">Медиазапросы</h4>

                    <p>Медиазапрос это директива или правило, которое позволяет применять различные свойства в
                        зависимости
                        от
                        разрешения страницы, ориентации устройства, плотности пикселей и типа устройства:</p>
                    <pre>
@media screen/print/all/speech ...* {
    селектор {
        свойство: значение;
    }
}
        </pre>
                    <p>*...(условие например min/max-width/height: ...px ) and (условие например not(color)/orientation:
                        portrait),
                        (запятая означает несколько выборов условий.), ("device-aspect-ratio: 16/9), (min-resolution:
                        2dppx),
                        (min-resolution: 300dpi)</p>
                    <p>Обычно @media используют для:</p>
                    <ul>
                        <li>Настройки количества колонок лэйаута</li>
                        <li>Гибких параметров ширины</li>
                        <li>Сжатия пустых пространств</li>
                        <li>Настройки размеров шрифтов</li>
                        <li>Изменения вида навигации</li>
                        <li>Скрытия и отображения контента на разных устройствах</li>
                        <li>Использования разных изображений</li>
                    </ul>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/_eO1urQ71Lw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="placeholderscrollbarsprites">Стилизация плейсхолдера и скролла, CSS-спрайты</h4>

                    <p>Для того, чтобы стилизировать плейсхолдер, в CSS используют следующую конструкцию:</p>
                    <pre>
.placeholderexample {
    font-size: 24px;
    padding: 5px 10px;
    color: red;
}
.placeholderexample::placeholder {
    color: aqua;
    opacity: 1;
}
.placeholderexample::-ms-input-placeholder {
    color: aqua;
}
.placeholderexample:-ms-input-placeholder {
    color: aqua;
}
        </pre>
                    <input aria-label="please enter your name" class="placeholderexample" type="text"
                           placeholder="please enter your name">
                    <p>Для того чтобы стилизировать скроллбар используют следующую конструкцию:</p>
                    <pre>
.scrollbarexample {
    width: 300px;
    height: 100px;
    overflow: auto;
}
.scrollbarexample::-webkit-scrollbar {
    width: 15px;
    background: #101124;
}
.scrollbarexample::-webkit-scrollbar-track {
    border: 5px solid rgba(255,255,255,0.25);
    box-shadow: inset 0 0 2.5px 2px rgba(0,0,0,0.5);
}
.scrollbarexample::-webkit-scrollbar-thumb {
    background: linear-gradient(45deg, #00ffa1, #00ffff);
    border-radius: 15px;
}
        </pre>
                    <p class="scrollbarexample">"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod
                        tempor
                        incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation
                        ullamco
                        laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in
                        voluptate
                        velit
                        esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident,
                        sunt in
                        culpa
                        qui officia deserunt mollit anim id est laborum."</p>
                    <p>Стилизация элементов взаимодействия с помощью спрайт картинок основывается на изменении позиции
                        отображаемой
                        области картинки:</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/button2.jpg" alt="button">
                    </div>
                    <pre>
#spriteexample {
    background-image: url("button2.jpg");
    background-position: -198px -112px;
    width: 157px;
    height: 60px;
    border: none;
    background-color: transparent;
    cursor: pointer;
    outline: blue;
}
#spriteexample:active {
    background-position: -198px -188px;
}
        </pre>
                    <button id="spriteexample"></button>
                </section>
            </section>

            <section id="FlexboxNav">
                <h3 id="CSSFlexbox">CSS Flexbox</h3>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/9MxBkY2_WNA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="basedefinitions">Основные понятия</h4>

                    <p>Flex Container это элемент которому задано значение "display: flex|inline-flex":</p>
                    <div class="flexcontainerexample">
                        <div class="flexitem item1">1</div>
                        <div class="flexitem item2">2</div>
                        <div class="flexitem item3">3</div>
                        <div class="flexitem item4">4</div>
                        <div class="flexitem item5">5</div>
                        <div class="flexitem item6">6</div>
                        <div class="flexitem item7">7</div>
                        <div class="flexitem item8">8</div>
                    </div>
                    <button id="displayflexexample">display: flex;</button>
                    <button id="normalise">display: inline;</button>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/OQ6GyMD5E-s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="flexdirection">Направление осей</h4>

                    <div class="flexcontainerexample2">
                        <div class="flexitem item1">1</div>
                        <div class="flexitem item2">2</div>
                        <div class="flexitem item3">3</div>
                        <div class="flexitem item4">4</div>
                        <div class="flexitem item5">5</div>
                        <div class="flexitem item6">6</div>
                    </div>
                    <p>За расположение главной оси отвечает свойство "flex-direction", оно имеет следующие свойства:</p>
                    <button id="rowexample">flex-direction: row;(по умолчанию)</button>
                    <br>
                    <button id="rowreverseexample">flex-direction: row-reverse;</button>
                    <br>
                    <button id="columnexample">flex-direction: column;</button>
                    <br>
                    <button id="columnreverseexample">flex-direction: column-reverse;</button>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/zvkE0MY1cxE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="flexwrapgap">Перенос элементов и отступы</h4>

                    <p>Для того чтобы разрешить перенос элементов на другой ряд, если в текущем им недостаточно места,
                        применяют
                        "flex-wrap: nowrap(по умолчанию)/wrap/wrap-reverse;":</p>
                    <pre>
.flexcontainerexample3 {
    border: 10px solid #7f00ff;
    width: 500px;
    display: flex;
}
.flexcontainerexample3 .flexitem {
    width: 44%;
    margin: 5px;
}
        </pre>
                    <div class="flexcontainerexample3">
                        <div class="flexitem item1">1</div>
                        <div class="flexitem item2">2</div>
                        <div class="flexitem item3">3</div>
                        <div class="flexitem item4">4</div>
                        <div class="flexitem item5">5</div>
                        <!--                        <div class="flexitem item6">6</div>-->
                        <!--                        <div class="flexitem item7">7</div>-->
                        <!--                        <div class="flexitem item8">8</div>-->
                    </div>
                    <button id="flexnowrapexample">flex-wrap: nowrap;</button>
                    <br>
                    <button id="flexwrapexample">flex-wrap: wrap;</button>
                    <br>
                    <button id="flexwrapreverseexample">flex-wrap: wrap-reverse;</button>
                    <br>
                    <p>Свойство "gap" определяет расстояние между элементами внутри флекс контейнера.</p>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/FKDfECxwC54" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="alignmentjustifycontent">Выравнивание вдоль главной оси</h4>

                    <button id="resetbutton">reset</button>
                    <br>
                    <div class="flexcontainerexample4">
                        <div class="flexitem item1">1</div>
                        <div class="flexitem item2">2</div>
                        <div class="flexitem item3">3</div>
                        <div class="flexitem item4">4</div>
                        <div class="flexitem item5">5</div>
                        <div class="flexitem item6">6</div>
                        <!--        <div class="flexitem item7">7</div>-->
                        <!--        <div class="flexitem item8">8</div>-->
                    </div>
                    <p>Для того чтобы одновременно изменить расположение главной оси и перенести флекс элементы на новый
                        ряд
                        в
                        случае отсутствия места в текущем ряду используют "flex-flow: column/column-reverse wrap;":
                        <button id="flexflowexample">flex-flow: column wrap;</button>
                    </p>
                    <p>Чтобы перемещать флекс элементы вдоль главной оси используют "justify-content" со следующими
                        значениями: </p>
                    <ul>
                        <li>
                            <button id="flexstartexample">justify-content: flex-start; (default)</button>
                        </li>
                        <li>
                            <button id="flexendexample">justify-content: flex-end;</button>
                        </li>
                        <li>
                            <button id="centerexample">justify-content: center;</button>
                        </li>
                        <li>
                            <button id="spacebetweenexample">justify-content: space-between;</button>
                        </li>
                        <li>
                            <button id="spacearoundexample">justify-content: space-around;</button>
                        </li>
                        <li>
                            <button id="spaceevenlyexample">justify-content: space-evenly;</button>
                        </li>
                    </ul>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/_9idibPDs1s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="alignmentalignitems">Выравнивание вдоль поперечной оси</h4>

                    <button id="resetfontsize">reset font-size</button>
                    <div class="flexcontainerexample5">
                        <div class="flexitem item1">1</div>
                        <div class="flexitem item2">2</div>
                        <div class="flexitem item3">3</div>
                        <div class="flexitem item4">4</div>
                        <div class="flexitem item5">5</div>
                        <!--<div class="flexitem item6">6</div>-->
                        <!--<div class="flexitem item7">7</div>-->
                        <!--<div class="flexitem item8">8</div>-->
                    </div>
                    <p>Для того чтобы задать выравнивание элементов вдоль дополнительной оси, используют свойство
                        "align-items"
                        которое имеет следующие свойства:</p>
                    <ul>
                        <li>
                            <button id="stretchexample">align-items: stretch; (default)</button>
                        </li>
                        <li>
                            <button id="flexstartexample2">align-items: flex-start;</button>
                        </li>
                        <li>
                            <button id="flexendexample2">align-items: flex-end;</button>
                        </li>
                        <li>
                            <button id="centerexample2">align-items: center;</button>
                        </li>
                        <li>
                            <button id="baselineexample">align-items: baseline; (+font-size)</button>
                        </li>
                    </ul>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/sDkL7o0LXF0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="aligncontent">Многострочное выравнивание</h4>

                    <button id="onwrapbutton">flex-wrap: wrap;</button>
                    <button id="offwrapbutton">flex-wrap: nowrap;</button>
                    <br>
                    <button id="oncolumn">flex-direction: column;</button>
                    <button id="offcolumn">flex-direction: row;</button>
                    <br>
                    <button id="autowidth">width: auto;</button>
                    <button id="pxwidth">width: 100px;</button>

                    <div class="flexcontainerexample6">
                        <div class="flexitem item1">1</div>
                        <div class="flexitem item2">2</div>
                        <div class="flexitem item3">3</div>
                        <div class="flexitem item4">4</div>
                        <div class="flexitem item5">5</div>
                        <div class="flexitem item6">6</div>
                        <div class="flexitem item7">7</div>
                        <!--                        <div class="flexitem item8">8</div>-->
                    </div>
                    <p>Для выравнивания многострочного контента используют "align-content", оно срабатывает только если
                        к
                        контейнеру
                        применено свойство "flex-wrap: wrap;"</p>
                    <p>"align-content" имеет следующие значения:</p>
                    <ul>
                        <li>
                            <button id="acstretchexample">align-content: stretch; (default)</button>
                        </li>
                        <li>
                            <button id="acflexstartexample">align-content: flex-start;</button>
                        </li>
                        <li>
                            <button id="acflexendexample">align-content: flex-end;</button>
                        </li>
                        <li>
                            <button id="accenterexample">align-content: center;</button>
                        </li>
                        <li>
                            <button id="acspacebetweenexample">align-content: space-between;</button>
                        </li>
                        <li>
                            <button id="acspacearoundexample">align-content: space-around;</button>
                        </li>
                        <li>
                            <button id="acspaceevenlyexample">align-content: space-evenly;</button>
                        </li>

                    </ul>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/WeFMfoK9R2o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="alignself">Индивидуальное выравнивание элементов</h4>

                    <p>"align-self" предназначено для выравнивания ОПРЕДЕЛЕННОМУ ЭЛЕМЕНТУ и имеет следующие
                        значения:</p>
                    <div class="flexcontainerexample7">
                        <div class="flexitem item1">1
                            <div class="fontsizefc">stretch</div>
                        </div>
                        <div class="flexitem item2">2
                            <div class="fontsizefc">flex-start</div>
                        </div>
                        <div class="flexitem item3">3
                            <div class="fontsizefc">center</div>
                        </div>
                        <div class="flexitem item4">4
                            <div class="fontsizefc">flex-end</div>
                        </div>
                        <!--                        <div class="flexitem item5">5-->
                        <!--                            <div class="fontsizefc">baseline</div>-->
                        <!--                        </div>-->
                        <!--                        <div class="flexitem item6">6-->
                        <!--                            <div class="fontsizefc">baseline</div>-->
                        <!--                        </div>-->
                        <!--                        <div class="flexitem item7">7</div>-->
                        <!--                        <div class="flexitem item8">8</div>-->
                    </div>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/rDdUWDaJzQ8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="flexboxsizing">Размеры элементов</h4>

                    <p>Чтобы задать пропорцию по которой элементы будут занимать свободный объем используют "flex-grow:
                        1/2/3/...;".
                        Чем больше число, тем на такую пропорцию элемент будет забирать на себя больше свободного
                        пространства.</p>
                    <p>Для того, чтобы определить сколько свободного пространства элемент может отдать, применяют
                        свойство
                        "flex-shrink: 1(default)/2/3...;". Чем больше число, тем больше пространства флекс элемент будет
                        отдавать в
                        пропорции.</p>
                    <p>"flex-basis: ...px/%" задает жесткие размеры.</p>
                    <p>Все три этих значения объединяются во "flex: grow shrink basis;"</p>
                    <input aria-label="css values" type="number" id="firstitem" placeholder="flex-grow: ...; (.item1)">
                    <input aria-label="css values" type="number" id="seconditem" placeholder="flex-grow: ...; (.item2)">
                    <input aria-label="css values" type="number" id="thirditem" placeholder="flex-grow: ...; (.item3)">
                    <button id="acceptbutton">accept</button>
                    <br>
                    <input aria-label="css values" type="number" id="fsfirstitem"
                           placeholder="flex-shrink: ...; (.item1)">
                    <input aria-label="css values" type="number" id="fsseconditem"
                           placeholder="flex-shrink: ...; (.item2)">
                    <input aria-label="css values" type="number" id="fsthirditem"
                           placeholder="flex-shrink: ...; (.item3)">
                    <button id="acceptbuttonfs">accept</button>
                    <br>
                    <input aria-label="css values" type="text" id="flexfirstitem" placeholder="flex: ...; (.item1)">
                    <input aria-label="css values" type="text" id="flexseconditem" placeholder="flex: ...; (.item2)">
                    <input aria-label="css values" type="text" id="flexthirditem" placeholder="flex: ...; (.item3)">
                    <button id="acceptbuttonflex">accept</button>
                    <div class="flexcontainerexample8">
                        <div class="flexitem item1">1
                            <div class="cssshow1"></div>
                        </div>
                        <div class="flexitem item2">2
                            <div class="cssshow2"></div>
                        </div>
                        <div class="flexitem item3">3
                            <div class="cssshow3"></div>
                        </div>
                        <!--<div class="flexitem item4">4</div>-->
                        <!--<div class="flexitem item5">5</div>-->
                        <!--<div class="flexitem item6">6</div>-->
                        <!--<div class="flexitem item7">7</div>-->
                        <!--<div class="flexitem item8">8</div>-->
                    </div>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/o_ozA-YMttU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="order">Определение порядка элементов</h4>

                    <p>За задание порядка флекс элемента отвечает "order: число;". "order" может быть так же
                        отрицательным.</p>
                    <div class="flexcontainerexample9">
                        <div class="flexitem item1">1<input aria-label="number input order1" type="number" id="order1">
                        </div>
                        <div class="flexitem item2">2<input aria-label="number input order2" type="number" id="order2">
                        </div>
                        <div class="flexitem item3">3<input aria-label="number input order3" type="number" id="order3">
                        </div>
                        <div class="flexitem item4">4<input aria-label="number input order4" type="number" id="order4">
                        </div>
                        <div class="flexitem item5">5<input aria-label="number input order5" type="number" id="order5">
                        </div>
                        <div class="flexitem item6">6<input aria-label="number input order6" type="number" id="order6">
                        </div>
                        <div class="flexitem item7">7<input aria-label="number input order7" type="number" id="order7">
                        </div>
                        <div class="flexitem item8">8<input aria-label="number input order8" type="number" id="order8">
                        </div>
                    </div>
                    <button id="orderaccept">accept</button>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/ar1F5IwBeSc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="nestingflexbasisflexwrap">Вложенность. Обёртка элементов с размерами</h4>

                    <p>Любой флекс элемент можно превратить во флекс контейнер и это никак не поменяет его
                        взаимодействие с
                        родительским контейнером:</p>
                    <div class="flexcontainerexample11">
                        <div class="flexitem item1">1</div>
                        <div class="flexitem item2">
                            <div class="flexitem inneritem1">1</div>
                            <div class="flexitem inneritem2">2</div>
                        </div>
                        <div class="flexitem item3">3</div>
                        <!--        <div class="flexitem item4">4</div>-->
                        <!--        <div class="flexitem item5">5</div>-->
                        <!--        <div class="flexitem item6">6</div>-->
                        <!--        <div class="flexitem item7">7</div>-->
                        <!--        <div class="flexitem item8">8</div>-->
                    </div>
                    <p>Использование "flex-basis" удобно тем, что при переворачивании основной линии(row/column) не
                        нужно переопределять размер с ширины на высоту и наоборот:</p>

                    <button id="cont10row">flex-direction: row</button>
                    <button id="cont10col">flex-direction: column</button>
                    <br>
                    <input aria-label="range input" type="range" id="rangeinputx" min="230" max="970" step="2"
                           oninput="fun1()"><br>
                    <div class="box1">
                        <div class="flexcontainerexample10">
                            <div class="flexitem item1">1</div>
                            <div class="flexitem item2">2</div>
                            <div class="flexitem item3">3
                                <div>flex-grow: 5;</div>
                            </div>
                            <div class="flexitem item4">4</div>
                            <div class="flexitem item5">5</div>
                            <div class="flexitem item6">6</div>
                            <div class="flexitem item7">7</div>
                            <div class="flexitem item8">8</div>
                        </div>
                        <input aria-label="range input" type="range" id="rangeinputy" min="110" max="740" step="2"
                               oninput="fun2()">
                    </div>
                </section>

                <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/GGiHxIOmPaE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
            -->
                <section>
                    <h4 id="practicalexamples">Практические примеры использования Flexbox</h4>

                    <p>Трехколоночный макет пк и мобильная версия:</p>
                    <div class="flexcontainerexample12">
                        <div class="flexitem item1">Header</div>
                        <div class="mainbox">
                            <div class="flexitem item2">Aside</div>
                            <div class="flexitem item3">Main</div>
                            <div class="flexitem item4">Aside</div>
                        </div>
                        <div class="flexitem item5">Footer</div>
                    </div>
                    <p>Модальное окно:</p>
                    <div class="flexcontainerexample13">
                        <div class="mwcontainer">
                            <div class="flexitem item1">Modal window</div>
                            <button id="closemw">x</button>
                        </div>
                    </div>
                    <button id="modalwindow">Модальное окно</button>
                    <p>Медиа объект:</p>
                    <div class="flex-container">
                        <img src="./assets/imageExample.png" alt="imageExample" style="max-width: 170px">
                        <div class="content">
                            <p>
                                Lorem ipsum dolor sit amet consectetur adipisicing elit. Eveniet minus quam, ipsam
                                tempora modi
                                maxime fuga quod aperiam impedit hic quo consequuntur, esse odit repellat, fugiat magnam
                                sint
                                accusantium dicta?
                            </p>
                        </div>
                    </div>
                    <p>Сайдбар навигации</p>
                    <div class="flexcontainerexample14">
                        <div class="flexitem item1">
                            <nav>
                                <div class="flexitem item2">Home</div>
                                <div class="flexitem item3">Posts</div>
                                <div class="flexitem item4">About</div>
                            </nav>
                            <nav>
                                <div class="flexitem item5">Settings</div>
                                <div class="flexitem item6">Login</div>
                            </nav>
                        </div>
                    </div>
                    <hr>
                </section>
            </section>
        </section>

        <section id="JSnav">
            <h2 id="jsBasicsHeaderLink">Основы JavaScript</h2>

            <section id="JSbasicsNav">
                <h3 id="JSSyntaxCommonTheory">Синтаксис и базовая Теория</h3>

                <section>
                    <h4 id="JSIntro">Введение в JS</h4>

                    <p>JavaScript — мультипарадигменный язык программирования. Поддерживает объектно-ориентированный,
                        императивный
                        и функциональный стили. Является реализацией спецификации ECMAScript (стандарт ECMA-262[2]).</p>
                    <p>Основные архитектурные черты: динамическая типизация, слабая типизация, автоматическое управление
                        памятью,
                        прототипное программирование, функции как объекты первого класса.</p>
                    <p>Имеет следующие типы переменных: переменные ссылочного типа(объекты, массивы, функции), и
                        примитивы.</p>
                    <p>Объект - это набор свойств "имя(ключ): значение". К объектам относятся массивы и функции, числа и
                        строки же - ведут себя как объекты, при этом являются примитивными значениями.</p>

                    <p>Базовые методы объекта console:</p>

                    <ul>
                        <li>console.log() - отображает заданный аргумент в консоль</li>
                        <li>console.dir() - отображает все свойства объекта в консоль</li>
                        <li>console.table() - отображает все свойства объекта в табличном виде в консоль</li>
                    </ul>

                    <p>Любое выражение всегда возвращает значение.</p>

                    <p>Выражения с побочными действиями - это выражение, которое не только возвращает значение, но и
                        выполняет
                        другие действия.</p>

                    <p>Переменные дают возможность повторного доступа к значениям.</p>

                    <p>Имена переменных:
                    <p>

                    <ul>
                        <li>PascalCase используется для Типов и Классов.</li>
                        <li>DB_PASSWORD - значения известны до запуска приложения и не меняются.</li>
                        <li>camelCase - все остальные переменные.</li>
                    </ul>

                    <p>"let a" - объявление переменной, "const c = 10" - объявление и присваивание, "a = true" - только
                        присваивание.</p>
                    <p>В случае let переприсваивание значений возможно, в случае с const - нет.</p>

                    <p>Тип переменной определяется типом присвоенного значения.</p>

                    <p>Типы: примитивные типы и ссылочный тип</p>

                    <p>Примитивные типы:</p>

                    <ul>
                        <li>string(строка)</li>
                        <li>boolean(логический)</li>
                        <li>number(число)</li>
                        <li>null</li>
                        <li>undefined</li>
                        <li>symbol(символ)</li>
                    </ul>

                    <p>Ссылочный тип - object(объект)</p>

                    <p>В случае присваивания переменной объекта, переменная хранит только ссылку на объект, но не сам
                        объект, в
                        случае же присваивания примитивных данных, она хранит именно примитивные данные.</p>

                    <p>Динамическая типизация - одной и той же переменной можно присвоить значения разных типов.
                        JavaScript - динамически типизируемый язык.</p>
                    <p>const позволяет предотвратить возможные проблемы связанные с динамической типизацией!
                        Рекомендуется использовать const везде, где это возможно.</p>
                </section>

                <section>
                    <h4 id="objects">Объекты</h4>

                    <p>Объект - набор свойств "имя: значение", так же так обозначают тип значений/переменных.</p>
                    <p>Порядок свойств в объекте не имеет значения.</p>
                    <p>Доступ к значению получается следующим образом: object.name, объявление новой пары имя:значение
                        или
                        изменение
                        значения в уже существующей паре, так же делается через точечную запись: cobject.name2 =
                        'value';
                        object.name2 = 'newValue'</p>
                    <p>Оператор удаления - "delete": delete object.name -> данное имя и его значение будет удалено. </p>
                    <p>Помимо точечной записи можно использовать синтаксис скобочной записи:</p>
                    <pre>
iobject['someName'] = value ||
const propertyName = 'someName';
object[propertyName] = value;
object = {someName: value}
        </pre>
                    <p>Вложенные свойства это вложенный объект:</p>
                    <pre>
object = {
   someName: {
      someIneredName: someIneredValue
   }
}

object.someName.someIneredValue (чтобы получить значение вложенного объекта)
        </pre>

                    <p>В случае если заданы какие-то переменные и их значения нужно присвоить одноименным ключам в
                        объекте,
                        можно
                        использовать сокращенную запись:</p>
                    <pre>
const name_1 = value_1;
const name_2 = value_2;
const object = {
   name_1,       // (вместо name_1: name_1)
   name_2        // (вместо name_2: name_2)
}
        </pre>
                </section>

                <section>
                    <h4 id="globalObjects">Глобальные объекты:</h4>

                    <ul>
                        <li>Window(веб браузеры)</li>
                        <li>global(Node.js)</li>
                        <li>globalThis(унифицированный глобальный объект)</li>
                    </ul>
                </section>

                <section>
                    <h4 id="methods">Методы</h4>

                    <p>Метод это свойство объекта, значение которого - функция. Метод вызывается при помощи двух скобок:
                        someMethod();</p>
                    <p>JSON (JavaSctipt Object Notation) формат обмена данными, между компьютерами в интернете.</p>
                    <p>Пример JSON: '{"userId": 1, "id": 1, "title": "Test title", "status": {"completed": false }}'</p>
                    <p>Чтобы конвертировать JSON в объект используют метод JSON.parse():</p>
                    <pre>
JSON.parse(someJSON);

{
   userId: 1,
   id: 1,
   title: 'Test title',
   status: {
      completed: false
   }
}
        </pre>
                    <p>Если требуется трансформировать объект в JSON, то используют JSON.stringify()</p>
                </section>

                <section>
                    <h4 id="mutationInJS">Мутация в JavaScript</h4>

                    <p>Изменение свойств объекта называют мутацией объекта.</p>
                    <p>Если одной переменной присвоен объект, и второй переменной присвоить ссылку объекта из первой
                        переменной и мутировать его, то вызывая объект через первую переменную будет показано измененное
                        значение(мутирование объекта через копию):</p>
                    <pre>
const person = {
   name: 'Bob',
   age: 25
}

const person2 = person;

person2.age = 26;
person2.isAdult = true;

console.log(person.age); // --> 26
console.log(person.isAdult); // --> true
        </pre>
                    <p>Чтобы избежать описанной сверху ситуации используют Object.assign({}, object). Не работает для
                        вложенных объектов!!!</p>
                    <pre>
const person2 = Object.assign({}, person);
person2.age = 26;

console.log(person2.age); // --> 26
console.log(person.age); // --> 25
        </pre>
                    <p>Второй вариант создания нового объекта, а не копирование ссылки - использование спред
                        оператора(Так же не работает для вложенных объектов!!!):</p>
                    <pre>
const person2 = {...person};
person2.name = 'Alice';

console.log(person2.name); // --> Alice
console.log(person.name); // --> Bob
        </pre>
                    <p>Третий вариант создания нового объекта с полным избежанием мутаций(ссылки на вложенные объекты не
                        сохраняются) - комбинация JSON.stringify() и JSON.parse():</p>
                    <pre>
const person2 = JSON.parse(JSON.stringify(person));
person2.name = 'Alice';

console.log(person2.name); // --> Alice
console.log(person.name); // --> Bob
        </pre>
                </section>

                <section>
                    <h4 id="functions">Функции</h4>

                    <p>Функция это блок кода который можно выполнять многократно. Функция является объектом и как у
                        любого объекта у функции есть свойства.</p>
                    <p>Функция может быть:</p>
                    <ul>
                        <li>именованной</li>
                        <li>анонимной</li>
                        <li>присвоена переменной</li>
                        <li>аргументом при вызове другой функции(CallBack функция)</li>
                        <li>значением свойства(метода) объекта</li>
                    </ul>
                    <p>Функции содержат:</p>
                    <ul>
                        <li>Ключевое слово function</li>
                        <li>имя функции</li>
                        <li>параметры в скобках ()</li>
                        <li>тело функции в фигурных скобках {}</li>
                        <li>ключевое слово return, для возвращения результата</li>
                    </ul>
                    <p>Return прерывает выполнение кода, даже если есть еще невыполненные строчки кода</p>
                    <p>Вызов функции совершается именем функции со скобками, внутрь скобок параметрам можно задать
                        аргументы если эти параметры были заданы при объявлении функции</p>
                    <p>Функции объявленные ключевым словом function могут быть вызваны до объявления, а которые обявлены
                        следующим
                        методом: "const functionName = function() {}" - могут быть вызваны только после объявления</p>
                    <pre>
function someFunction(param1, param2) {
   let param3;
   param3 = param1 + param2;
   return param3;
}

console.log(someFunction(10, 3)); // --> 13;
        </pre>
                </section>

                <section>
                    <h4 id="linkedValues">Передача значения по ссылке</h4>

                    <p>Внутри функций не рекомендуется мутировать внешний объект, рекомендуется делать копию объекта и
                        мутировать уже его:</p>
                    <pre>
const personOne = {
   name: 'Bob',
   age: 21
}
function increasePersonAge(person) {
   const updatedPerson = {...person};
   updatedPerson.age += 1;
   return updatedPerson;
}
const updatedPersonOne = increasePersonAge(personOne);
console.log(personOne.age); // --> 21
console.log(updatedPersonOne.age); // --> 22
                    </pre>
                    <p>Нужно учитывать, что при spread операции происходит не глубокое копирование, поэтому нужна именно
                        полная копия</p>
                </section>

                <section>
                    <h4 id="callbackFunction">CallBack функции</h4>

                    <p>Колбэк функции это функции вызванные внутри другой функции.</p>
                    <pre>
function someFunction () {
  // действия...
}

function functionWithCallBack(callbackFunction) {
  callbackFunction();
}
functionWithCallBack(someFunction);
        </pre>
                </section>

                <section>
                    <h4 id="functionRules">Правила работы с функциями:</h4>

                    <ol>
                        <li>Называйте функции исходя из выполняемых задач</li>
                        <li>Одна функция должна выполнять одну задачу</li>
                        <li>Не рекомендуется изменять внешние относительно функции переменные</li>
                    </ol>
                </section>

                <section>
                    <h4 id="scope">Область видимости</h4>

                    <p>Область видимости определяет границы действия переменной. Разделяется на глобальную область
                        видимости
                        и
                        локальные области видимости.</p>
                    <p>Переменные с одинаковым именем в локальной области видимости и глобальной - это разные
                        переменные!
                        Если
                        такая
                        переменная объявлена в локальной области видимости, то глобальная будет проигнорирована, если же
                        нет, то
                        переменная будет взята из глобальной области видимости</p>

                    <pre>
let a;
let b;

const myFn = () => {
   let b;
   a = true;
   b = 10;
   console.log(b); // --> 10
}

myFn();

console.log(a); // --> true
console.log(b); // --> undefined
                    </pre>
                </section>

                <section>
                    <h4 id="сhainOfScopes">Цепочка областей видимости</h4>

                    <p>В случае, если есть несколько вложенных областей видимости, и если были вызваны некоторые
                        переменные,
                        то
                        поиск их аргументов происходит "снизу вверх", т.е. сначала аргумент будет искаться в текущей
                        области
                        видимости, потом в верхней, и тд</p>
                </section>

                <section>
                    <h4 id="variableLifeCycle">Жизненный цикл переменных</h4>

                    <p>Жизненный цикл переменной ограничен областью видимости, где она была объявлена:</p>
                    <pre>
let a;
let b;

const someFunction = () => {
   let b;
   a = true;
   b = 10;
   console.log(a); // --> true
   console.log(b); // --> 10
}

someFunction();

console.log(a); // --> true
console.log(b); // --> undefined
        </pre>
                    <p>Тк b была объявлена локально, то присвоенная 10 была применена только к ней, ибо обращение к
                        глобальной b
                        не
                        произошло</p>
                </section>

                <section>
                    <h4 id="typeOfScopes">Типы областей видимости</h4>

                    <ul>
                        <li>Глобальная область видимости</li>
                        <li>Область видимости функции</li>
                        <li>Область видимости блока[*]</li>
                    </ul>
                    <p>[*] Переменные объявленные с помощью let или const внутри блока имеют область видимости,
                        ограниченную
                        этим блоком. Блок это код внутри фигурных скобок(if/for ect.).</p>

                    <p>Если присвоить не объявленной переменной некий аргумент, то при ее вызове она будет автоматически
                        объявлена в
                        глобальной области видимости, (даже если она вызывается в локальной области видимости),
                        присвоение
                        значений
                        не объявленным переменным - bad practice</p>
                    <p>Правила работы с переменными:</p>
                    <ol>
                        <li>Все переменные нужно объявлять перед их использованием</li>
                        <li>Стараться использовать const везде, где это возможно</li>
                        <li>Внутри функций не изменять переменные с внешних областей видимости</li>
                    </ol>
                </section>


                <section>
                    <h4 id="strictMode">Строгий режим / Strict mode</h4>

                    <p>Строчка 'use strict' в самом начале JavaScript файла запрещает использование необъявленных
                        переменных
                        во
                        всем
                        файле, либо же можно написать ее первой строчкой в какой-то локальной области видимости, чтобы
                        включить
                        этот
                        режим только в нем.</p>
                </section>

                <section>
                    <h4 id="operators">Операторы</h4>

                    <ul>
                        <li>Арифметические
                            <ul>
                                <li>+</li>
                                <li>-</li>
                                <li>*</li>
                                <li>/</li>
                            </ul>
                        </li>
                        <li>сравнения
                            <ul>
                                <li>===</li>
                                <li>!==</li>
                                <li>&lt;=</li>
                                <li>&gt;=</li>
                            </ul>
                        </li>
                        <li>логические
                            <ul>
                                <li>!</li>
                                <li>&&</li>
                                <li>||</li>
                            </ul>
                        </li>
                        <li>присваивания =</li>
                    </ul>
                    <p>Текстовые операторы:</p>
                    <ul>
                        <li>typeof(проверка типа объекта)</li>
                        <li>instanceof(проверка принадлежности объекта к тому или иному классу)</li>
                        <li>new</li>
                        <li>delete</li>
                    </ul>
                    <p>Оператор - это встроенная функция.</p>
                    <p>Операнды - то, к чему применяется оператор. Например: 5 * 2 - оператор умножения с левым и правым
                        операндами.
                        Другое название: "аргумент оператора".</p>
                    <p>Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный
                        минус
                        "-"
                        меняет знак числа на противоположный: x = -x; x++; +x; delete obj.x; typeof x; new Object();</p>
                    <p>Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в
                        бинарной
                        форме: y - x; y = x; y + x; y === x; y && x; y += x; </p>
                </section>

                <section>
                    <h4 id="operatorNotationFormats">Форматы записи операторов</h4>

                    <p>Инфиксная запись(оператор находится между операндами):</p>
                    <ul>
                        <li>a = true</li>
                        <li>a + b</li>
                        <li>a += 5</li>
                        <li>a || b</li>
                        <li>a > b</li>
                    </ul>

                    <p>Префиксная запись(оператор находится перед операндом):</p>
                    <ul>
                        <li>++a</li>
                        <li>delete obj.a</li>
                        <li>typeof a</li>
                    </ul>

                    <p>Постфиксная запись(оператор находится после операнда):</p>
                    <ul>
                        <li>a++</li>
                        <li>someFunction()</li>
                    </ul>
                </section>

                <section>
                    <h4 id="operatorPrecedence">Приоритетность операторов</h4>
                    <p>Математические операторы имеют такую же приоритетность как в алгебре.</p>
                </section>


                <section>
                    <h4 id="logicalOperators">Логические операторы</h4>

                    <ul>
                        <li>! - префиксный оператор отрицания. Тип - boolean.</li>
                        <li>&& - инфиксный бинарный оператор "и". Возвращает значение одного из операндов.</li>
                        <li>|| - инфиксный бинарный оператор "или". Возвращает значение одного из операндов.</li>
                        <li></li>
                    </ul>
                </section>

                <section>
                    <h4 id="falseValues">Ложные значения</h4>

                    <p>Ложными значениями являются те значения, которые при приведении к логическому типу(типу
                        Boolean())
                        дают
                        false:</p>
                    <ul>
                        <li>false</li>
                        <li>0</li>
                        <li>''</li>
                        <li>undefined</li>
                        <li>null</li>
                    </ul>
                    <p>Истинными значениями являются те значения, которые при приведении к логическому типу(типу
                        Boolean())
                        дают
                        true:</p>
                    <ul>
                        <li>true</li>
                        <li>1</li>
                        <li>' '</li>
                        <li>'someText'</li>
                    </ul>
                </section>

                <section>
                    <h4 id="operatorTypeOf">Оператор typeof</h4>

                    <pre>
typeof 10 === 'number'; // --> true
typeof 'someText' === 'string'; // --> true
typeof undefined; // --> 'undefined'
                    </pre>
                </section>

                <section>
                    <h4 id="negationOperator">Префиксный унарный оператор "!"(не/отрицания)</h4>

                    <p>Оператор "!" чаще всего используется в условных инструкциях.</p>
                    <ul>
                        <li>!10 // --> false</li>
                        <li>!0 // --> true</li>
                        <li>!'someText' // --> false</li>
                        <li>!'' // --> true</li>
                        <li>!true // --> false</li>
                        <li>!undefined // --> true</li>
                    </ul>
                </section>

                <section>
                    <h4 id="negationOfNegation">Отрицание отрицания "!!"</h4>

                    <p>Оператор "!!" позволяет проверить ложность значения:</p>
                    <ul>
                        <li>!!10 // --> true</li>
                        <li>!!0 // --> false</li>
                        <li>!!'someText' // --> true</li>
                        <li>!!'' // --> false</li>
                        <li>!!true // --> true</li>
                        <li>!!undefined // --> false</li>
                        <li>!!{} // --> true</li>
                    </ul>
                </section>

                <section>
                    <h4 id="andOr">Операторы короткого замыкания "и" и "или"</h4>

                    <p>Операторы "&&" и "||" являются операторами короткого замыкания.</p>

                    <p>Оператор "&&":</p>
                    <pre>expression1 && expression2</pre>
                    <p>Если expression1 ложно, то expression2 игнорируется и возвращается результат expression1.</p>
                    <p>Если expression1 истинно, то проверяется expression2 и возвращается только его результат.</p>

                    <p>Оператор "||":</p>
                    <pre>expression1 || expression2</pre>
                    <p>Если expression1 истинно, то expression2 игнорируется и возвращается результат expression1.</p>
                    <p>Если expression1 ложно, то проверяется expression2 и возвращается только его результат.</p>

                    <p>С помощью оператора "&&" можно вызывать функции по условию:</p>
                    <pre>
let a = 10;

a && console.log('выполнено'); // --> выполнено/undefined

let c;

c && console.log('выполнено'); // --> undefined
        </pre>
                </section>

                <section>
                    <h4 id="chainOfAndOr">Цепочки операторов "&&" и "||"</h4>

                    <p>Если используется оператор &&, то ищется первое отрицательное значение и возвращается его
                        значение.</p>
                    <p>Если же используется оператор ||, то ищется уже первое истинное значение и так же возвращается
                        его
                        значение.</p>
                </section>

                <section>
                    <h4 id="spreadOperator">Оператор разделения объекта на свойства "..." (spread)</h4>

                    <pre>
const button = {
   width: 200,
   text: 'buy'
}

const redButton = {
   ...button,
   color: 'red'
}

console.log(redButton) // --> {width: 200, text: 'buy', color: 'red'}
        </pre>
                    <p>Если свойство присутствует и в разделяемом объекте и в дополняемом объекте, то для замены этого
                        свойства
                        оператор spread с разворачиваемым объектом надо писать первыми.</p>
                </section>


                <section>
                    <h4 id="stringСoncatenation">Конкатенация строк</h4>

                    <pre>
'hello ' + 'world'; // --> 'hello world'

const hello = 'hello';
const world = 'world';

const greeting = hello + ' ' + world;

либо

const greeting = `${hello} ${world}`; (использование шаблонной строки)

greeting // --> 'hello world'
        </pre>
                </section>

                <section>
                    <h4 id="functionExpressions">Функциональные выражения. Объявленная функция VS функциональное
                        выражение.</h4>

                    <p>Функциональные выражения ВСЕГДА анонимные и их нельзя использовать автономно. Так же как и
                        объявленная
                        функция, функциональное выражение может быть присвоено переменной и так же использовано как
                        аргумент
                        в
                        вызове другой функции(быть callback функцией).</p>
                </section>

                <section>
                    <h4 id="arrowFunction">Стрелочные функции</h4>

                    <p>Стрелочная функция это выражение и она ВСЕГДА анонимная и чтобы ей дать имя ее нужно присвоить
                        переменной.</p>
                    <pre>
const someFunctionName = (a, b) => {
    let c;
    c = a + b;
    return c;
}

someFunctionName(5,10); // --> 15
        </pre>

                    <p>Сокращение в стрелочных функциях:</p>
                    <ul>
                        <li>Если только один параметр, то скобки можно опустить:
                            <pre>
a => {
   // тело функции
}
                </pre>
                        </li>
                        <li>Фигурные скобки можно опустить, если тело функции состоит из одного выражения. В этом случае
                            стрелочная
                            функция неявно возвращает результат выражения:
                            <pre>(a, b) => a + b;</pre>
                        </li>
                    </ul>
                </section>


                <section>
                    <h4 id="defaultValues">Значения параметров функций по умолчанию</h4>

                    <pre>
const multByFactor = (value, multiplier = 2) => {
    return value * multiplier;
}

multByFactor(5); // --> 10
multByFactor(10, 3); // --> 30

const newPost = (post, addedAt = Date()) => ({
    ...post,
    addedAt,
})

const firstPost = {
    id: 1,
    author: 'Dmitry'
}

console.log(newPost(firstPost));
        </pre>
                </section>


                <section>
                    <h4 id="tryCatch">Обработка ошибок в JavaScript</h4>

                    <pre>
try {
    // Выполнение блока кода
} catch (error) {
    // этот блок кода выполняется в случае
    возникновения ошибок в блоке try
}

const functionWithError = () => {
    throw new Error('some error')
}

try {
    functionWithError();
} catch (error) {
    console.error(error);
    console.log(error.message);
}

console.log('continue...');
        </pre>
                </section>

                <section>
                    <h4 id="instructions">Инструкции</h4>

                    <p>Выражение всегда возвращает значение.</p>
                    <p>Инструкция всегда выполняет действие. Инструкция зашеврается ";" которая стоит вконце инструкции.
                        Исключение:
                        точка с запятой не требуется после блока инструкций.</p>
                    <p>Точку с запятой можно опускать в JavaScript(но лучше их использовать)</p>

                    <pre>
let a;

const b = 5;

if (a > b) {
    console.log('a is larger');
} // (точка с запятой не требуется)

for (let i = 0; i++; i &lt; 5) {
    console.log(i);
} // (точка с запятой не требуется)
        </pre>
                </section>

                <section>
                    <h4 id="statementExpressions">Выражения-инструкции</h4>

                    <p>Выражение может быть инструкцией:</p>
                    <pre>
'abc';
a = a + 3;
c = a + b;
d = 'good ' + 'evening';
someFunction(c, d);
console.log('hey');
        </pre>
                    <p>Если выражение написано на отдельной строке, то это выражение - инструкция.</p>
                    <p>Инструкция не может быть трансформирована в выражение.</p>
                    <p>Как отличить выражение от инструкции? Выражения могут быть использованы как аргументы в вызовах
                        функций,
                        в
                        отличие от инструкций.</p>

                    <pre>
let someFn = (a) => {
    console.log(a);
}

const b = true;
let c = 10;

someFn(2 + 3) // --> 5
someFn(b) // --> true
someFn(c = c + 1) // --> 11
someFn(c = c + 1;) // --> Uncaught SyntaxError
someFn(let d) // --> Uncaught SyntaxError
        </pre>
                </section>

                <section>
                    <h4 id="arrays">Массивы</h4>

                    <p>Массив это объект с цифровыми именами свойств.</p>
                    <p>Формат записи массивов:</p>
                    <pre>
const someArray = [1, 2, 3];
console.log(someArray); // --> [1, 2, 3]

const someArray2 = new Array(1, 2, 3); // создание нового экземпляра класса Array
console.log(someArray2); // --> [1, 2, 3]
        </pre>
                    <p>Структура массивов</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/arrayStructure.png" style="max-width: 400px" alt="arrayStructure">
                    </div>
                </section>

                <section>
                    <h4 id="comparisonOperatorForArraysAndObjects">Оператор сравнения для массивов и объектов</h4>

                    <p>Тк массивы это объекты, то переменные которым присвоены одинаковые массивы при сравнении не будут
                        равны:</p>
                    <pre>
const someArray = [1, 2, 3];
const someArray2 = [1, 2, 3];

console.log(someArray === someArray2); // --> false
        </pre>
                    <p>В случае же если присвоить переменной переменную, которой был присвоен массив, то в таком случае
                        обе
                        эти
                        переменные будут равны тк хранят одну и ту же ссылку на массив памяти.</p>
                    <pre>
const someArray = [1, 2, 3];
const someArray3 = someArray;

console.log(someArray3 === someArray); //--> true
        </pre>
                </section>

                <section>
                    <h4 id="arrayVSobject">Массив против объекта</h4>

                    <div class="smallScreenContainer">
                        <img src="./assets/arrayVSobject.png" alt="arrayVSobject">
                    </div>
                    <p>Отличием между массивом и объектом является прототип(__proto__). Прототип определяет применяемые
                        методы
                        для
                        объекта/массива.</p>
                </section>

                <section>
                    <h4 id="readingValueOfArray">Чтение значения массива</h4>

                    <p>ТК у массивов индексы номерные(и если у объектов они тоже номерные), то вызывать их элементы
                        точечной
                        записью
                        НЕЛЬЗЯ. В таком случае используются квадратные скобки:</p>
                    <pre>
const someArray = [1, true, 'a'];

console.log(someArray); // --> [1, true, 'a']
console.log(someArray[0]); // --> 1
console.log(someArray[1]); // --> true
console.log(someArray.length); // --> 3
console.log(someArray['length']); // --> 3

someArray.length = 7; // --> [1, true, 'a', empty × 4]
        </pre>
                    <p>Длину массива можно менять в ручную, в таком случае появятся пустые элементы либо удалятся
                        существующие,
                        в
                        зависимости от заданной длины массива, но делать это не рекомендуется:</p>
                    <pre>
someArray.length = 7; // --> [1, true, 'a', empty × 4]
someArray.length = 2; // --> [1, true]
        </pre>
                    <p>С помощью квадратных скобок так же можно менять элементы массива либо добавлять новый:</p>
                    <pre>
const someArray = [1, 2, 3, 4];
someArray[2] = 'abc';

console.log(someArray); // --> [1, 2, 'abc', 4]

someArray[4] = true;

console.log(someArray); // --> [1, 2, 'abc', 4, true]
console.log(someArray.length); // --> 5
        </pre>
                </section>

                <section>
                    <h4 id="arrayMethods">Методы массивов</h4>

                    <p>Функции высшего порядка в массивах(функции/методы прототипов):</p>
                    <ul>
                        <li>push(someItem) - добавляет элемент в конец массива</li>
                        <li>pop() - удаляет элемент с конца массива, возвращает удаленный элемент</li>
                        <li>unshift(someItem) - добавляет элемент в начало массива</li>
                        <li>shift() - удаляет элемент в начале массива, возвращает удаленный элемент</li>
                        <li>forEach(item => {}) - перебирает элементы массива и выполняет с ними какие-то действия</li>
                        <li>filter(item => {})</li>
                        <li>map(item => {})</li>
                        <li>...остальное ищи в __proto__</li>
                    </ul>

                    <p>Методы push(), pop(), unshift(), shift() - относятся к калечащим методом, они мутируют
                        изначальный
                        массив!!!</p>

                    <p>push(someItem)</p>
                    <pre>
const someArray = [1, 2, 3];

someArray.push(4);
console.log(someArray); // --> [1, 2, 3, 4]
        </pre>

                    <p>pop()</p>
                    <pre>
const someArray = [1, 2, 3];

someArray.pop();
console.log(someArray); // --> [1, 2]

const removedElement = someArray.pop();
console.log(someArray); // --> [1]
console.log(removedElement); // --> 2
        </pre>

                    <p>unshift(someItem)</p>
                    <pre>
const someArray = [1, 2, 3];

someArray.unshift(true);
console.log(someArray); // --> [true, 1, 2, 3]
        </pre>

                    <p>shift()</p>
                    <pre>
const someArray = [1, 2, 3];

someArray.shift();
console.log(someArray); // --> [2, 3]

const removedElement = someArray.shift();
console.log(someArray); // --> [3]
console.log(removedElement); // --> 2
        </pre>

                    <p>Методы forEach(), filter(), map() - относятся к некалечащим, forEach проходит цикл по каждому
                        элементу
                        массива выполняя
                        инструкцию и возвращает undefined, map так же проходит по каждому элементу массива, но уже
                        возвращает
                        новый массив,
                        filter проходится по массиву и возвращает те элементы, которые удовлетворяют заданным условиям
                        определенных if оператором.</p>
                    <p>forEach(item => {})</p>
                    <pre>
const someArray = [1, 2, 3];

someArray.forEach(elem => console.log(elem * 2)); // --> 2/ 4/ 6
console.log(someArray); // --> [1, 2, 3]
        </pre>

                    <p>map(item => {})</p>
                    <pre>
const someArray = [1, 2, 3];
const newArray = someArray.map(el => el * 3);

console.log(someArray); --> [1, 2, 3]
console.log(newArray); --> [3, 6, 9]
        </pre>
                </section>


                <section>
                    <h4 id="objectDestructuring">Деструктуризация объектов</h4>

                    <p>При деструктуризации объектов в качестве переменной объявляются ключи из объекта, заключенные в
                        фигурные
                        скобки,
                        далее данной конструкции присваивается исходный объект. В ходе данной операции мы получаем
                        переменные,
                        значениями
                        которых являются значения одноименных ключей из объекта</p>
                    <pre>
const userProfile = {
    name: 'Dmitry',
    commentsQty: 23,
    hasSignedAgreement: false
}

const { name, commentsQty } = userProfile;
const { hasSignedAgreement } = userProfile;

console.log(name); // --> Dmitry
console.log(commentsQty); // --> 23
console.log(hasSignedAgreement); // --> false
        </pre>
                </section>

                <section>
                    <h4 id="arrayDestructuring">Деструктуризация массивов</h4>

                    <p>Деструктуризация массивов похожа на деструктуризацию объектов, но имя переменной теперь задается
                        в
                        деструтурирующих скобках самостоятельно и в строгой последовательности</p>
                    <pre>
const fruits = ['pineapple', 'apple', 'banana'];
const [ , fruitTwo, fruitThree] = fruits;

console.log(fruitTwo); // --> apple
console.log(fruitThree); // --> banana
        </pre>
                </section>


                <section>
                    <h4 id="functionDestructuring">Деструктуризация в функциях</h4>

                    <p>В функциях деструктурируется блок параметров, далее при вызове функции, которой в качестве
                        аргумента
                        будет
                        дан
                        объект, благодаря деструктурированному блоку параметров разложенный на отдельные параметры</p>
                    <pre>
const userProfile = {
    name: 'Dmitry',
    commentsQty: 23,
    hasSignedAgreement: false
}

const userInfo = ({ name, commentsQty }) => {
    if (!commentsQty) {
        return `User ${name} has no comments`
    }

    return `User ${name} has ${commentsQty} comments`
}

console.log(userInfo(userProfile)); // --> User Dmitry has 23 comments
        </pre>
                </section>


                <section>
                    <h4 id="ifElseConstruction">Условные конструкции</h4>

                    <ul>
                        <li>if() {}</li>
                        <li>if() {} else {}</li>
                        <li>switch</li>
                        <li>тернарный оператор (условие ? выражение1 : выражение2)</li>
                    </ul>
                </section>


                <section>
                    <h4 id="ifOperator">Инструкция if() {}</h4>

                    <pre>
if (Условие) {
    // Блок кода, выполняемый однократно, если Условие истинно
}

let value = 10;

if (value > 5) {
    value += 20;
}

console.log(value); // --> 30

const somePerson = {
    age: 21
}

if (!somePerson.name) {
    console.log('имя не указано')
}
                    </pre>
                </section>

                <section>
                    <h4 id="ifElse">Инструкция if() {} else {}</h4>

                    <pre>
if (Условие) {
    // Блок кода, выполняемый однократно, если Условие истинно
} else {
    // Блок кода, выполняемый однократно, если Условие ложно
}

let value = 10;

if (value &lt; 5) {
    value += 20;
} else {
    value -= 20;
}

console.log(value); // --> -10
        </pre>
                </section>


                <section>
                    <h4 id="ifElseElseIf">Инструкция if() {} else if() {} else {}</h4>

                    <pre>
if (Условие 1) {
    // Блок кода, выполняемый однократно, если Условие 1 истинно
} else if (Условие 2) {
    // Блок кода, выполняемый однократно, если Условие 2 истинно
} else {
    // Блок кода, выполняемый однократно, если предыдущие условия ложны
}

const age = 25;

if (age >= 18) {
    console.log('is adult');
} else if (age >= 12) {
    console.log('is teenager');
} else {
    console.log('is child')
}

// аналог "if() {} else if() {} else {}":

const age = 25;

if (age >= 18) {
    console.log('is adult');
}

if (age >= 12 && age &lt; 18) {
    console.log('is teenager');
}

if (age >= 12) {
    console.log('is adult');
}
        </pre>
                </section>

                <section>
                    <h4 id="ifUsage">Использование условного оператора if в функциях</h4>

                    <pre>
const sumPositiveNumbers = (a, b) => {
    if (typeof a !== 'number' || typeof b !== 'number') {
        return 'One of the arguments is not a number';
    }

    if (a &lt;= 0 || b &lt;= 0) {
        return 'Numbers are not positive';
    }

    return a + b;
}

console.log(sumPositiveNumbers ('a', true)); // --> One of the arguments is not a number
console.log(sumPositiveNumbers (-10, 5)); // --> Numbers are not positive
console.log(sumPositiveNumbers (3, 8)); // --> 11
        </pre>
                </section>


                <section>
                    <h4 id="switchInstruction">Инструкция switch</h4>

                    <p>синтаксис switch:</p>
                    <pre>
switch(Выражение) {
    case A:
    // Действия если Выражение === A
    break
    case B:
    // Действия если Выражение === B
    break
    default:
    // Действия по умолчанию
}
        </pre>
                    <p>Пример:</p>
                    <pre>
const month = 2;

switch (month) {
    case 12:
        console.log('Декабрь');
    break;
    case 1:
        console.log('Январь');
        break;
    case 2:
        console.log('Февраль');
        break;
    default:
        console.log('Это не зимний месяц');
} // --> Февраль
        </pre>
                    <p>Если стоит задача выполнять разные действия исходя из значения переменной, то лучше всего
                        использовать
                        оператор switch.</p>
                </section>

                <section>
                    <h4 id="ternaryOperatorExpression">Тернарный оператор</h4>

                    <p>Конструкция с тернарным оператором - выражение</p>
                    <p>Синтаксис - Условие ? expression_1 : expression_2, где Условие - любое выражение, expression_1 -
                        выражение, результат
                        которого возвращается, если условие правдиво, expression_2 - выражение, результат которого
                        возвращается
                        если
                        условие ложно</p>
                    <p>Рекомендованная форма записи:</p>
                    <pre>
Условие
    ? expression_1
    : expression_2
        </pre>
                    <p>Пример:</p>
                    <pre>
const value = 11;

value
    ? console.log('Условие истинно')
    : console.log('Условие ложно')

//------------------------------------------------

const value_1 = 11;
const value_2 = 25;

value_1 && value_2
    : someFunction_1(value_1, value_2)
    ? someFunction_2()

//------------------------------------------------

let value = 11;

console.log(value >= 0 ? value : -value); // --> 11

value = -5;

const res = value >= 0 ? value : -value
console.log(res); // --> 5
        </pre>
                </section>

                <section>
                    <h4 id="CallApplyBindDecorators">Методы call, apply, bind. Декораторы.</h4>

                    <div>
                        <p>При вызове в функции this мы обращаемся к глобальному объекту window, через точку
                            (this.someWindowParameter) мы можем обратиться к любому свойству существующему в объекте
                            Window.</p>
                        <pre>
function someFunction() {
    console.log(this)
}
someFunction() // Window{...}
            </pre>
                        <p>В случае если мы хотим обратиться к свойству некоего объекта в данной функции, то нам к ней
                            необходимо применить один из трех методов к этой функции, а именно:</p>
                        <ul>
                            <li>call(Object, arg1, arg2, argN, ...) - вызывает данную функцию привязывая контекст к
                                свойствам
                                объекта, первым аргументом метода call передается нужный объект, последующими через
                                запятую
                                аргументы функции к которой применяется метод call
                            </li>
                            <li>apply(Object, [arg1, arg2, argN, ...]) - вызывает данную функцию привязывая контекст к
                                свойствам
                                объекта, первым аргументом метода apply передается нужный объект, вторым аргументом
                                передается
                                массив, в котором через запятую расположены аргументы фунцкии
                            </li>
                            <li>bind(Object, arg1, arg2, argN, ...) - используется в случае если нам нужно вызвать
                                функцию с
                                привязанным контекстом к конкретному объекту позже, работа с аргументами метода bind -
                                аналогична
                                методу call, для вызова функции с привязанным контекстом позже, результат отработки
                                функции
                                с
                                методом bind присваивается новой переменной.
                            </li>
                        </ul>
                        <pre>
function helloWorldFunction(arg1,arg2) {
    console.log(arg1 + arg2 + this.someValue)
}

const worldObject = {
    someValue: "World"
}

helloWorldFunction.call(worldObject, "Hello", " "); // Hello World

helloWorldFunction.apply(worldObject, ["Hello", " "]); // Hello World

let someVariable = helloWorldFunction.bind(worldObject, "Hello", " ");
someVariable(); //Hello World
            </pre>
                        <p>Так же при работе с методом bind() в случае если у нас более одного аргумента в изначальной
                            функции,
                            то второй, третий и тд аргумент мы можем передавать уже при вызове новой функции:</p>
                        <pre>
let someAnotherVariable = helloWorldFunction.bind(worldObject, "Hello");
someAnotherVariable(""); //HelloWorld
someAnotherVariable(" "); //Hello World
            </pre>
                        <p>Метод bind() можно использовать и без привязки к контексту определенного объекта:</p>
                        <pre>
function multiply(a, b) {
   console.log(a * b)
}

let double = multiply.bind(null, 2);
double(3); // 6
double(5); // 10

let triple = multiply.bind(null, 3);
triple(3); // 9
triple(5); // 15
            </pre>

                        <p>Функция декоратор - специальная функция, которая в качестве аргумента принимает другую
                            функцию и
                            модифицирует ее поведение.</p>
                        <pre>
let printFuncResult = (x) => {
    return x * 2;
}

const cacheDecorator = (func) => {
    let cache = new Map();

    return function (x) {
        if (cache.has(x)) {
            console.log("Value is from cache");
            return cache.get(x)
        }

        let result = func(x);
        cache.set(x, result);

        return result;
    }
}

printFuncResult = cacheDecorator(printFuncResult);
printFuncResult(2); // 4
printFuncResult(2); // 4 // Value is from cache
            </pre>
                    </div>
                </section>

                <section>
                    <h4 id="cycles">Циклы</h4>

                    <p>Все циклы это инструкции.</p>
                    <p>Для удобства перебора свойств объекта и элементов массива используют цикл.</p>
                    <p>Типы циклов:</p>
                    <ul>
                        <li>for</li>
                        <li>for ... in</li>
                        <li>for ... of</li>
                        <li>while</li>
                        <li>do ... while</li>
                    </ul>
                </section>


                <section>
                    <h4 id="cycleFor">Цикл for</h4>

                    <pre>
for (начальная инструкция; условие; итерационное действие) {
    // блок кода выполняемый на каждой итерации
}

//-------------------------------------------------------

for (let i = 0; i &lt; 5; i++) {
    console.log(i);
} // --> 0 1 2 3 4
        </pre>

                    <p>Для перебора массивов циклы можно использовать, но не рекомендуется! Лучше всего использовать
                        циклы
                        высшего
                        порядка массивов: forEach, map и reduce.</p>
                    <pre>
const someArray = ['first', 'second', 'third'];

for (let i = 0; i &lt; someArray.length; i++) {
    console.log('for: ' + someArray[i] + ' ' + [i]);
} // --> for: first 0 second 1 third 2

someArray.forEach((el, ind) => console.log('forEach: ' + el, ind)); // --> forEach: first 0 second 1 third 2
        </pre>
                </section>

                <section>
                    <h4 id="cycleWhile">Цикл while</h4>

                    <p>Если условие ложно то цикл while может ниразу не выполниться</p>
                    <pre>
while (условие) {
    // блок кода, выполняемый на каждой итерации
    пока условие правдиво
}

//---------------------------------------------

let i = 0;

while (i &lt; 5) {
    console.log(i);
    i++;
}
                    </pre>
                </section>

                <section>
                    <h4 id="cycleDoWhile">Цикл do... while</h4>

                    <p>В отличии от цикла while цикл do ... while выполняется минимум один раз.</p>
                    <pre>
do {
    // блок кода, выполняемый на каждой итерации пока условие правдиво
} while (условие)

//----------------------------------------------------------------

let i = 0;

do {
    console.log(i);
    i++;
} while (i &lt; 5) // --> 0 1 2 3 4

let i = 10;

do {
    console.log(i);
    i++;
} while (i &lt; 5) // --> 10
        </pre>
                </section>

                <section>
                    <h4 id="cycleForKey">Цикл for key in object</h4>

                    <pre>
for (key in Object) {
    // действия с каждым свойством объекта
    // Значение свойства - Object[key]
}

//---------------------------------------

let someObject = {
    a: 10,
    b: true,
    c: 'abc'
}

for (key in someObject) {
    console.log(`${key}: ${someObject[key]}`);
} // --> a: 10 b: true c: 'abc'
        </pre>
                </section>

                <section>
                    <h4 id="objectKeysValues">Методы keys и values для объектов(Object.keys и Object.values)</h4>

                    <p>С помощью Object.keys мы получаем массив из ключей объекта, а далее с помощью цикла forEach мы
                        перебираем этот массив</p>
                    <pre>
let someObject = {
    a: 10,
    b: true,
    c: 'abc'
}

Object.keys(someObject).forEach(key => console.log(`${key}: ${someObject[key]}`));
// --> a: 10 b: true c: 'abc'
                    </pre>

                    <p>С помощью Object.values мы получаем массив из значений объекта с помощью цикла forEach уже
                        перебираем значения</p>
                    <pre>
let someObject = {
    a: 10,
    b: true,
    c: 'abc'
}

Object.values(someObject).forEach(value => console.log(value));
// --> 10 true 'abc'
        </pre>
                </section>

                <section>
                    <h4 id="cycleForIn">Цикл for in для массивов</h4>

                    <pre>
const someArray = [10, true, 'abc', null];

for(const key in someArray) {
    console.log(`${key}: ${someArray[key]}`);
} // --> 0: 10 1: true 2: abc 3: null
        </pre>
                    <p>Это bad practice!</p>
                </section>

                <section>
                    <h4 id="cycleForOf">Цикл for of</h4>

                    <pre>
for (Element of Iterable) {
    // Действия с определенным элементом
}

// for of для строк

const someString = 'some string';

for (const letter of someString) {
    console.log(letter);
} // --> s o m e   s t r i n g

// for of для массивов

const someArray = [10, true, 'abc', null];

for (const element of someArray) {
    console.log(element)
} // --> 10 true abc null

// for of НЕЛЬЗЯ использовать для объектов
        </pre>
                    <p>Где Iterable это любое значение, которое можно перебирать</p>
                </section>

                <section>
                    <h4 id="modules">Модули</h4>

                    <p>Модули позволяют структурировать код и избегать дублирования блоков кода.</p>
                    <p>Синтаксис:</p>
                    <pre>
// moduleOne.js

const myName = () => {
    console.log('Dmitry');
}

export default myName;

// moduleTwo.js

import printMyName from './moduleOne.js'

printMyName(); // --> Dmitry
        </pre>

                    <p>Название экспортируемых переменных могут не совпадать если экспорт по умолчанию(export
                        default)!</p>
                    <p>Каждый модуль отдельная зона видимости переменных.</p>
                </section>

                <section>
                    <h4 id="someModulesExports">Несколько экспортов в модуле</h4>

                    <pre>
// moduleOne.js

const myName = () => {
    console.log('Dmitry');
}

const one = 1;
const two = 'two';

export {
    myName,
    one,
    two
}

// moduleTwo.js

import {
    myName,
    one,
    two
} from './moduleOne.js'

console.log(myName);
console.log(one);
console.log(two);
        </pre>
                    <p>Имена переменных при экспорте нескольких переменных ДОЛЖНЫ совпадать!</p>
                    <p>Если нужно переименовать переменную, то при импорте рядом с переменной добавляют as и новое
                        желаемое
                        имя:</p>
                    <pre>
import {
    myName as printMyName,
    one,
    two
} from './moduleOne.js'
        </pre>
                </section>

                <section>
                    <h4 id="moduleRules">Правила работы с модулями</h4>

                    <ol>
                        <li>Модули должны быть одноцелевыми</li>
                        <li>Располагайте все export инструкции внизу файла</li>
                        <li>Располагайте все import инструкции сверху файла</li>
                        <li>По возможности используйте export default</li>
                    </ol>
                </section>

                <section>
                    <h4 id="classesAndPrototypes">Классы и прототипы</h4>

                    <p>Синтаксис классов появился в ES6 в 2015 году: "class ...", до этого классов не было вообще тк JS
                        не
                        является
                        объектно ориентированным языком программирования.</p>
                    <p>С помощью классов можно создавать прототипы(шаблоны) для объектов, и потом на основании этих
                        прототипов
                        создавать
                        экземпляры объектов.</p>
                    <p>Экземпляры могут иметь собственные свойства и методы, так же экземпляры наследуют свойства и
                        методы
                        прототипов</p>
                    <p>Пример:</p>
                    <pre>
class Comment {
    constructor(text) {
        this.text = text;
        this.votesQty = 0;
    }

    upvote() {
        this.votesQty += 1;
    }
}

const firstComment = new Comment('first comment');

console.log(firstComment.votesQty); // --> 1
firstComment.upvote();

console.log(firstComment.votesQty); // --> 2
firstComment.upvote();
        </pre>
                </section>

                <section>
                    <h4 id="callingInheritedMethods">Вызов унаследованных методов</h4>

                    <p>Метод "constructor()" вызывается только тогда когда необходимо создать новый экземпляр класса,
                        метод
                        "upvote()" и тд будет наследоваться каждым экземпляром этого класса.</p>
                    <p>Оператор new вызывает функцию "constructor()", создавая новый экземпляр(в данном случае с именем
                        "firstComment", класс Comment будет являться прототипом для данного экземпляра).</p>
                </section>

                <section>
                    <h4 id="prototypeChains">Цепочка прототипов</h4>

                    <p>Данный экземпляр будет наследовать все методы Object тк Comment является объектом и наследует все
                        методы
                        глобального класса Object.</p>
                    <p>firstComment --> Comment --> Object</p>
                </section>

                <section>
                    <h4 id="inheritanceCheck">Проверка принадлежности</h4>

                    <p>Проверка принадлежности прототипу осуществляется при помощи оператора instanceof:</p>
                    <pre>
console.log(firstComment instanceof Comment); // --> true
console.log(firstComment instanceof Object); // --> true
console.log(firstComment instanceof Array); // --> false
                    </pre>
                </section>

                <section>
                    <h4 id="objectCopyInheritanceCheck">Проверка принадлежности свойств экземпляру объекта</h4>

                    <p>Проверка принадлежности свойств экземпляру объекта осуществляется при помощи метода объекта
                        "hasOwnProperty"</p>
                    <pre>
firstComment.hasOwnProperty('text'); // --> true
firstComment.hasOwnProperty('votesQty'); // --> true
firstComment.hasOwnProperty('upvote'); // --> false
firstComment.hasOwnProperty('hasOwnProperty'); // --> false
                    </pre>
                </section>

                <section>
                    <h4 id="creatingSomeCopies">Создание нескольких экземпляров</h4>

                    <pre>
class Comment {
    constructor(text) {
        this.text = text;
        this.votesQty = 0;
    }

    upvote() {
        this.votesQty += 1;
    }
}

const firstComment = new Comment('first comment');
firstComment.upvote();

const secondComment = new Comment('second comment');
secondComment.upvote();

const thirdComment = new Comment('third comment');
thirdComment.upvote();
        </pre>
                </section>

                <section>
                    <h4 id="staticMethods">Статическе методы</h4>

                    <pre>
class Comment {
    constructor(text) {
        this.text = text;
        this.votesQty = 0;
    }

    upvote() {
        this.votesQty += 1;
    }

    static mergeComments(first, second) {
        return `${first} ${second}`;
    }
}

Comment.mergeComments('First comment.', 'Second comment.'); // --> First comment. Second comment.
                    </pre>
                    <p>Статические методы доступны как свойства класса и не наследуются экземплярами класса!</p>
                    <p>Object.keys, Object.values и Object.assign являются статическими методами. Эти методы не
                        наследуются
                        экземплярами
                        Object, и доступны только для Object.</p>
                </section>

                <section>
                    <h4 id="classExtension">Расширение других классов</h4>

                    <pre>
class NumbersArray extends Array {
    sum() {
        return this.reduce((el, acc) => acc += el, 0)
    }
}

const myArray = new NumbersArray(2, 5, 7);

console.log(myArray); // --> [2, 5, 7]
myArray.sum(); // --> 14
                    </pre>

                    <p>В данном случае цепочка прототипов будет выглядеть так: myArray > NumbersArray > Array >
                        Object</p>
                </section>


                <section>
                    <h4 id="prototypes">Что такое прототип</h4>

                    <p>Прототип - это JS объект, от которого другие объекты наследуют его свойства и методы. По
                        умолчанию, у
                        каждого
                        объекта есть свой прототип и если у искомого объекта не хватает каких-либо свойств, то они
                        ищутся в
                        прототипе.
                        В свою очередь, если и у ближайшего прототипа нет этих свойств, то они ищутся ниже в иерархии
                        прототипов. По
                        такому принципу происходит наследование прототипов в JS.</p>
                    <pre>Comment.prototype === firstComment.__proto__; // --> true</pre>
                </section>

                <section>
                    <h4 id="stringAndNumberBehavior">Строки и числа ведут себя как объекты</h4>

                    <pre>
const myName = 'Ivan';
console.log(myName); // --> Ivan
myName.toUpperCase(); // --> IVAN

const mySecondName = new String('Ivanov');
mySecondName.toUpperCase(); // --> IVANOV
                    </pre>
                    <p>Переменные myName и mySecondName имеют одинаковый набор методов!</p>
                </section>

                <section>
                    <h4 id="objectAndClassDecorators">Декораторы классов, объектов</h4>

                    <div>
                        <p>Декоратор — это средство, которое позволяет обернуть одну функцию другой и расширить ее
                            возможности.</p>
                        <pre>
//декораторы JS
const myCar = {
    fuel: '50%',
    open: true,
    freeSeats: 3,
    isOpenAndFuel() {
        return `${this.open} and ${this.fuel}`;
    }
}

//функция декоратор
function closeCar(car: typeof myCar) {
    car.open = false;
    console.log('close car');
    return car;
}

function addFuel(car: typeof myCar){
    car.fuel = '100%';
    console.log('addFuel');
    return car;
}

console.log(closeCar(addFuel(myCar)).isOpenAndFuel()); // первой срабатывает функция которая внутри: addFuel / close car / false and 100%

//декораторы классов
interface ICar {
    fuel: string;
    open: boolean;
    freeSeats: number;
    isOpenAndFuel: () => string;
}

class MyCar implements ICar{
    fuel: string = '50%';
    open: boolean = true;
    freeSeats: number = 3;
    isOpenAndFuel() {
        return `${this.open} and ${this.fuel}`;
    }
}

const newCar = new MyCar();
console.log(closeCar(addFuel(newCar)));  // addFuel / close car / MyCar { fuel: '100%', open: false, freeSeats: 3 }
            </pre>
                        <p>Декораторы функций — это такие же функции. Они принимают функцию в качестве аргумента и
                            возвращают
                            другую
                            функцию, которая расширяет поведение функции-аргумента. Новая функция не изменяет
                            функцию-аргумент,
                            но
                            использует ее в своем теле</p>
                        <p>В функциональном программировании на JavaScript декораторы функций используются уже давно.
                            Классы
                            в
                            JavaScript — на самом деле не классы. Синтаксис классов — это всего лишь синтаксический
                            сахар
                            для
                            прототипов,
                            который упрощает работу с ними. Напрашивается вывод, что классы — это просто функции.</p>
                    </div>
                </section>

                <section>
                    <h4 id="promises">Промисы</h4>

                    <p>Промисы позволяют обрабатывать отложенные во времени события(промис - обещание предоставить
                        результат
                        позже).</p>
                    <p>Промис может вернуть ошибку если результат предоставить невозможно.</p>
                    <p>Состояние промиса:</p>
                    <ul>
                        <li>ожидание</li>
                        <li>исполнен</li>
                        <li>отклонен</li>
                    </ul>
                </section>

                <section>
                    <h4 id="promiseCreationAndUsage">Создание и использование промисов</h4>

                    <pre>
const somePromise = new Promise((resolve, reject) => {
    // Выполнение асинхронных действий

    /** Внутри этой функции нужно в результате вызвать одну из
    функций resolve или reject */
});
        </pre>
                    <p>Вновь созданный промис будет в состоянии ожидания (pending)</p>
                    <p>Получение результата промиса:</p>
                    <pre>
somePromise
    .then(value => {
        /** Действия в случае успешного исполнения промиса.
        Значение value - это значение, переданное в вызове
        функции resolve внутри промиса */
    })
    .catch(error => {
        /** Действия в случае отклонение промиса.
        Значение error - это значение, переданное в вызове
        функции reject внутри промиса. */
    })
                    </pre>
                </section>

                <section>
                    <h4 id="fetchApi">Получение данных с помощью fetch api</h4>

                    <pre>
fetch('https://jsonplaceholder.typicode.com/todos')
   .then(response => {
       console.log(response);
       return response.json()
   }) // json возвращает еще один промис
   .then(json => console.log(json))
   .catch(error => console.error(error))
        </pre>
                </section>

                <section>
                    <h4 id="callingFetchInsidePromise">Вызов fetch внутри промиса</h4>

                    <pre>
const getData = (url) =>
    new Promise((resolve, reject) =>
        fetch(url)
    .then(response => response.json())
    .then(json => resolve(json))
)

getData('https://jsonplaceholder.typicode.com/todos')
    .then(data => console.log(data))
    .catch(error => console.log(error.message))
                    </pre>
                </section>

                <section>
                    <h4 id="asyncAwait">Асинхронные функции(async/await)</h4>

                    <p>Асинхронная функция - это функция, которая вместо значения(строка/число/undefined), возвращает
                        промис.</p>
                    <p>async/await это специальный синтаксис для упрощения работы с промисами. Появился в ES6 в 2015
                        году.</p>
                    <pre>
async function asyncFunction() {
    // всегда возвращает промис
}

// альтернативный синтаксис -->

const asyncFunction = async() => {
    // всегда возвращает промис
}

//---------------------------

const asyncFunction = async() => {
    return 'Success!'
}

asyncFunction();

asyncFunction()
    .then(value => console.log(value));

const asyncFunction = async() => {
    throw new Error('There was an error!')
}

asyncFunction()
    .then(value => console.log(value))
    .catch(error => console.log(error.message));
        </pre>
                </section>

                <section>
                    <h4 id="awaitInAJAX">Использование await внутри асинхронных функций</h4>

                    <p>ключевое слово await можно использовать только в функциях с async</p>
                    <pre>
const asyncFunction = async() => {
    await &lt;Promise&gt;
}

asyncFunction();

// пример:

const timerPromise = () =>
    new Promise((resolve, reject) =>
        setTimeout(() => resolve(), 2000));

const asyncFunction = async() => {
    console.log('Timer starts');

    const startTime = performance.now();

    await timerPromise();

    const endTime = performance.now();

    console.log('Timer ended', endTime - startTime);
}

asyncFunction();
        </pre>
                </section>

                <section>
                    <h4 id="asyncAwaitUsage">Переход(миграция) с промисов на async/await</h4>

                    <pre>
const getData = async(url) => {
    const res = await fetch(url);
    const json = await res.json();
    return json;
}

const url = 'https://jsonplaceholder.typicode.com/todos';

try {
    const data = await getData(url);
    console.log(data);
} catch(error) {
    console.log(error.message);
}
        </pre>
                </section>

                <section>
                    <h4 id="keyPrinciplesInAsyncAwait">Ключевые принципы в async/await</h4>

                    <ol>
                        <li>async/await - это синтаксическая надстройка над промисами</li>
                        <li>await синтаксис возможен только внутри async функций</li>
                        <li>async функция всегда возвращает Promise</li>
                        <li>async функция ожидает результата инструкции await и не выполняет последующие инструкции(но
                            не
                            блокируется
                            выполнение других частей приложения)
                        </li>
                    </ol>
                </section>
            </section>

            <section id="JSbasicsForEmploymentNav">
                <h3 id="JSCommonTheory">Частые вопросы по JS теории</h3>

                <section>
                    <h4 id="JSbasicsForEmployment0">Способы создания объектов в JS</h4>

                    <div>
                        <ol>
                            <li>
                                <h5>Конструктор объекта:</h5>
                                <p>Самый простой способ создать пустой объект — использовать конструктор Object. В
                                    настоящее
                                    время
                                    этот подход не рекомендуется.</p>
                                <pre>var object = new Object();</pre>
                                <p>Object() — это встроенная функция-конструктор, поэтому ключевое слово
                                    «new» не требуется. Вышеизложенное можно записать как:</p>
                                <pre>var object = Object();</pre>
                            </li>
                            <li>
                                <h5>Метод создания объекта:</h5>
                                <p>Метод create объекта Object создает новый объект, передавая объект-прототип в
                                    качестве
                                    параметра.</p>
                                <pre>var object = Object.create(null);</pre>
                            </li>
                            <li>
                                <h5>Синтаксис литерала объекта:</h5>
                                <p>Синтаксис литерала объекта (или инициализатор объекта) представляет собой набор
                                    пар имя-значение, разделенных запятыми, заключенных в фигурные скобки.</p>
                                <pre>
var object = {
    name: "Sudheer",
    age: 34
};

Object literal property values can be of any data type, including array, function, and nested object.
                        </pre>
                            </li>
                            <li>
                                <h5>Конструктор функций:</h5>
                                <p>Создайте любую функцию и примените "new" оператор для создания
                                    экземпляров объектов.</p>
                                <pre>
function Person(name) {
    this.name = name;
    this.age = 21;
}
var object = new Person("Sudheer");
                        </pre>
                            </li>
                            <li>
                                <h5>Конструктор функции с прототипом:</h5>
                                <p>Это похоже на конструктор функций, но он использует прототип для своих
                                    свойств и методов.</p>
                                <pre>
function Person() {}
Person.prototype.name = "Sudheer";
var object = new Person();
                        </pre>

                                <p>Это эквивалентно экземпляру, созданному с помощью метода создания
                                    объекта с прототипом функции, а затем вызову этой функции с экземпляром и
                                    параметрами в
                                    качестве аргументов.</p>
                                <pre>
function func() {}

new func(x, y, z);

//or:

// Create a new instance using function prototype.
var newInstance = Object.create(func.prototype)

// Call the function
var result = func.call(newInstance, x, y, z),

// If the result is a non-null object then use it otherwise just use the new instance.
console.log(result && typeof result === 'object' ? result : newInstance);
                    </pre>
                            </li>
                            <li>
                                <h5>Синтаксис Классов в ES6</h5>
                                <p>ES6 представляет функцию класса для создания объектов</p>
                                <pre>
class Person {
    constructor(name) {
        this.name = name;
    }
}

var object = new Person("Sudheer");
                        </pre>
                            </li>
                            <li>
                                <h5>Singleton pattern(функция одноразового объявления):</h5>
                                <p>Синглтон — это объект, экземпляр которого может быть создан только один раз.
                                    Повторные вызовы его конструктора возвращают один и тот же экземпляр, и таким
                                    образом
                                    можно гарантировать, что они случайно не создадут несколько экземпляров.
                                </p>
                                <pre>
var object = new (function () {
    this.name = "Sudheer";
})();
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment1">Что такое цепочка прототипов</h4>

                    <div>
                        <p>Цепочка прототипов используется для создания новых объектов на основе существующих.
                            Это похоже на наследование в языках, основанных на классах.</p>
                        <p>Прототип экземпляра объекта доступен через свойство Object.getPrototypeOf(object) или
                            __proto__,
                            тогда как функция прототипа в конструкторах доступна через Object.prototype.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment2">В чем разница между Call, Apply и Bind</h4>

                    <div>
                        <p>Разницу между Call, Apply и Bind можно объяснить на примерах ниже:</p>
                        <p>Call: метод call() вызывает функцию с заданным значением и аргументами,
                            предоставленными один за другим.</p>
                        <pre>
var employee1 = { firstName: "John", lastName: "Rodson" };
var employee2 = { firstName: "Jimmy", lastName: "Baily" };

function invite(greeting1, greeting2) {
    console.log(
        greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2
    );
}

invite.call(employee1, "Hello", "How are you?"); // Hello John Rodson, How are you?
invite.call(employee2, "Hello", "How are you?"); // Hello Jimmy Baily, How are you?
                </pre>
                        <p>Apply: вызывает функцию с заданным значением и позволяет передавать аргументы в виде
                            массива.</p>
                        <pre>
var employee1 = { firstName: "John", lastName: "Rodson" };
var employee2 = { firstName: "Jimmy", lastName: "Baily" };

function invite(greeting1, greeting2) {
    console.log(
        greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2
    );
}

invite.apply(employee1, ["Hello", "How are you?"]); // Hello John Rodson, How are you?
invite.apply(employee2, ["Hello", "How are you?"]); // Hello Jimmy Baily, How are you?
                </pre>
                        <p>bind: возвращает новую функцию, позволяющую передавать любое количество аргументов.</p>
                        <pre>
var employee1 = { firstName: "John", lastName: "Rodson" };
var employee2 = { firstName: "Jimmy", lastName: "Baily" };

function invite(greeting1, greeting2) {
    console.log(
        greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2
    );
}

var inviteEmployee1 = invite.bind(employee1);
var inviteEmployee2 = invite.bind(employee2);
inviteEmployee1("Hello", "How are you?"); // Hello John Rodson, How are you?
inviteEmployee2("Hello", "How are you?"); // Hello Jimmy Baily, How are you?
                </pre>
                        <p>Call и apply довольно взаимозаменяемы. Оба немедленно выполняют текущую функцию.
                            Вам нужно решить, что проще использовать в аргументах: массив или список аргументов,
                            разделенных
                            запятыми.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment3">Что такое JSON и его общие операции</h4>

                    <div>
                        <p>JSON — это текстовый формат данных, соответствующий синтаксису объектов JavaScript,
                            популяризированный
                            Дугласом Крокфордом. Это полезно, когда вы хотите передавать данные по сети и по сути это
                            просто
                            текстовый файл с расширением .json и MIME-типом application/json.</p>

                        <p>Парсинг: преобразование строки в собственный объект</p>
                        <pre>JSON.parse(text);</pre>
                        <p>Стрингификация: преобразование собственного объекта в строку для его передачи по сети.</p>
                        <pre>JSON.stringify(object);</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment4">Какова цель метода массивов "slice"</h4>

                    <div>
                        <p>Метод slice() возвращает выбранные элементы массива как новый объект массива. Он выбирает
                            элементы,
                            начинающиеся с данного начального аргумента, и заканчиваются данным необязательным конечным
                            аргументом,
                            не включая последний элемент. Если вы опустите второй аргумент, он будет выбирать до конца.
                        </p>
                        <pre>
let arrayIntegers = [1, 2, 3, 4, 5];
let arrayIntegers1 = arrayIntegers.slice(0, 2); // returns [1,2]
let arrayIntegers2 = arrayIntegers.slice(2, 3); // returns [3]
let arrayIntegers3 = arrayIntegers.slice(4); //returns [5]
                </pre>

                        <p>Примечание. Метод Slice не изменяет исходный массив, но возвращает подмножество как новый
                            массив.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment5">Какова цель метода массивов "splice"</h4>

                    <div>
                        <p>Метод splice() используется либо для добавления/удаления элементов в/из массива, а затем для
                            возврата
                            удаленного элемента. Первый аргумент указывает позицию массива для вставки или удаления,
                            тогда
                            как
                            необязательный второй аргумент указывает количество элементов, которые необходимо удалить.
                            Каждый
                            дополнительный аргумент добавляется в массив.
                        </p>
                        <pre>
let arrayIntegersOriginal1 = [1, 2, 3, 4, 5];
let arrayIntegersOriginal2 = [1, 2, 3, 4, 5];
let arrayIntegersOriginal3 = [1, 2, 3, 4, 5];

let arrayIntegers1 = arrayIntegersOriginal1.splice(0, 2); // returns [1, 2]; original array: [3, 4, 5]
let arrayIntegers2 = arrayIntegersOriginal2.splice(3); // returns [4, 5]; original array: [1, 2, 3]
let arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, "a", "b", "c"); //returns [4]; original array: [1, 2, 3, "a", "b", "c", 5]
                </pre>
                        <p>Примечание: Метод Splice изменяет(мутирует) исходный массив и возвращает удаленный массив.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment6">В чем разница между slice и splice</h4>

                    <div>
                        <table class="jsTheoryTable">
                            <caption>Некоторые основные различия в табличной форме</caption>
                            <thead>
                            <tr>
                                <th>Slice</th>
                                <th>Splice</th>
                            </tr>
                            </thead>
                            <tr>
                                <td>Не изменяет исходный массив (иммутабельный)</td>
                                <td>Изменяет исходный массив (мутабельный)</td>
                            </tr>
                            <tr>
                                <td>Возвращает подмножество исходного массива</td>
                                <td>Возвращает удаленные элементы в виде массива</td>
                            </tr>
                            <tr>
                                <td>Используется для выбора элементов из массива</td>
                                <td>Используется для вставки или удаления элементов в/из массива.</td>
                            </tr>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment7">Сходства и различия Object и Map</h4>

                    <div>
                        <p>Objects похожи на Map в том, что оба позволяют устанавливать ключи в значения,
                            извлекать эти
                            значения, удалять ключи и определять, хранится ли что-то по ключу. По этой причине объекты
                            исторически
                            использовались в качестве Map. Но есть важные различия, которые делают использование Map
                            предпочтительнее в определенных случаях.
                        </p>

                        <ol>
                            <li>
                                Ключами объекта являются строки и символы, тогда как для Map они
                                могут быть любым значением, включая функции, объекты и любые примитивы.
                            </li>
                            <li>
                                Ключи в Map упорядочены, а ключи, добавленные в Object, — нет. Таким
                                образом, при переборе объект Map возвращает ключи в порядке вставки.
                            </li>
                            <li>
                                Вы можете легко получить размер Map с помощью свойства size, тогда
                                как количество свойств в объекте необходимо определять вручную.
                            </li>
                            <li>
                                Map является итерируемой, и поэтому ее можно перебирать напрямую,
                                тогда как итерация по объекту требует каким-то образом получить его
                                ключи и перебрать их.
                            </li>
                            <li>
                                У объекта есть прототип, поэтому у Map есть ключи по умолчанию,
                                которые могут столкнуться с вашими ключами, если вы не будете осторожны.
                                Начиная с ES5, это можно обойти, используя map = Object.create(null), но это делается
                                редко.
                            </li>
                            <li>
                                Map может работать лучше в сценариях, связанных с частым добавлением
                                и удалением пар ключей.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment8">В чем разница между операторами == и ===</h4>

                    <div>
                        <p>
                            JavaScript обеспечивает как строгое (===, !==), так и преобразование типов (==, !=)
                            сравнение на
                            равенство. Строгие операторы учитывают тип переменной, тогда как нестрогие операторы
                            выполняют
                            коррекцию/преобразование типа на основе значений переменных. Строгие операторы следуют
                            приведенным ниже условиям для разных типов:
                        </p>
                        <ol>
                            <li>
                                Две строки строго равны, если они имеют одинаковую последовательность символов,
                                одинаковую длину и одинаковые символы в соответствующих позициях.
                            </li>
                            <li>
                                Два числа строго равны, если они численно равны. т. е. имеющие
                                одинаковое числовое значение. Здесь есть два особых случая:
                                <ul>
                                    <li>NaN не равен ничему, включая NaN</li>
                                    <li>Положительные и отрицательные нули равны друг другу.</li>
                                </ul>
                            </li>
                            <li>Два логических операнда строго равны, если оба истинны или оба ложны.</li>
                            <li>Два объекта строго равны, если они ссылаются на один и тот же объект.</li>
                            <li>
                                Типы Null и Undefine не равны ===, но равны ==. т.е. null === undefined -->
                                false, но null == undefined --> true
                            </li>
                        </ol>
                        <pre>
0 == false   // true
0 === false  // false
1 == "1"     // true
1 === "1"    // false
null == undefined // true
null === undefined // false
'0' == false // true
'0' === false // false
[]==[] or []===[] //false, refer different objects in memory
{}=={} or {}==={} //false, refer different objects in memory
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment9">Что такое лямбда или стрелочные функции?</h4>

                    <div>
                        <p>Стрелочная функция представляет собой более короткий синтаксис функционального
                            выражения и не имеет собственных аргументов this, super или new.target.
                            Эти функции лучше всего подходят для функций, не являющихся методами,
                            и их нельзя использовать в качестве конструкторов.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment10">Что такое функция первого класса</h4>

                    <div>
                        <p>В Javascript функции являются объектами первого класса. Функции первого класса
                            означают, что функции на
                            этом языке рассматриваются как любая другая переменная.</p>

                        <p>Например, в таком языке функция может передаваться в качестве аргумента другим
                            функциям, может быть
                            возвращена другой функцией и может быть присвоена как значение переменной. В приведенном
                            ниже
                            примере
                            функции-обработчики, назначенные прослушивателю:</p>

                        <pre>
const handler = () => console.log("This is a click handler function");
document.addEventListener("click", handler);
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment11">Что такое функция первого порядка</h4>

                    <div>
                        <p>Функция первого порядка — это функция, которая не принимает другую функцию в качестве
                            аргумента и
                            не
                            возвращает функцию в качестве возвращаемого значения.</p>

                        <pre>const firstOrder = () => console.log("I am a first order function!");</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment12">Что такое функция высшего порядка</h4>

                    <div>
                        <p>Функция высшего порядка — это функция, которая принимает другую функцию в качестве
                            аргумента или возвращает функцию в качестве возвращаемого значения, или и то, и другое.
                        </p>

                        <pre>
const firstOrderFunc = () => console.log("Hello, I am a First order function");
const higherOrder = (ReturnFirstOrderFunc) => ReturnFirstOrderFunc();
higherOrder(firstOrderFunc);
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment13">Что такое унарная функция</h4>

                    <div>
                        <p>Унарная функция (т.е. монадическая) — это функция, которая принимает ровно
                            один аргумент. Он обозначает один аргумент, принимаемый функцией.
                        </p>

                        <pre>const unaryFunction = (a) => console.log(a + 10); // Add 10 to the given argument and display the value</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment14">Что такое функция каррирования</h4>

                    <div>
                        <p>
                            Каррирование — это процесс преобразования функции с несколькими аргументами в
                            последовательность
                            функций, каждая из которых имеет только один аргумент. Карринг назван в честь математика
                            Хаскелла Карри. Применяя каррирование, n-арная функция превращается в унарную функцию.
                        </p>

                        <pre>
//example

const multiArgFunction = (a, b, c) => a + b + c;
console.log(multiArgFunction(1, 2, 3)); // 6

const curryUnaryFunction = (a) => (b) => (c) => a + b + c;
curryUnaryFunction(1); // returns a function: b => c =>  1 + b + c
curryUnaryFunction(1)(2); // returns a function: c => 3 + c
curryUnaryFunction(1)(2)(3); // returns the number 6

//example

function sum(a, b, c) {
    return a + b + c;
}

function curry(fn) {
    return function curried(...args) {
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        }
        return function (...newArgs) {
            return curried.apply(this, args.concat(newArgs));
        };
    };
}

const curriedSum = curry(sum);

console.log(curriedSum(2, 3, 4));
console.log(curriedSum(2)(3)(4));
                </pre>

                        <p>Каррированные функции отлично подходят для улучшения повторного использования кода и
                            функциональной композиции.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment15">Что такое чистая функция</h4>

                    <div>
                        <p>Чистая функция — это функция, возвращаемое значение которой определяется только ее
                            аргументами
                            без
                            каких-либо побочных эффектов. т. е. если вы вызываете функцию с одинаковыми аргументами «n»
                            количество раз и «n» количество мест в приложении, она всегда будет возвращать одно и то же
                            значение.
                        </p>

                        <pre>
//Impure
let numberArray = [];
const impureAddNumber = (number) => numberArray.push(number);

//Pure
const pureAddNumber = (number) => (argNumberArray) => argNumberArray.concat([number]);

//Display the results
console.log(impureAddNumber(6)); // returns 1
console.log(numberArray); // returns [6]
console.log(pureAddNumber(7)(numberArray)); // returns [6, 7]
console.log(numberArray); // returns [6]
                </pre>

                        <p>Согласно приведенным выше фрагментам кода, функция Push сама по себе является
                            нечистой, изменяя массив
                            и возвращая индекс номера push, независимый от значения параметра, тогда как Concat, с
                            другой
                            стороны,
                            берет массив и объединяет его с другим массивом, создавая совершенно новый массив. без
                            побочных
                            эффектов. Кроме того, возвращаемое значение представляет собой объединение предыдущего
                            массива.
                        </p>

                        <p>Помните, что чистые функции важны, поскольку они упрощают модульное тестирование без
                            каких-либо
                            побочных эффектов и отсутствия необходимости внедрения зависимостей. Они также избегают
                            жесткой
                            связи и затрудняют выход из строя вашего приложения, не вызывая каких-либо побочных
                            эффектов.
                            Эти
                            принципы сочетаются с концепцией неизменности ES6: предпочтение отдается использованию
                            const, а
                            не let.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment16">Какова цель ключевого слова let</h4>

                    <div>
                        <p>Оператор let объявляет локальную переменную области действия блока(области видимости).
                            Следовательно, переменные,
                            определенные с помощью ключевого слова let, ограничены в области действия блоком, оператором
                            или
                            выражением,
                            в котором они используются. В то время как переменные, объявленные с помощью ключевого слова
                            var, используются
                            для определения переменной глобально или локально для всей функции независимо от области
                            действия блока.
                        </p>

                        <pre>
let counter = 30;
if (counter === 30) {
    let counter = 31;
    console.log(counter); // 31
}
console.log(counter); // 30 (because the variable in if block won't exist here)
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment17">В чем разница между let и var</h4>

                    <div>
                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>var</th>
                                <th>let</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Он был доступен с самого начала JavaScript.</td>
                                <td>Представлен как часть ES6.</td>
                            </tr>
                            <tr>
                                <td>Имеет глобальную область видимости</td>
                                <td>Имеет область видимости ограниченную блоком</td>
                            </tr>
                            <tr>
                                <td>Переменные будут "подняты"</td>
                                <td>Переменные "подняты", но не инициализированы</td>
                            </tr>
                            </tbody>
                        </table>
                        <pre>
function userDetails(username) {
    if (username) {
        console.log(salary); // undefined due to hoisting
        console.log(age); // ReferenceError: Cannot access 'age' before initialization
        let age = 30;
        var salary = 10000;
    }
    console.log(salary); //10000 (accessible due to function scope)
    console.log(age); //error: age is not defined(due to block scope)
}
userDetails("John");
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment18">По какой причине let выбрано в качестве ключевого слова в JS</h4>

                    <div>
                        <p>let — это математическое утверждение, которое было принято в ранних языках программирования,
                            таких как
                            Scheme и Basic. Оно было заимствовано из десятков других языков, в которых let уже
                            используется
                            как традиционное ключевое слово, максимально близкое к var.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment19">Как переобъявить переменные в блоке переключателей (switch) без
                        ошибки?</h4>

                    <div>
                        <p>Если вы попытаетесь переопределить переменные в блоке switch, это приведет к ошибкам,
                            поскольку
                            существует только один блок. Например, приведенный ниже блок кода выдает синтаксическую
                            ошибку,
                            как показано ниже:</p>

                        <pre>
let counter = 1;
switch (x) {
    case 0:
        let name;
        break;

    case 1:
        let name; // SyntaxError for redeclaration.
        break;
}
                </pre>

                        <p>Чтобы избежать этой ошибки, вы можете создать вложенный блок внутри предложения
                            case и создать новую лексическую среду с областью действия блока.
                        </p>

                        <pre>
let counter = 1;
switch (x) {
    case 0: {
        let name;
        break;
    }
    case 1: {
        let name; // No SyntaxError for redeclaration.
        break;
    }
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment20">Что такое временная мертвая зона</h4>

                    <div>
                        <p>Временная мертвая зона — это поведение в JavaScript, которое возникает при объявлении
                            переменной
                            с
                            ключевыми словами let и const, но не с var. В ECMAScript 6 доступ к переменной let или const
                            до
                            ее
                            объявления (в пределах ее области действия) вызывает ошибку ReferenceError. Промежуток
                            времени,
                            когда
                            это происходит, между созданием привязки переменной и ее объявлением, называется временной
                            мертвой зоной.
                        </p>
                        <pre>
function someMethod() {
    console.log(counter1); // undefined
    console.log(counter2); // ReferenceError
    var counter1 = 1;
    let counter2 = 2;
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment21">Что такое IIFE (выражение функции с немедленным вызовом)</h4>

                    <div>
                        <p>IIFE (выражение немедленно вызываемой функции) — это функция JavaScript, которая
                            запускается сразу после ее определения. Сигнатура будет такой, как показано ниже:</p>

                        <pre>
(function () {
    // logic here
})();
                </pre>

                        <p>Основная причина использования IIFE — обеспечение конфиденциальности данных, поскольку любые
                            переменные, объявленные в IIFE, не могут быть доступны внешнему миру. т. е. если вы
                            попытаетесь
                            получить доступ к переменным из IIFE, то выдается ошибка, как показано ниже:</p>

                        <pre>
(function () {
    var message = "IIFE";
    console.log(message);
})();
console.log(message); //Error: message is not defined
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment22">Как декодировать или кодировать URL-адрес в JavaScript?</h4>

                    <div>
                        <p>Функция encodeURI() используется для кодирования URL-адреса. Эта функция требует строку
                            URL-адреса в
                            качестве параметра и возвращает эту закодированную строку. Функция decodeURI() используется
                            для
                            декодирования URL-адреса. Эта функция требует в качестве параметра закодированную строку
                            URL-адреса и возвращает эту декодированную строку.</p>

                        <p>Примечание: Если вы хотите закодировать такие символы, как / ? : @ & = + $ # тогда вам нужно
                            использовать encodeURIComponent().</p>

                        <pre>
let uri = "employeeDetails?name=john&occupation=manager";
let encoded_uri = encodeURI(uri);
let decoded_uri = decodeURI(encoded_uri);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment23">Что такое мемоизация</h4>

                    <div>
                        <p>Мемоизация — это метод функционального программирования, который пытается повысить
                            производительность
                            функции за счет кэширования ранее вычисленных результатов. Каждый раз, когда вызывается
                            мемоизированная
                            функция, ее параметры используются для индексации кеша. Если данные присутствуют, то их
                            можно
                            вернуть,
                            не выполняя всю функцию. В противном случае функция выполняется, а затем результат
                            добавляется в
                            кеш.</p>

                        <pre>
const memoizAddition = () => {
    let cache = {};
    return (value) => {
        if (value in cache) {
            console.log("Fetching from cache");
            return cache[value]; // Here, cache.value cannot be used as property name starts with the number which is not a valid JavaScript  identifier.
            // Hence, can only be accessed using the square bracket notation.
        } else {
            console.log("Calculating result");
            let result = value + 20;
            cache[value] = result;
            return result;
        }
    };
};
// returned function from memoizAddition
const addition = memoizAddition();
console.log(addition(20)); //output: 40 calculated
console.log(addition(20)); //output: 40 cached
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment24">Что такое подъем(всплытие)</h4>

                    <div>
                        <p>Подъем(всплытие) — это механизм JavaScript, в котором переменные, объявления функций и классы
                            перемещаются в
                            верхнюю часть области видимости перед выполнением кода. Помните, что JavaScript поддерживает
                            только
                            объявления, а не инициализацию.</p>

                        <pre>
console.log(message); //output : undefined
var message = "The variable Has been hoisted";
                </pre>

                        <p>Приведенный выше код выглядит для интерпретатора следующим образом:</p>

                        <pre>
//УСЛОВНЫЙ КОД для предыдущего примера

var message;
console.log(message);
message = "The variable Has been hoisted";
                </pre>

                        <p>Таким же образом всплывают и объявления функций.</p>

                        <pre>
message("Good morning"); //Good morning

function message(name) {
    console.log(name);
}
                </pre>

                        <p>Такое поднятие позволяет безопасно использовать функции в коде до их объявления.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment25">Что такое классы в ES6</h4>

                    <div>
                        <p>В ES6 классы Javascript представляют собой в первую очередь синтаксический сахар над
                            существующим в JavaScript наследованием на основе прототипов. Например, наследование на
                            основе
                            прототипа, записанное в функциональном выражении, как показано ниже:
                        </p>

                        <pre>
function Bike(model, color) {
    this.model = model;
    this.color = color;
}

Bike.prototype.getDetails = function () {
    return this.model + " bike has" + this.color + " color";
};
                </pre>

                        <p>Классы ES6 могут быть определены как альтернатива</p>

                        <pre>
class Bike {
    constructor(color, model) {
        this.color = color;
        this.model = model;
    }

    getDetails() {
        return this.model + " bike has" + this.color + " color";
    }
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment26">Что такое замыкания</h4>

                    <div>
                        <p>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была
                            объявлена. т.е.
                            это внутренняя функция, которая имеет доступ к переменным внешней или охватывающей функции.
                            Замыкание
                            имеет три цепи охвата:</p>

                        <ol>
                            <li>Собственная область видимости, где переменные определены между фигурными скобками.</li>
                            <li>Переменные внешней функции</li>
                            <li>Глобальные переменные</li>
                        </ol>
                        <pre>
function getCounter() {
    let counter = 0;
    return function() {
        return counter++;
    }
}
let count = getCounter();
console.log(count());  // 0
console.log(count());  // 1
console.log(count());  // 2
                </pre>
                        <p>Тут мы храним ссылку на анонимную внутреннюю функцию, возвращённую функцией
                            getCounter(), в переменной count. Так как функция count() представляет собой замыкание, она
                            может обращаться к переменной counter функции getCount() даже после того, как функция
                            getCounter()
                            завершила работу.</p>
                        <p>Обратите внимание на то, что значение переменной counter не сбрасывается в 0 при каждом
                            вызове
                            функции count(). Может показаться, что оно должно сбрасываться в 0, как могло бы быть при
                            вызове
                            обычной
                            функции, но этого не происходит.</p>
                        <p>Всё работает именно так из-за того, что при каждом вызове функции count() для неё создаётся
                            новая
                            область видимости, но существует лишь одна область видимости для функции getCounter(). Так
                            как
                            переменная counter объявлена в области видимости функции getCounter(), её значение между
                            вызовами функции
                            count() сохраняется, не сбрасываясь в 0.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment27">Что такое модули</h4>

                    <div>
                        <p>Модули относятся к небольшим единицам независимого, многократно используемого кода, а также
                            служат
                            основой многих шаблонов проектирования JavaScript. Большинство модулей JavaScript
                            экспортируют
                            литерал объекта, функцию или конструктор.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment28">Зачем нужны модули</h4>

                    <div>
                        <p>Ниже приведен список преимуществ использования модулей в экосистеме JavaScript:</p>
                        <ol>
                            <li>Улучшает процесс доработки приложения</li>
                            <li>Многоразовое использование</li>
                            <li>Пространство имен</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment29">Что такое область видимости в JavaScript</h4>

                    <div>
                        <p>Область видимости — это доступность переменных, функций и объектов в определенной части
                            вашего
                            кода во
                            время выполнения. Другими словами, область видимости определяет видимость переменных и
                            других
                            ресурсов в
                            областях вашего кода.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment30">Что такое сервисный работник(service worker)</h4>

                    <div>
                        <p>Сервис воркеры — это, по сути, скрипт (файл JavaScript), который выполняется в фоновом режиме
                            отдельно от веб-страницы и предоставляет функции, не требующие веб-страницы или
                            взаимодействия с
                            пользователем. Некоторые из основных функций сервис воркеров — это богатый автономный опыт
                            (сначала
                            разработка веб-приложений в автономном режиме), периодическая фоновая синхронизация,
                            push-уведомления,
                            перехват и обработка сетевых запросов, а также программное управление кешем ответов.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment31">Как манипулировать DOM с помощью сервис-воркера</h4>

                    <div>
                        <p>Сервис-воркер не может получить прямой доступ к DOM. Но он может взаимодействовать
                            со страницами, которые он контролирует, отвечая на сообщения, отправленные через
                            интерфейс postMessage, и эти страницы могут манипулировать DOM.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment32">Как повторно использовать информацию при перезапуске Service
                        Worker?</h4>

                    <div>
                        <p>Проблема с сервис-воркером заключается в том, что он завершается, когда он не используется, и
                            перезапускается, когда он в следующий раз понадобится, поэтому вы не можете полагаться на
                            глобальное состояние в обработчиках onfetch и onmessage сервис-воркера. В этом случае
                            сервисные
                            работники будут иметь доступ к API IndexedDB для его сохранения и повторного использования
                            при
                            перезапусках.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment33">Что такое IndexedDB</h4>

                    <div>
                        <p>IndexedDB — это низкоуровневый API для хранения на стороне клиента больших
                            объемов структурированных данных, включая файлы и BLOB-объекты.
                            Этот API использует индексы для обеспечения высокопроизводительного поиска этих данных.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment34">Что такое веб-хранилище(web storage)</h4>

                    <div>
                        <p>Веб-хранилище — это API, который предоставляет механизм, с помощью которого браузеры могут
                            хранить пары
                            ключ/значение локально в браузере пользователя, гораздо более интуитивно понятным способом,
                            чем
                            использование файлов cookie. Веб-хранилище предоставляет два механизма хранения данных на
                            клиенте:</p>

                        <ol>
                            <li>Локальное хранилище: оно хранит данные текущего происхождения без срока действия.</li>
                            <li>Хранилище сеансов: оно хранит данные за один сеанс, и данные теряются при закрытии
                                вкладки
                                браузера.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment35">Что такое post сообщение</h4>

                    <div>
                        <p>Post сообщение — это метод, который обеспечивает связь между источниками между объектами
                            Window
                            (т. е. между страницей и всплывающим окном, которое она создала, или между страницей и
                            встроенным в
                            нее iframe). Как правило, сценариям на разных страницах разрешен доступ друг к другу тогда и
                            только
                            тогда, когда страницы следуют политике одного и того же происхождения (т. е. страницы
                            используют
                            один и
                            тот же протокол, номер порта и хост).
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment36">Что такое Cookie</h4>

                    <div>
                        <p>Файл cookie — это часть данных, которая хранится на вашем компьютере и доступна вашему
                            браузеру.
                            Файлы
                            cookie сохраняются в виде пар ключ/значение. Например, вы можете создать файл cookie с
                            именем
                            пользователя, как показано ниже:</p>

                        <pre>document.cookie = "username=John";</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment37">Зачем вам нужен Cookie</h4>

                    <div>
                        <p>Файлы cookie используются для запоминания информации о профиле пользователя
                            (например, имени пользователя). В основном это включает в себя два шага:</p>

                        <ol>
                            <li>Когда пользователь посещает веб-страницу, профиль пользователя может быть сохранен в
                                файле
                                cookie.
                            </li>
                            <li>Когда пользователь в следующий раз посетит страницу, файл cookie запоминает профиль
                                пользователя.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment38">Какие параметры есть в Cookie</h4>

                    <div>
                        <p>Для файлов cookie доступно несколько вариантов ниже:</p>

                        <ol>
                            <li>
                                По умолчанию файл cookie удаляется при закрытии браузера, но вы можете
                                изменить это поведение, установив дату истечения срока действия (по времени UTC).
                                <pre>document.cookie = "username=John; expires=Sat, 8 Jun 2019 12:00:00 UTC";</pre>
                            </li>
                            <li>
                                По умолчанию файл cookie принадлежит текущей странице. Но вы можете сообщить
                                браузеру, какому пути принадлежит файл cookie, используя параметр пути.
                                <pre>document.cookie = "username=John; path=/services";</pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment39">Как удалить файл cookie</h4>

                    <div>
                        <p>Вы можете удалить файл cookie, установив дату истечения срока его действия как прошедшую
                            дату. В
                            этом
                            случае вам не нужно указывать значение cookie. Например, вы можете удалить файл cookie имени
                            пользователя на текущей странице, как показано ниже.
                        </p>

                        <pre>document.cookie = "username=; expires=Fri, 07 Jun 2019 00:00:00 UTC; path=/;";</pre>

                        <p>Примечание. Вам следует определить параметр пути к файлам cookie, чтобы гарантировать
                            удаление
                            нужного файла cookie.
                            Некоторые браузеры не позволяют удалять файлы cookie, если вы не укажете параметр пути.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment40">В чем разница между файлами cookie, локальным хранилищем и
                        хранилищем сеансов?</h4>

                    <div>
                        <p>Ниже приведены некоторые различия между файлами cookie, локальным хранилищем и хранилищем
                            сеансов.</p>

                        <div class="tableWrapper">
                            <table class="jsTheoryTable">
                                <thead>
                                <tr>
                                    <th>Особенность</th>
                                    <th>Cookie</th>
                                    <th>Local storage</th>
                                    <th>Session storage</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>Доступ на стороне клиента или сервера</td>
                                    <td>Как на стороне сервера, так и на стороне клиента</td>
                                    <td>только на стороне клиента</td>
                                    <td>только на стороне клиента</td>
                                </tr>
                                <tr>
                                    <td>Продолжит. жизни</td>
                                    <td>Как настроено с использованием параметра Expires</td>
                                    <td>пока не будет удален</td>
                                    <td>пока вкладка не закроется</td>
                                </tr>
                                <tr>
                                    <td>Поддержка SSL</td>
                                    <td>Поддерж.</td>
                                    <td>Не поддерж.</td>
                                    <td>Не поддерж.</td>
                                </tr>
                                <tr>
                                    <td>Макс. размер данных</td>
                                    <td>4 KB</td>
                                    <td>5 MB</td>
                                    <td>5 MB</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment41">В чем основная разница между localStorage и sessionStorage?</h4>

                    <div>
                        <p>LocalStorage аналогичен SessionStorage, но он сохраняет данные, даже когда
                            браузер
                            закрывается и снова
                            открывается (т. е. у него нет срока действия), тогда как в sessionStorage данные очищаются
                            после
                            завершения сеанса страницы.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment42">Как получить доступ к веб-хранилищу</h4>

                    <div>
                        <p>Объект Window реализует объекты WindowLocalStorage и WindowSessionStorage,
                            которые
                            имеют свойства
                            localStorage(window.localStorage) и sessionStorage(window.sessionStorage) соответственно.
                            Эти
                            свойства
                            создают экземпляр объекта Storage, с помощью которого можно устанавливать, получать и
                            удалять
                            элементы
                            данных для определенного домена и типа хранилища (сеансовое или локальное). Например, вы
                            можете
                            читать и
                            записывать объекты локального хранилища, как показано ниже.
                        </p>

                        <pre>
localStorage.setItem("logo", document.getElementById("logo").value);
localStorage.getItem("logo");
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment43">Какие методы доступны в хранилище сеансов?</h4>

                    <div>
                        <p>Хранилище сеансов предоставляет методы для чтения, записи и очистки данных сеанса.</p>

                        <pre>
// Save data to sessionStorage
sessionStorage.setItem("key", "value");

// Get saved data from sessionStorage
let data = sessionStorage.getItem("key");

// Remove saved data from sessionStorage
sessionStorage.removeItem("key");

// Remove all saved data from sessionStorage
sessionStorage.clear();
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment44">Что такое событие хранилища и его обработчик событий</h4>

                    <div>
                        <p>StorageEvent — это событие, которое срабатывает, когда область хранения была
                            изменена в контексте
                            другого документа. Тогда как свойство onstorage — это EventHandler для обработки событий
                            хранилища.
                            Синтаксис будет таким, как показано ниже:
                        </p>

                        <pre>window.onstorage = functionRef;</pre>

                        <p>Давайте возьмем пример использования обработчика событий onstorage, который
                            регистрирует ключ хранилища и его значения.</p>
                        <pre>
window.onstorage = function (e) {
    console.log(
        "The " +
        e.key +
        " key has been changed from " +
        e.oldValue +
        " to " +
        e.newValue +
        "."
    );
};
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment45">Зачем нужно веб-хранилище</h4>

                    <div>
                        <p>Веб-хранилище более безопасно, и большие объемы данных могут храниться
                            локально, не влияя на
                            производительность веб-сайта. Кроме того, информация никогда не передается на сервер.
                            Следовательно, это более рекомендуемый подход, чем использование файлов cookie.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment46">Как проверить поддержку веб-хранилища браузером</h4>

                    <div>
                        <p>Перед использованием веб-хранилища необходимо проверить поддержку браузером
                            localStorage и sessionStorage.</p>

                        <pre>
if (typeof Storage !== "undefined") {
    // Code for localStorage/sessionStorage.
} else {
    // Sorry! No Web Storage support..
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment47">Как проверить поддержку браузером веб-воркеров</h4>

                    <div>
                        <p>Прежде чем использовать его, необходимо проверить поддержку веб-воркеров в
                            браузере.</p>

                        <pre>
if (typeof Worker !== "undefined") {
    // code for Web worker support.
} else {
    // Sorry! No Web Worker support..
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment48">Приведите пример веб-воркера</h4>

                    <div>
                        <p>Вам необходимо выполнить следующие шаги, чтобы начать использовать
                            веб-воркеров для примера подсчета.
                        </p>

                        <ol>
                            <li>
                                Создайте файл веб-воркера: необходимо написать сценарий для увеличения значения
                                счетчика.
                                Назовем его counter.js.

                                <pre>
let i = 0;

function timedCount() {
    i = i + 1;
    postMessage(i);
    setTimeout("timedCount()", 500);
}

timedCount();
                        </pre>

                                Здесь метод postMessage() используется для отправки сообщения обратно на HTML-страницу.
                            </li>
                            <li>
                                Создайте объект веб-воркера. Вы можете создать объект веб-рабочего, проверив поддержку
                                браузера. Назовем этот файл web_worker_example.js.
                                <pre>
if (typeof w == "undefined") {
    w = new Worker("counter.js");
}
                        </pre>

                                и мы можем получать сообщения от веб-воркера

                                <pre>
w.onmessage = function (event) {
    document.getElementById("message").innerHTML = event.data;
};
                        </pre>
                            </li>
                            <li>
                                Завершить веб-воркер: Веб-воркеры будут продолжать прослушивать
                                сообщения (даже после завершения
                                внешнего скрипта), пока он не будет завершен. Вы можете использовать метод terminate(),
                                чтобы прекратить прослушивание сообщений.

                                <pre>w.terminate();</pre>
                            </li>
                            <li>
                                Повторное использование веб-воркера: Если вы установите для рабочей
                                переменной значение undefined, вы сможете повторно использовать код.

                                <pre>w = undefined;</pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment49">Каковы ограничения веб-воркеров в DOM</h4>

                    <div>
                        <p>Веб-воркеры не имеют доступа к объектам JavaScript из списка ниже, поскольку они определены
                            во
                            внешних файлах:</p>

                        <ol>
                            <li>Window object</li>
                            <li>Document object</li>
                            <li>Родительский объект</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment50">Что такое promise</h4>

                    <div>
                        <p>Промис — это объект, который может когда-нибудь в будущем создать одно
                            значение, которое будет либо с разрешенным значением, либо с причиной,
                            по которой оно не было разрешено (например, сетевая ошибка). Оно будет
                            находиться в одном из трех возможных состояний: выполнено(fulfilled),
                            отклонено(rejected) или ожидается(pending).
                        </p>

                        <p>Синтаксис создания промиса выглядит следующим образом:</p>

                        <pre>
const promise = new Promise(function (resolve, reject) {
    // promise description
});
                </pre>

                        <p>Использование обещания будет выглядеть следующим образом:</p>

                        <pre>
const promise = new Promise(
        (resolve) => {
            setTimeout(() => {
            resolve("I'm a Promise!");
        }, 5000);
    },
    (reject) => {}
);

promise.then((value) => console.log(value));
                </pre>

                        <p>Последовательность действий промиса будет такой, как показано ниже:</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/promises.png" alt="promises">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment51">Для чего нужен промис</h4>

                    <div>
                        <p>Промисы используются для обработки асинхронных операций. Они предоставляют
                            альтернативный подход к
                            обратным вызовам, уменьшая "ад обратных вызовов" и написав более чистый код.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment52">Три состояния промиса</h4>

                    <div>
                        <p>Промисы имеют три состояния:</p>

                        <ol>
                            <li>Pending(ожидание): это начальное состояние промиса перед началом операции.</li>
                            <li>Fulfilled(выполнено): это состояние указывает, что указанная операция была завершена.
                            </li>
                            <li>Rejected(отклонено): это состояние указывает на то, что операция не
                                завершена. В этом случае будет выдано значение ошибки.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment53">Что такое функция обратного вызова(callback функция)</h4>

                    <div>
                        <p>Функция обратного вызова(callback функция) — это функция, передаваемая в другую функцию
                            в качестве аргумента. Эта функция вызывается внутри внешней функции для завершения действия.
                            Давайте рассмотрим простой пример использования функции обратного вызова:
                        </p>

                        <pre>
function callbackFunction(name) {
    console.log("Hello " + name);
}

function outerFunction(callback) {
    let name = prompt("Please enter your name.");
    callback(name);
}

outerFunction(callbackFunction);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment54">Почему нужны колбэк функции</h4>

                    <div>
                        <p>Колбэк функции необходимы, потому что javascript — это язык, управляемый событиями.
                            Это означает, что вместо ожидания ответа JavaScript будет продолжать выполняться,
                            прослушивая другие события. Давайте возьмем пример с первой функцией, вызывающей вызов API
                            (моделируемый setTimeout), и следующей функцией, которая регистрирует сообщение:</p>

                        <pre>
function firstFunction() {
    // Simulate a code delay
    setTimeout(function () {
        console.log("First function called");
    }, 1000);
}
function secondFunction() {
    console.log("Second function called");
}
firstFunction();
secondFunction();

Output:
// Second function called
// First function called
                </pre>

                        <p>Как видно из выходных данных, javascript не дождался ответа первой функции, и оставшийся блок
                            кода был
                            выполнен. Таким образом, обратные вызовы используются для того, чтобы гарантировать, что
                            определенный
                            код не будет выполняться, пока другой код не завершит выполнение.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment55">Что такое "ад обратного вызова"</h4>

                    <div>
                        <p>Callback Hell — это анти-паттерн с несколькими вложенными обратными вызовами, который
                            затрудняет
                            чтение и
                            отладку кода при работе с асинхронной логикой. Ад обратного вызова выглядит следующим
                            образом:</p>

                        <pre>
async1(function(){
    async2(function(){
        async3(function(){
            async4(function(){
                ....
            });
        });
    });
});
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment56">Что такое события, отправляемые сервером</h4>

                    <div>
                        <p>События, отправленные сервером (SSE) — это технология push-уведомлений сервера, позволяющая
                            браузеру
                            получать автоматические обновления с сервера через HTTP-соединение, не прибегая к запросу.
                            Это
                            односторонний канал связи — события передаются только от сервера к клиенту. Это
                            использовалось в
                            обновлениях Facebook/Twitter, обновлениях цен на акции, новостных лентах и т. д.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment57">Как вы получаете уведомления о событиях, отправленные сервером</h4>

                    <div>
                        <p>Объект EventSource используется для получения уведомлений о событиях, отправленных
                            сервером. Например, вы можете получать сообщения с сервера, как показано ниже:</p>

                        <pre>
if (typeof EventSource !== "undefined") {
    var source = new EventSource("sse_generator.js");
    source.onmessage = function (event) {
        document.getElementById("output").innerHTML += event.data + "&lt;br&gt;";
    };
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment58">Как проверить поддержку браузером событий, отправленных
                        сервером?</h4>

                    <div>
                        <p>Вы можете выполнить поддержку браузера для событий, отправленных сервером, прежде чем
                            использовать его, как показано ниже:</p>

                        <pre>
if (typeof EventSource !== "undefined") {
    // Server-sent events supported. Let's have some code here!
} else {
    // No server-sent events supported
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment59">Какие события доступны для событий, отправленных сервером?</h4>

                    <div>
                        <p>Ниже приведен список событий, доступных для событий, отправленных
                            сервером.</p>

                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>Событие</th>
                                <th>Событие</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>onopen</td>
                                <td>Используется при открытии соединения с сервером.</td>
                            </tr>
                            <tr>
                                <td>onmessage</td>
                                <td>Это событие используется при получении сообщения</td>
                            </tr>
                            <tr>
                                <td>onerror</td>
                                <td>Это происходит, когда возникает ошибка</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment60">Каковы основные правила промисов</h4>

                    <div>
                        <p>Промис должен соответствовать определенному набору правил:</p>

                        <ol>
                            <li>Промис — это объект, который предоставляет соответствующий стандарту метод .then().</li>
                            <li>Ожидающий(pending) промис может перейти в состояние "выполнено"(fulfilled) или
                                "отклонено"(rejected).
                            </li>
                            <li>Выполненный или отклоненный промис является урегулированным и не должен переходить в
                                какое-либо другое состояние.
                            </li>
                            <li>После того как промис выполнен, его значение не должно меняться.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment61">Что такое обратный вызов в обратном вызове</h4>

                    <div>
                        <p>Вы можете вложить один обратный вызов в другой обратный вызов, чтобы выполнять действия
                            последовательно одно за другим. Это называется - обратные вызовы в обратных вызовах.</p>

                        <pre>
loadScript("/script1.js", function (script) {
    console.log("first script is loaded");

    loadScript("/script2.js", function (script) {
            console.log("second script is loaded");

            loadScript("/script3.js", function (script) {
            console.log("third script is loaded");
            // after all scripts are loaded
        });
    });
});
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment62">Что такое цепочка промисов</h4>

                    <div>
                        <p>Процесс выполнения последовательности асинхронных задач одна за другой с использованием
                            промисов
                            известен как цепочка промисов. Давайте рассмотрим пример цепочки обещаний для расчета
                            конечного
                            результата:
                        </p>

                        <pre>
new Promise(function (resolve, reject) {
    setTimeout(() => resolve(1), 1000);
})
.then(function (result) {
    console.log(result); // 1
    return result * 2;
})
.then(function (result) {
    console.log(result); // 2
    return result * 3;
})
.then(function (result) {
    console.log(result); // 6
    return result * 4;
});
                </pre>

                        <p>В приведенных выше обработчиках результат передается в цепочку обработчиков .then()
                            с приведенным ниже рабочим процессом:</p>

                        <ol>
                            <li>Первоначальный промис выполняется через 1 секунду</li>
                            <li>После этого вызывается обработчик .then, регистрирующий результат (1), а затем
                                возвращает
                                промис со значением result * 2.
                            </li>
                            <li>После этого значение передается следующему обработчику .then путем регистрации
                                результата
                                (2) и возврата промиса с result * 3.
                            </li>
                            <li>Наконец, значение передается последнему обработчику .then путем регистрации результата
                                (6) и
                                возврата промиса с result * 4.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment63">Что такое promise.all</h4>

                    <div>
                        <p>Promise.all — это промис, который принимает на вход массив промисов (итерируемый объект), и
                            он
                            выполняется, когда все промисы решены или какой-либо из них отклонен. Например, синтаксис
                            метода
                            Promise.all приведен ниже:</p>

                        <pre>
Promise.all([Promise1, Promise2, Promise3])
    .then(result => console.log(result))
    .catch(error => console.log(`Error in promises ${error}`))
                </pre>

                        <p>Примечание: Помните, что порядок промисов (вывод результата) сохраняется в соответствии с
                            порядком ввода.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment64">Какова цель метода race() в промисе</h4>

                    <div>
                        <p>Метод Promise.race() вернет экземпляр промиса, который был первым разрешен или отклонен.
                            Давайте
                            возьмем пример метода race(), где сначала разрешается Promise2:</p>

                        <pre>
var promise1 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 500, "one");
});
var promise2 = new Promise(function (resolve, reject) {
    setTimeout(resolve, 100, "two");
});

Promise.race([promise1, promise2]).then(function (value) {
    console.log(value); // "two" // Both promises will resolve, but promise2 is faster
});
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment65">Что такое strict mode(строгий режим) в JavaScript</h4>

                    <div>
                        <p>Строгий режим(strict mode) — это новая функция ECMAScript 5, которая позволяет поместить
                            программу или функцию в
                            «строгий» рабочий контекст. Таким образом, он предотвращает выполнение определенных действий
                            и
                            генерирует больше
                            исключений. Буквальное выражение "use strict"; указывает браузеру использовать код
                            JavaScript в
                            строгом режиме.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment66">Для чего нужен строгий режим(strict mode)</h4>

                    <div>
                        <p>Строгий режим полезен для написания «безопасного» JavaScript кода, уведомляя «плохой
                            синтаксис» о
                            реальных
                            ошибках. Например, он исключает случайное создание глобальной переменной путем выдачи
                            ошибки, а
                            также
                            выдает ошибку при присвоении свойству, не доступному для записи, свойству геттеру,
                            несуществующему
                            свойству, несуществующей переменной и несуществующему объекту.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment67">Как объявить строгий режим</h4>

                    <div>
                        <p>Строгий режим объявляется добавлением «use strict»; в начало скрипта или функции.
                            Если он объявлен в начале скрипта, он имеет глобальную область действия.</p>

                        <pre>
"use strict";
x = 3.14; // This will cause an error because x is not declared
                </pre>

                        <p>и если вы объявляете строгий режим внутри функции, она имеет локальную область видимости</p>

                        <pre>
x = 3.14; // This will not cause an error.
myFunction();

function myFunction() {
    "use strict";
    y = 3.14; // This will cause an error
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment68">Какова цель двойного восклицательного знака (отрицание
                        отрицания)</h4>

                    <div>
                        <p>Двойное восклицание или отрицание (!!) гарантирует, что результирующий тип является
                            логическим.
                            Если
                            оно было ложным (например, 0, null, undefined, и т. д.), оно будет ложным, в противном
                            случае
                            оно
                            будет истинным. Например, вы можете проверить версию IE, используя это выражение, как
                            показано
                            ниже:
                        </p>

                        <pre>
let isIE8 = false;
isIE8 = !!navigator.userAgent.match(/MSIE 8.0/);
console.log(isIE8); // returns true or false
                </pre>

                        <p>Если вы не используете это выражение, оно возвращает исходное значение.</p>

                        <pre>console.log(navigator.userAgent.match(/MSIE 8.0/)); // returns either an Array or null</pre>

                        <p>Примечание: выражение !! не является оператором, но это всего лишь двойной оператор "!"</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment69">Какова цель оператора delete</h4>

                    <div>
                        <p>Ключевое слово delete используется для удаления свойства объекта, а также его значения.</p>

                        <pre>
var user = { name: "John", age: 20 };
delete user.age;

console.log(user); // {name: "John"}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment70">Что такое оператор typeof</h4>

                    <div>
                        <p>Вы можете использовать оператор typeof JavaScript, чтобы найти тип переменной JavaScript. Он
                            возвращает тип переменной или выражения.</p>

                        <pre>
typeof "John Abraham"; // Returns "string"
typeof (1 + 2); // Returns "number"
typeof [1, 2, 3]; // Returns "object" because all arrays are also objects
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment71">Что такое свойство undefined</h4>

                    <div>
                        <p>Свойство undefined указывает, что переменной не присвоено значение или она
                            объявлена, но не инициализирована вообще. Тип undefined значения также undefined.</p>

                        <pre>
var user; // Value is undefined, type is undefined
console.log(typeof user); //undefined
                </pre>

                        <p>Любую переменную можно очистить, установив ее значение undefined.</p>

                        <pre>user = undefined;</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment72">Что такое null значение</h4>

                    <div>
                        <p>Значение null представляет намеренное отсутствие какого-либо значения объекта.
                            Это одно из примитивных значений JavaScript. Тип нулевого значения — объект.
                            Вы можете очистить переменную, установив ее значение равным нулю.</p>

                        <pre>
var user = null;
console.log(typeof user); //object
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment73">В чем разница между null и undefined</h4>

                    <div>
                        <p>Ниже приведены основные различия между нулевым и неопределенным:</p>

                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>Null</th>
                                <th>Undefined</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Это значение присваивания, которое указывает, что переменная не указывает ни на один
                                    объект.
                                </td>
                                <td>Означает, что переменная объявлена, но не имеет значения.</td>
                            </tr>
                            <tr>
                                <td>Тип null — объект</td>
                                <td>Тип undefined собственно сам undefined</td>
                            </tr>
                            <tr>
                                <td>Значение null — это примитивное значение, которое представляет нулевую, пустую или
                                    несуществующую ссылку.
                                </td>
                                <td>undefined значение — это примитивное значение, используемое, когда переменной не
                                    присвоено значение.
                                </td>
                            </tr>
                            <tr>
                                <td>Указывает на отсутствие значения переменной</td>
                                <td>Указывает на отсутствие самой переменной</td>
                            </tr>
                            <tr>
                                <td>Преобразуется в ноль (0) при выполнении примитивных операций.</td>
                                <td>Преобразуется в NaN при выполнении примитивных операций.</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment74">Что такое eval()</h4>

                    <div>
                        <p>Функция eval() оценивает код JavaScript, представленный в виде строки. Строка может быть
                            выражением JavaScript, переменной, оператором или последовательностью операторов.</p>

                        <pre>console.log(eval("1 + 2")); //  3</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment75">В чем разница между window и document</h4>

                    <div>
                        <p>Ниже приведены основные различия между window и document:</p>

                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>Window</th>
                                <th>Document</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Это элемент корневого уровня на любой веб-странице.</td>
                                <td>Это прямой дочерний объект объекта window. Это также известно как объектная модель
                                    документа (DOM).
                                </td>
                            </tr>
                            <tr>
                                <td>По умолчанию объект window неявно доступен на странице.</td>
                                <td>Вы можете получить к нему доступ через window.document или document.</td>
                            </tr>
                            <tr>
                                <td>Имеет такие методы, как alert(), confirm() и такие свойства, как document, location.
                                </td>
                                <td>Предоставляет такие методы, как getElementById, getElementsByTagName, createElement
                                    и т.
                                    д.
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment76">Как получить доступ к истории(history) в JavaScript</h4>

                    <div>
                        <p>Объект window.history содержит историю браузера. Вы можете загрузить предыдущий и следующий
                            URL-адреса
                            в историю, используя методы back() и next().</p>

                        <pre>
function goBack() {
    window.history.back();
}
function goForward() {
    window.history.forward();
}
                        </pre>

                        <p>Примечание: Вы также можете получить доступ к истории без префикса window.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment77">Как определить, включена клавиша Caps Lock или нет?</h4>

                    <div>
                        <p>mouseEvent getModifierState() используется для возврата логического значения, которое
                            указывает, активирована ли указанная клавиша-модификатор или нет. Модификаторы, такие
                            как CapsLock, ScrollLock и NumLock, активируются при нажатии на них и деактивируются
                            при повторном нажатии.</p>

                        <pre>
&lt;input type="password" onmousedown="enterInput(event)"&gt;

&lt;p id="feedback"&gt;&lt;/p&gt;

&lt;script&gt;
    function enterInput(e) {
        var flag = e.getModifierState("CapsLock");
        if (flag) {
            document.getElementById("feedback").innerHTML = "CapsLock activated";
        } else {
            document.getElementById("feedback").innerHTML =
            "CapsLock not activated";
        }
    }
&lt;/script&gt;
                </pre>
                        <input aria-label="password input" type="password" onclick="enterInput(event)">

                        <p id="feedback"></p>

                        <script>
                            function enterInput(e) {
                                var flag = e.getModifierState("CapsLock");
                                if (flag) {
                                    document.getElementById("feedback").innerHTML = "CapsLock activated";
                                } else {
                                    document.getElementById("feedback").innerHTML =
                                        "CapsLock not activated";
                                }
                            }
                        </script>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment78">Что такое isNaN</h4>

                    <div>
                        <p>Функция isNaN() используется для определения того, является ли значение недопустимым числом
                            (не
                            числом)
                            или нет. т. е. эта функция возвращает true, если значение равно NaN. В противном случае он
                            возвращает false.</p>

                        <pre>
isNaN("Hello"); //true
isNaN("100"); //false
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment79">В чем разница между необъявленными и неопределенными
                        переменными</h4>

                    <div>
                        <p>Ниже приведены основные различия между необъявленными(not defined) и неопределенными
                            переменными.</p>

                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>undeclared</th>
                                <th>undefined</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Эти переменные не существуют в программе и не объявлены.</td>
                                <td>Эти переменные объявлены в программе, но им не присвоено никакого значения.</td>
                            </tr>
                            <tr>
                                <td>Если вы попытаетесь прочитать значение необъявленной переменной, то возникнет
                                    runtime
                                    error
                                </td>
                                <td>Если вы попытаетесь прочитать значение неопределенной переменной, будет возвращено
                                    значение undefined.
                                </td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment80">Что такое глобальные переменные</h4>

                    <div>
                        <p>Глобальные переменные — это те, которые доступны по всему коду без какой-либо области
                            действия.
                            То есть вне блока, функции и модуля.</p>

                        <pre>
// глобальные переменные car и year
let car = 'Audi';
let year = 2007;

function myFunc() {
    // локальная переменная car
    let car = 'Ford';
    console.log(car); // "Ford"
    console.log(year); // 2007
}
myFunc(); // "Audi"
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment81">Какие проблемы с глобальными переменными</h4>

                    <div>
                        <p>Проблема с глобальными переменными заключается в конфликте имен переменных локальной и
                            глобальной
                            области видимости. Также сложно отлаживать и тестировать код, использующий глобальные
                            переменные.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment82">Что такое свойство NaN</h4>

                    <div>
                        <p>Свойство NaN — это глобальное свойство, представляющее значение «Не число». т. е. указывает,
                            что
                            значение не является допустимым числом. NaN используется в программе очень редко, но в
                            некоторых
                            случаях его можно использовать в качестве возвращаемого значения.</p>

                        <pre>
Math.sqrt(-1);
parseInt("Hello");
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment83">Какова цель функции isFinite</h4>

                    <div>
                        <p>Функция isFinite() используется для определения того, является ли число
                            конечным и допустимым числом. Он возвращает false, если значение равно +infinity,
                            -infinity или NaN (не число), в противном случае возвращается true.</p>

                        <pre>
isFinite(Infinity); // false
isFinite(NaN); // false
isFinite(-Infinity); // false

isFinite(100); // true
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment84">Что такое поток событий</h4>

                    <div>
                        <p>Поток событий — это порядок, в котором события принимаются на веб-странице.
                            Когда вы щелкаете элемент, вложенный в различные другие элементы, прежде чем ваш
                            щелчок действительно достигнет места назначения или целевого элемента, он должен
                            сначала вызвать событие щелчка для каждого из своих родительских элементов,
                            начиная сверху с объекта глобального окна. Существует два способа потока событий:
                        </p>

                        <ol>
                            <li>Сверху вниз (перехват событий)</li>
                            <li>Снизу вверх (всплытие событий)</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment85">Что такое всплытие событий</h4>

                    <div>
                        <p>Всплытие событий — это тип распространения событий, при котором событие сначала
                            инициируется на самом внутреннем целевом элементе, а затем последовательно инициируется
                            на предках (родителях) целевого элемента в той же иерархии вложенности, пока не достигнет
                            самого внешнего элемента DOM.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment86">Что такое перехват событий</h4>

                    <div>
                        <p>Перехват событий — это тип распространения событий, при котором событие сначала фиксируется
                            самым
                            внешним элементом, а затем последовательно срабатывает на потомках (дочерних элементах)
                            целевого
                            элемента в той же иерархии вложенности, пока не достигнет самого внутреннего элемента DOM.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment87">Как отправить форму с помощью JavaScript</h4>

                    <div>
                        <p>Вы можете отправить форму, используя document.forms[0].submit(). Вся
                            информация ввода формы отправляется с использованием обработчика событий onsubmit.
                        </p>

                        <pre>
function submit() {
    document.forms[0].submit();
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment88">Как найти сведения об операционной системе</h4>

                    <div>
                        <p>Объект window.navigator содержит информацию о деталях ОС браузера посетителя.
                            Некоторые свойства ОС доступны в разделе свойств платформы.</p>

                        <pre>console.log(navigator.platform);</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment89">В чем разница между загрузкой документа и событиями
                        DOMContentLoaded</h4>

                    <div>
                        <p>Событие DOMContentLoaded вызывается, когда исходный HTML-документ полностью загружен и
                            проанализирован,
                            не дожидаясь завершения загрузки ресурсов (таблиц стилей, изображений и подкадров). Принимая
                            во
                            внимание,
                            что событие загрузки вызывается при загрузке всей страницы, включая все зависимые ресурсы
                            (таблицы стилей, изображения).
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment90">В чем разница между собственными, хостовыми и пользовательскими
                        объектами</h4>

                    <div>
                        <p>Собственные объекты — это объекты, являющиеся частью языка JavaScript, определенного
                            спецификацией
                            ECMAScript. Например, основные объекты String, Math, RegExp, Object, Function и т. д.,
                            определенные в
                            спецификации ECMAScript. Хост-объекты — это объекты, предоставляемые браузером или средой
                            выполнения
                            (Node). Например, окно, XmlHttpRequest, узлы DOM и т. д. считаются объектами хоста.
                            Пользовательские
                            объекты — это объекты, определенные в коде JavaScript. Например, объекты «Пользователь»,
                            созданные для
                            информации профиля.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment91">Какие инструменты или методы используются для отладки кода
                        JavaScript?</h4>

                    <div>
                        <p>Вы можете использовать приведенные ниже инструменты или методы для отладки JavaScript:</p>

                        <ol>
                            <li>Chrome Devtools</li>
                            <li>
                                <div>оператор debugger [1]</div>
                            </li>
                            <li>console.log()</li>
                        </ol>

                        <p>Пример debugger:</p>

                        <div class="imgLongWidth">
                            <img src="./assets/debugger.png" alt="debugger" width="900">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment92">Каковы плюсы и минусы промисов перед обратными вызовами</h4>

                    <div>
                        <p>Ниже приведена таблица плюсов и минусов промисов перед обратными вызовами:</p>

                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>+</th>
                                <th>-</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Это позволяет избежать ада обратных вызовов, который нечитабелен.</td>
                                <td>Это делает небольшой сложный код</td>
                            </tr>
                            <tr>
                                <td>Легко писать последовательный асинхронный код с помощью .then()</td>
                                <td>Вам необходимо загрузить полифилл, если ES6 не поддерживается.</td>
                            </tr>
                            <tr>
                                <td>Легко писать параллельный асинхронный код с помощью Promise.all()</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>
                                    Решает некоторые распространенные проблемы обратных вызовов (вызов
                                    колбэка слишком поздно, слишком рано, много раз и проглатывает ошибки/исключения).
                                </td>
                                <td>-</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment93">В чем разница между атрибутом и свойством</h4>

                    <div>
                        <p>Атрибуты определяются в разметке HTML, тогда как свойства определяются в DOM.
                            Например, приведенный ниже элемент HTML имеет 2 атрибута типа и значения:</p>

                        <pre>&lt;input type="text" value="Name:"&gt;</pre>

                        <p>Вы можете получить значение атрибута, как показано ниже:</p>

                        <pre>
const input = document.querySelector("input");
console.log(input.getAttribute("value")); // Good morning
console.log(input.value); // Good morning
                </pre>

                        <p>А после того, как вы измените значение текстового поля на «Good evening», это станет похоже
                            на:</p>

                        <pre>
console.log(input.getAttribute("value")); // Good evening
console.log(input.value); // Good evening
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment94">Что такое политика одного и того же происхождения(CORS)</h4>

                    <div>
                        <p>Политика одного и того же происхождения — это политика, которая запрещает JavaScript
                            выполнять
                            запросы
                            через границы домена. Источник определяется как комбинация схемы URI, имени хоста и номера
                            порта.
                            Если вы включите эту политику, она не позволит вредоносному сценарию на одной странице
                            получить
                            доступ к конфиденциальным данным на другой веб-странице с помощью объектной модели документа
                            (DOM).</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment95">Какова цель void(0)</h4>

                    <div>
                        <p>Void(0) используется для предотвращения обновления страницы. Это поможет устранить
                            нежелательный
                            побочный эффект, поскольку вернет неопределенное примитивное значение. Обычно он
                            используется для
                            HTML-документов, использующих href="JavaScript:Void(0);" внутри элемента
                            <code>&lt;a&gt;</code>.
                            т. е. когда вы нажимаете ссылку, браузер загружает новую страницу или обновляет ту же
                            страницу.
                            Но такое поведение будет предотвращено с помощью этого выражения. Например, ссылка ниже
                            уведомляет
                            сообщение без перезагрузки страницы.</p>

                        <pre>
&lt;a href="JavaScript:void(0);" onclick="alert('Well done!')"&gt;
    Click Me!
&lt;/a&gt;
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment96">JavaScript является компилируемым или интерпретируемым языком?</h4>

                    <div>
                        <p>JavaScript — это интерпретируемый язык, а не компилируемый язык. Интерпретатор в браузере
                            читает
                            код
                            JavaScript, интерпретирует каждую строку и запускает его. В настоящее время современные
                            браузеры
                            используют технологию, известную как компиляция Just-In-Time (JIT), которая компилирует
                            JavaScript в исполняемый байт-код непосредственно перед его запуском.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment97">Является ли JavaScript языком, чувствительным к регистру?</h4>

                    <div>
                        <p>Да, JavaScript — язык, чувствительный к регистру. Ключевые слова языка, переменные, имена
                            функций
                            и
                            объектов, а также любые другие идентификаторы всегда должны вводиться с использованием
                            заглавных
                            букв.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment98">Есть ли какая-либо связь между Java и JavaScript?</h4>

                    <div>
                        <p>Нет, это совершенно два разных языка программирования и не имеют друг с другом
                            ничего общего. Но оба они являются языками объектно-ориентированного программирования и,
                            как и многие другие языки, имеют схожий синтаксис для основных функций (if, else, for,
                            switch,
                            break, continue и т. д.).
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment99">Что такое события</h4>

                    <div>
                        <p>События — это «вещи», которые происходят с элементами HTML. Когда JavaScript используется на
                            страницах
                            HTML, JavaScript может реагировать на эти события. Вот некоторые примеры событий HTML:
                        </p>

                        <ol>
                            <li>Веб-страница завершила загрузку</li>
                            <li>Поле ввода изменено</li>
                            <li>Кнопка была нажата</li>
                        </ol>

                        <p>Опишем поведение события клика для элемента кнопки:</p>

                        <pre>
&lt;!doctype html&gt;
&lt;html&gt;
 &lt;head&gt;
   &lt;script&gt;
     function greeting() {
         alert('Hello! Good morning');
     }
   &lt;/script&gt;
 &lt;/head&gt;
 &lt;body&gt;
   &lt;button type="button" onclick="greeting()"&gt;Click me&lt;/button&gt;
 &lt;/body&gt;
&lt;/html&gt;
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment100">Кто создал JavaScript</h4>

                    <div>
                        <p>JavaScript был создан Бренданом Эйхом в 1995 году, когда он работал в Netscape
                            Communications.
                            Первоначально он был разработан под названием Mocha, но позже язык получил официальное
                            название
                            LiveScript, когда он впервые появился в бета-версиях Netscape.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment101">Для чего используется метод preventDefault()</h4>

                    <div>
                        <p>Метод PreventDefault() отменяет событие, если оно может быть отменено. Это
                            означает,
                            что действие или
                            поведение по умолчанию, принадлежащее событию, не произойдет. Например, некоторые
                            распространенные
                            варианты использования — запретить отправку формы при нажатии кнопки отправки и запретить
                            открытие
                            URL-адреса страницы при нажатии на гиперссылку.
                        </p>

                        <pre>
document
    .getElementById("link")
    .addEventListener("click", function (event) {
        event.preventDefault();
    });
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment102">Для чего используется метод stopPropagation</h4>

                    <div>
                        <p>Метод stopPropagation используется для предотвращения возникновения события в цепочке
                            событий.
                            Например, приведенные ниже вложенные элементы div с методом stopPropagation предотвращают
                            распространение событий по умолчанию при нажатии на вложенный элемент div (Div1).</p>

                        <pre>
&lt;p&gt;Click DIV1 Element&lt;/p&gt;
&lt;div onclick="secondFunc()"&gt;DIV 2
    &lt;div onclick="firstFunc(event)"&gt;DIV 1&lt;/div&gt;
    &lt;div onclick="thirdFunc(event)"&gt;DIV 3(innered without stopPropagation)&lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
    function firstFunc(event) {
        alert("DIV 1");
        event.stopPropagation();
    }

    function secondFunc() {
        alert("DIV 2");
    }
    function thirdFunc(event){
        alert('DIV 3')
    }
&lt;/script&gt;
                </pre>
                        <p>Click DIV1 Element</p>
                        <div onclick="secondFunc()">DIV 2
                            <div onclick="firstFunc(event)">DIV 1</div>
                            <div onclick="thirdFunc(event)">DIV 3(innered without stopPropagation)</div>
                        </div>

                        <script>
                            function firstFunc(event) {
                                alert("DIV 1");
                                event.stopPropagation();
                            }

                            function secondFunc() {
                                alert("DIV 2");
                            }

                            function thirdFunc() {
                                alert('DIV 3')
                            }
                        </script>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment103">Какие шаги выполняются при использовании return false выражения в
                        обработчиках событий</h4>

                    <div>
                        <p>Оператор return false в обработчиках событий выполняет следующие шаги:</p>

                        <ol>
                            <li>Сначала он останавливает действие или поведение браузера по умолчанию.</li>
                            <li>Это предотвращает распространение события в DOM.</li>
                            <li>Останавливает выполнение обратного вызова и немедленно возвращает результат при
                                вызове.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment104">Что такое BOM (объектная модель браузера)</h4>

                    <div>
                        <p>Объектная модель браузера (BOM) позволяет JavaScript «общаться» с браузером.
                            Он состоит из объектов navigator, history, screen, location и document, которые
                            являются дочерними элементами window. Объектная модель браузера не стандартизирована
                            и может меняться в зависимости от браузера.
                        </p>

                        <div class="smallScreenContainer">
                            <img src="./assets/bom.png" alt="bom">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment105">Для чего используется setTimeout</h4>

                    <div>
                        <p>Метод setTimeout() используется для вызова функции или оценки выражения по истечении
                            указанного
                            количества миллисекунд.
                            Например, давайте зарегистрируем сообщение через 2 секунды, используя метод setTimeout:</p>

                        <pre>
setTimeout(function () {
    console.log("Good morning");
}, 2000);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment106">Для чего используется setInterval</h4>

                    <div>
                        <p>Метод setInterval() используется для вызова функции или оценки выражения через заданные
                            интервалы
                            времени
                            (в миллисекундах). Например, давайте зарегистрируем сообщение через 2 секунды, используя
                            метод
                            setInterval:</p>

                        <pre>
setInterval(function () {
    console.log("Good morning");
}, 2000);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment107">Почему JavaScript считается однопоточным</h4>

                    <div>
                        <p>JavaScript — это однопоточный язык. Потому что спецификация языка не позволяет программисту
                            писать код так,
                            чтобы интерпретатор мог запускать его части параллельно в нескольких потоках или процессах.
                            В то время как такие языки, как Java, Go, C++ позволяют создавать многопоточные и
                            многопроцессные программы.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment108">Что такое делегирование события</h4>

                    <div>
                        <p>Делегирование событий — это метод прослушивания событий, при котором вы делегируете
                            родительский элемент в качестве прослушивателя всех событий, происходящих внутри него.</p>

                        <p>Например, если вы хотите обнаружить изменения полей внутри определенной формы,
                            вы можете использовать технику делегирования событий:</p>

                        <pre>
var form = document.querySelector("#registration-form");

// Listen for changes to fields inside the form
form.addEventListener("input", function (event) {
    // Log the field that was changed
        console.log(event.target);
    },
    false
);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment109">Что такое ECMAScript</h4>

                    <div>
                        <p>ECMAScript — это язык сценариев, лежащий в основе JavaScript. ECMAScript
                            стандартизирован международной
                            организацией по стандартизации ECMA в спецификациях ECMA-262 и ECMA-402. Первая редакция
                            ECMAScript
                            была
                            выпущена в 1997 году.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment110">Что такое JSON</h4>

                    <div>
                        <p>JSON (нотация объектов JavaScript/javaScript object notation) — это облегченный формат,
                            используемый для
                            обмена данными. Он основан на подмножестве языка JavaScript, который используется для
                            построения
                            объектов в
                            JavaScript.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment111">Каковы правила синтаксиса JSON?</h4>

                    <div>
                        <p>Ниже приведен список правил синтаксиса JSON.</p>

                        <ol>
                            <li>Данные находятся в парах имя/значение.</li>
                            <li>Данные разделяются запятыми</li>
                            <li>Фигурные скобки содержат объекты</li>
                            <li>Квадратные скобки содержат массивы</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment112">Какова цель JSON.stringify()</h4>

                    <div>
                        <p>При отправке данных на веб-сервер данные должны быть в строковом формате. Вы
                            можете
                            добиться этого,
                            преобразовав объект JSON в строку с помощью метода stringify():
                        </p>

                        <pre>
let userJSON = { name: "John", age: 31 };
let userString = JSON.stringify(userJSON);
console.log(userString); //"{"name":"John","age":31}"
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment113">Как парсить строку JSON?</h4>

                    <div>
                        <p>При получении данных с веб-сервера данные всегда имеют строковый формат. Но вы
                            можете преобразовать это
                            строковое значение в объект javascript, используя метод parse().
                        </p>

                        <pre>
let userString = '{"name":"John","age":31}';
let userJSON = JSON.parse(userString);
console.log(userJSON); // {name: "John", age: 31}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment114">Для чего нужен JSON</h4>

                    <div>
                        <p>При обмене данными между браузером и сервером данные могут быть только текстовыми. Поскольку
                            JSON
                            — это
                            только текст, его можно легко отправлять на сервер и с него, а также использовать в качестве
                            формата
                            данных на любом языке программирования.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment115">Что такое PWA(Progressive web applications/Прогрессивные
                        веб-приложения)</h4>

                    <div>
                        <p>Прогрессивные веб-приложения (PWA) — это тип мобильных приложений,
                            предоставляемых
                            через Интернет и
                            созданных с использованием распространенных веб-технологий, включая HTML, CSS и JavaScript.
                            Эти
                            PWA
                            развертываются на серверах, доступны через URL-адреса и индексируются поисковыми системами.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment116">Какова цель метода clearTimeout?</h4>

                    <div>

                        <p>Функция clearTimeout() используется в javascript для очистки таймаута,
                            установленного до этого функцией
                            setTimeout(). т. е. возвращаемое значение функции setTimeout() сохраняется в переменной и
                            передается
                            в
                            функцию clearTimeout() для очистки таймера.
                        </p>


                        <p>Например, приведенный ниже метод setTimeout используется для отображения
                            сообщения через 3 секунды. Этот тайм-аут можно очистить с помощью метода clearTimeout().</p>

                        <pre>
var msg;
function greeting() {
    alert('Good morning');
}
function start() {
    msg =setTimeout(greeting, 3000);
}

function stop() {
    clearTimeout(msg);
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment117">Какова цель метода clearInterval</h4>

                    <div>

                        <p>Функция ClearInterval() используется в JavaScript для очистки интервала, установленного
                            функцией
                            setInterval(). т. е. возвращаемое значение, возвращаемое функцией setInterval(), сохраняется
                            в
                            переменной и передается в функцию clearInterval() для очистки интервала.</p>


                        <p>Например, приведенный ниже метод setInterval используется для отображения сообщения
                            каждые 3 секунды. Этот интервал можно очистить методом clearInterval().x</p>

                        <pre>
var msg;
function greeting() {
    alert('Good morning');
}
function start() {
    msg = setInterval(greeting, 3000);
}

function stop() {
    clearInterval(msg);
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment118">Как перенаправить на новую страницу в JavaScript</h4>

                    <div>
                        <p>В ванильном JavaScript вы можете перенаправить на новую страницу, используя
                            свойство
                            location объекта window. Синтаксис будет следующим:
                        </p>

                        <pre>
function redirect() {
    window.location.href = "newPage.html";
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment119">Как проверить, содержит ли строка подстроку</h4>

                    <div>

                        <p>Существует 3 возможных способа проверить, содержит ли строка подстроку или нет:</p>

                        <ol>
                            <li>
                                Использование includes: ES6 предоставил метод String.prototype.includes
                                для проверки того, что строка содержит подстроку:
                                <pre>
let mainString = "hello",
let subString = "hell";
mainString.includes(subString);
                        </pre>
                            </li>
                            <li>
                                Использование indexOf: в среде ES5 или более ранней версии вы можете использовать
                                String.prototype.indexOf, который возвращает индекс подстроки. Если значение индекса не
                                равно -1, это означает, что подстрока существует в основной строке.
                                <pre>
let mainString = "hello",
let subString = "hell";
mainString.indexOf(subString) !== -1;
                        </pre>
                            </li>
                            <li>
                                Использование RegEx: расширенное решение использует метод проверки регулярных выражений
                                (RegExp.test),
                                который позволяет проводить тестирование регулярных выражений.
                                <pre>
let mainString = "hello",
let regex = /hell/;
regex.test(mainString);
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment120">Как проверить электронную почту в JavaScript</h4>

                    <div>

                        <p>Вы можете проверить электронную почту в JavaScript, используя регулярные выражения.
                            Рекомендуется
                            выполнять проверки на стороне сервера, а не на стороне клиента. Потому что JavaScript можно
                            отключить на стороне клиента.</p>

                        <pre>
function validateEmail(email) {
    let re =
        /^(([^&lt;&gt;()\[\]\\.,;:\s@"]+(\.[^&lt;&gt;()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    return re.test(String(email).toLowerCase());
}
                </pre>

                        <p>Приведенное выше регулярное выражение принимает символы Юникода.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment121">Как получить текущий URL с помощью JavaScript</h4>

                    <div>
                        <p>Вы можете использовать выражение window.location.href для получения текущего URL-адреса, а
                            также
                            использовать то же выражение для обновления URL-адреса. Вы также можете использовать
                            document.URL только для чтения, но у этого решения есть проблемы в FF.
                        </p>

                        <pre>console.log("location.href", window.location.href); // Returns full URL</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment122">Каковы различные свойства URL объекта location?</h4>

                    <div>
                        <p>Приведенные ниже свойства объекта Location можно использовать для доступа к
                            компонентам URL-адреса страницы:</p>

                        <ol>
                            <li>href - весь URL-адрес</li>
                            <li>protocol - протокол URL-адреса.</li>
                            <li>host - имя хоста и порт URL-адреса.</li>
                            <li>hostname - имя хоста URL-адреса.</li>
                            <li>port - номер порта в URL-адресе.</li>
                            <li>pathname — путь к URL-адресу.</li>
                            <li>search - часть запроса URL-адреса.</li>
                            <li>hash - якорная часть URL-адреса.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment123">Как получить значения строки запроса в JavaScript</h4>

                    <div>
                        <p>Вы можете использовать URLSearchParams для получения значений строки запроса в JavaScript.
                            Давайте посмотрим пример получения значения кода клиента из строки запроса URL:</p>

                        <pre>
const urlParams = new URLSearchParams(window.location.search);
const clientCode = urlParams.get("clientCode");
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment124">Как проверить, существует ли ключ в объекте</h4>

                    <div>
                        <p>Проверить, существует ли ключ в объекте или нет, можно тремя способами:</p>

                        <ol>
                            <li>
                                Использование оператора in: вы можете использовать оператор in
                                независимо от того, существует ли ключ в объекте или нет:
                                <pre>"key" in obj;</pre>
                            </li>
                            <li>
                                и если вы хотите проверить, не существует ли ключ, не забудьте
                                использовать круглые скобки:
                                <pre>!("key" in obj);</pre>
                            </li>
                            <li>
                                Использование метода hasOwnProperty: вы можете использовать hasOwnProperty
                                для проверки свойств экземпляра объекта (а не унаследованных свойств):
                                <pre>obj.hasOwnProperty("key"); // true</pre>
                            </li>
                            <li>
                                Использование сравнения undefined: если вы получаете доступ к несуществующему свойству
                                объекта, результат не определен. Давайте сравним свойства с undefined, чтобы определить
                                существование свойства.
                                <pre>
const user = {
    name: "John",
};

console.log(user.name !== undefined); // true
console.log(user.nickName !== undefined); // false
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment125">Как вы перебираете или перечисляете объект javascript</h4>

                    <div>
                        <p>Вы можете использовать цикл for-in для перебора объекта javascript. Вы также можете
                            убедиться,
                            что полученный вами ключ является реальным свойством объекта, а не получен из прототипа,
                            используя
                            метод hasOwnProperty.
                        </p>

                        <pre>
var object = {
    k1: "value1",
    k2: "value2",
    k3: "value3",
};

for (var key in object) {
    if (object.hasOwnProperty(key)) {
      console.log(key + " -> " + object[key]); // k1 -> value1 ...
    }
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment126">Как проверить пустой объект</h4>

                    <div>
                        <p>Существуют разные решения на основе версий ECMAScript:</p>

                        <ol>
                            <li>
                                Использование Object.entries() (ECMA 7+): вы можете использовать Object.entries() вместе
                                с
                                типом конструктора.
                                <pre>Object.entries(obj).length === 0 && obj.constructor === Object; // Since date object length is 0, you need to check constructor check as well</pre>
                            </li>
                            <li>
                                Использование Object.keys() (ECMA 5+): вы можете использовать Object.keys() вместе с
                                типом
                                конструктора.
                                <pre>Object.keys(obj).length === 0 && obj.constructor === Object; // Since date object length is 0, you need to check constructor check as well</pre>
                            </li>
                            <li>
                                Использование цикла for-in с hasOwnProperty (до ECMA 5): вы можете использовать цикл
                                for-in
                                вместе с hasOwnProperty.
                                <pre>
function isEmpty(obj) {
    for (const prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        return false;
      }
    }

    return JSON.stringify(obj) === JSON.stringify({});
}
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment127">Что такое объект arguments</h4>

                    <div>
                        <p>Объект arguments — это объект типа Array, доступный внутри функций, который содержит значения
                            аргументов, переданных этой функции. Например, давайте посмотрим, как использовать объект
                            аргументов внутри функции sum:</p>

                        <pre>
function sum() {
    let total = 0;
    for (let i = 0, len = arguments.length; i &lt; len; ++i) {
      total += arguments[i];
    }
    return total;
}

sum(1, 2, 3); // returns 6
                </pre>

                        <p>Примечание: Вы не можете применять методы массива к объекту аргументов. Но вы
                            можете преобразовать в обычный массив, как показано ниже.</p>

                        <pre>const argsArray = Array.prototype.slice.call(arguments);</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment128">Как сделать первую букву строки заглавной?</h4>

                    <div>
                        <p>Вы можете создать функцию, которая использует цепочку строковых методов, таких как charAt,
                            toUpperCase и методы среза, для создания строки с первой буквой в верхнем регистре.
                        </p>

                        <pre>
function capitalizeFirstLetter(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment129">Каковы плюсы и минусы цикла for?</h4>

                    <div>
                        <p>Цикл for — это часто используемый синтаксис итерации в JavaScript. У него есть как плюсы, так
                            и
                            минусы:</p>

                        <p>Pros(+):</p>
                        <ol>
                            <li>Работает в любой среде</li>
                            <li>Вы можете использовать операторы управления потоком break и continue.</li>
                        </ol>
                        <p>Cons(-):</p>
                        <ol>
                            <li>Слишком многословно</li>
                            <li>Императивный подход</li>
                            <li>Вы можете столкнуться с отдельными ошибками</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment130">Как отобразить текущую дату в JavaScript</h4>

                    <div>
                        <p>Вы можете использовать new Date() для создания нового объекта Date, содержащего текущую
                            дату и время. Например, давайте отобразим текущую дату в формате мм/дд/гггг.</p>

                        <pre>
const todayDate = new Date();
const dd = String(todayDate.getDate()).padStart(2, "0");
const mm = String(todayDate.getMonth() + 1).padStart(2, "0"); //January is 0!
const yyyy = todayDate.getFullYear();

const today = `${mm} ${dd} ${yyyy}`;
console.log(today); //document.write(today);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment131">Как сравнить два объекта Date</h4>

                    <div>
                        <p>Вам нужно использовать метод date.getTime() для сравнения значений даты вместо
                            прямого сравнения, тк в переменных находятся ссылки на объекты дат</p>

                        <pre>
const d1 = new Date();
const d2 = new Date(d1);
console.log(d1.getTime() === d2.getTime()); //True
console.log(d1 === d2); // False
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment132">Как проверить, начинается ли строка с искомой строки</h4>

                    <div>
                        <p>Вы можете использовать метод String.prototype.startsWith() ECMAScript 6, чтобы
                            проверить, начинается ли строка с искомой строки или нет. Давайте посмотрим
                            пример, чтобы увидеть это использование:</p>

                        <pre>
"Good morning".startsWith("Good"); // true
"Good morning".startsWith("morning"); // false
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment133">Как обрезать строку в JavaScript</h4>

                    <div>
                        <p>В JavaScript предусмотрен метод обрезки для типов строк, позволяющий обрезать
                            любые пробелы, присутствующие в начале или конце строки.</p>

                        <pre>"  Hello World   ".trim(); //Hello World</pre>

                        <p>Если ваш браузер (&lt; IE9) не поддерживает этот метод, вы можете использовать
                            приведенный ниже полифилл.</p>

                        <pre>
if (!String.prototype.trim) {
    (function () {
        // Make sure we trim BOM and NBSP
        let rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        String.prototype.trim = function () {
            return this.replace(rtrim, "");
        };
    })();
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment134">Как добавить пару ключ-значение в JavaScript</h4>

                    <div>
                        <p>Существует два возможных решения для добавления новых свойств к объекту.
                            Давайте возьмем простой объект, чтобы объяснить эти решения.</p>

                        <pre>
const object = {
    key1: value1,
    key2: value2,
};
                </pre>

                        <ol>
                            <li>
                                Использование точечной записи: это решение полезно, если вы знаете имя свойства:

                                <pre>object.key3 = "value3";</pre>
                            </li>
                            <li>

                                <div>Использование квадратных скобок. Это решение полезно, когда имя
                                    свойства
                                    определяется динамически:
                                </div>
                                <pre>object["key3"] = "value3";</pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment135">Является ли обозначение !-- специальным оператором?</h4>

                    <div>
                        <p>Нет, это не специальный оператор. Но это комбинация двух стандартных
                            операторов друг за другом:</p>

                        <ol>
                            <li>

                                <div>Логический оператор нет (!)</div>
                            </li>
                            <li>

                                <div>Декремент (--)</div>
                            </li>
                        </ol>

                        <p>Сначала значение уменьшается на единицу, а затем проверяется, равно ли оно
                            нулю или нет, для определения истинного/ложного значения.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment136">Как присвоить переменным значения по умолчанию</h4>

                    <div>
                        <p>Вы можете использовать логический оператор или || в выражении присваивания,
                            чтобы указать значение по умолчанию. Синтаксис выглядит следующим образом:</p>

                        <pre>let a = b || c;</pre>

                        <p>Согласно приведенному выше выражению, переменная 'a' получит значение 'c', только если 'b'
                            имеет ложное значение (если оно равно null, false, undefined, 0, пустая строка или NaN),
                            в противном случае 'a' получит значение значение 'b'.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment137">Как определить многострочные строки</h4>

                    <div>
                        <p>Вы можете определить многострочные строковые литералы, используя символ '\',
                            за которым следует признак конца строки.</p>

                        <pre>
let str =
    "This is a \
very lengthy \
sentence!";
                </pre>

                        <p>Но если после символа '\' стоит пробел, код будет выглядеть точно так же, но
                            выдаст SyntaxError.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment138">Что такое модель оболочки приложения</h4>

                    <div>
                        <p>Архитектура оболочки приложения — это один из способов создания прогрессивного
                            веб-приложения,
                            которое надежно и мгновенно загружается на экранах ваших пользователей, подобно тому,
                            что вы видите в собственных приложениях. Это полезно для быстрого вывода исходного
                            HTML-кода на экран без подключения к сети.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment139">Можем ли мы определить свойства для функций</h4>

                    <div>
                        <p>Да, мы можем определять свойства функций, поскольку функции также являются объектами.</p>

                        <pre>
const fn = function (x) {
    //Function code goes here
};

fn.userName = "John"; //fn.name -> 'fn'

fn.profile = function (y) {
    //Profile code goes here
};
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment140">Как найти количество параметров, ожидаемых функцией?</h4>

                    <div>
                        <p>Вы можете использовать синтаксис function.length, чтобы найти количество параметров,
                            ожидаемых
                            функцией.
                            Давайте возьмем пример функции sum для вычисления суммы чисел:</p>

                        <pre>
function sum(num1, num2, num3, num4) {
    return num1 + num2 + num3 + num4;
}
sum.length; // 4 is the number of parameters expected.
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment141">Что такое полифил</h4>

                    <div>
                        <p>Полифил — это фрагмент JS-кода, используемый для обеспечения современных функций в старых
                            браузерах,
                            которые не поддерживают его изначально. Например, полифил подключаемого модуля Silverlight
                            можно
                            использовать для имитации функциональности элемента HTML Canvas в Microsoft Internet
                            Explorer
                            7.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment142">Что такое операторы break и continue</h4>

                    <div>
                        <p>Оператор Break используется для «выхода» из цикла. т. е. он разрывает цикл и продолжает
                            выполнение кода после цикла.</p>

                        <pre>
for (i = 0; i &lt; 10; i++) {
    if (i === 5) {
      break;
    }
    text += "Number: " + i + "&lt;br&gt;";
}
                </pre>

                        <p>Оператор continue используется для «перепрыгивания» одной итерации цикла. т. е. он прерывает
                            одну
                            итерацию (в цикле), если возникает указанное условие, и продолжает следующую итерацию в
                            цикле.</p>

                        <pre>
for (i = 0; i &lt; 10; i++) {
    if (i === 5) {
      continue;
    }
    text += "Number: " + i + "&lt;br&gt;";
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment143">Что такое js-метки</h4>

                    <div>
                        <p>JS метка позволяет нам называть циклы и блоки в JavaScript. Затем мы можем
                            использовать эти метки, чтобы позже вернуться к коду. Например,
                            приведенный ниже код с метками позволяет избежать печати чисел, если они одинаковы.</p>

                        <pre>
let i, j;

loop1: for (i = 0; i &lt; 3; i++) {
    loop2: for (j = 0; j &lt; 3; j++) {
      if (i === j) {
        continue loop1;
      }
      console.log("i = " + i + ", j = " + j);
    }
}

// Output is:
//   "i = 1, j = 0"
//   "i = 2, j = 0"
//   "i = 2, j = 1"
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment144">Каковы преимущества размещения объявлений вверху?</h4>

                    <div>
                        <p>Рекомендуется хранить все объявления в начале каждого скрипта или функции.
                            Преимущества этого заключаются в том:</p>

                        <ol>
                            <li>Получается более чистый код</li>
                            <li>Предоставляется единое место для поиска локальных переменных.</li>
                            <li>Легко избежать нежелательных глобальных переменных</li>
                            <li>Снижается вероятность нежелательных повторных деклараций.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment145">Каковы преимущества инициализации переменных</h4>

                    <div>
                        <p>Рекомендуется инициализировать переменные из-за следующих преимуществ:</p>

                        <ol>
                            <li>Получается более чистый код</li>
                            <li>Предоставляется единое место для инициализации переменных.</li>
                            <li>Избегаются undefined значения в коде</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment146">Каковы рекомендации по созданию нового объекта</h4>

                    <div>
                        <p>Рекомендуется избегать создания новых объектов с помощью new Object(). Вместо
                            этого вы можете инициализировать значения на основе их типа для создания объектов.
                        </p>

                        <ol>
                            <li>Назначьте {} вместо new Object()</li>
                            <li>Назначьте "" вместо new String()</li>
                            <li>Назначьте 0 вместо new Number()</li>
                            <li>Назначьте false вместо new Boolean()</li>
                            <li>Назначьте [] вместо new Array()</li>
                            <li>Назначьте /()/ вместо new RegExp().</li>
                            <li>Назначьте function (){} вместо new Function()</li>
                        </ol>

                        <p>Вы можете определить их в качестве примера:</p>

                        <pre>
let v1 = {};
let v2 = "";
let v3 = 0;
let v4 = false;
let v5 = [];
let v6 = /()/;
let v7 = function () {};
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment147">Как вы обозначаете массивы JSON</h4>

                    <div>
                        <p>Массивы JSON записываются в квадратных скобках, а массивы содержат объекты JavaScript.
                            Например, массив пользователей JSON будет выглядеть следующим образом:</p>

                        <pre>
"users":[
    {"firstName":"John", "lastName":"Abrahm"},
    {"firstName":"Anna", "lastName":"Smith"},
    {"firstName":"Shane", "lastName":"Warn"}
]
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment148">Как генерировать случайные целые числа</h4>

                    <div>
                        <p>Вы можете использовать Math.random() с Math.floor() для возврата случайных целых чисел.
                            Например,
                            если
                            вы хотите генерировать случайные целые числа от 1 до 10, коэффициент умножения должен быть
                            10.</p>

                        <pre>
Math.floor(Math.random() * 10) + 1; // returns a random integer from 1 to 10
Math.floor(Math.random() * 100) + 1; // returns a random integer from 1 to 100
                </pre>

                        <p>Примечание: Math.random() возвращает случайное число от 0 (включительно) до 1
                            (исключительно).</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment149">Можете ли вы написать функцию случайных целых чисел для печати
                        целых чисел в диапазоне?</h4>

                    <div>
                        <p>Да, вы можете создать правильную генерирующую рандомное число функцию, которая
                            будет возвращать случайное число между минимальным и максимальным значением (оба
                            включены)</p>

                        <pre>
function randomInteger(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
randomInteger(1, 100); // returns a random integer from 1 to 100
randomInteger(1, 1000); // returns a random integer from 1 to 1000
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment150">Что такое встряхивание дерева(tree shaking)</h4>

                    <div>
                        <p>Встряхивание дерева — это форма устранения мертвого кода. Это означает, что
                            неиспользуемые модули не будут включены в пакет во время процесса сборки, и для этого он
                            полагается
                            на статическую структуру синтаксиса модуля ES2015 (т. е. импорт и экспорт). Первоначально
                            это
                            было
                            популяризировано с помощью накопительного пакета модулей ES2015.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment151">Для чего нужно встряхивание дерева</h4>

                    <div>
                        <p>Tree Shaking может значительно уменьшить размер кода в любом приложении. т. е. чем меньше
                            кода мы
                            отправим по сети, тем более производительным будет приложение. Например, если мы просто
                            хотим
                            создать
                            приложение «Hello World» с использованием фреймворков SPA, это займет около нескольких МБ,
                            но
                            встряхивание дерева может уменьшить размер до нескольких сотен КБ. Встряхивание дерева
                            реализовано в
                            сборщиках Rollup и Webpack.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment152">Рекомендуется ли использовать eval</h4>

                    <div>
                        <p>Нет, он позволяет запускать произвольный код, что вызывает проблемы с безопасностью.
                            Как мы знаем, функция eval() используется для запуска текста как кода.
                            В большинстве случаев необходимости в его использовании нет.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment153">Что такое регулярное выражение</h4>

                    <div>
                        <p>Регулярное выражение — это последовательность символов, образующая шаблон поиска.
                            Вы можете использовать этот шаблон поиска для поиска данных в тексте.
                            Их можно использовать для выполнения всех типов операций текстового поиска и замены текста.
                            Давайте теперь посмотрим на формат синтаксиса:
                        </p>

                        <pre>/pattern/modifiers;</pre>

                        <p>Например, регулярное выражение или шаблон поиска с именем пользователя без учета регистра
                            будет
                            выглядеть так:</p>

                        <pre>/John/i;</pre>

                        <p>Подробнее <a
                                href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Regular_expressions"
                                target="_blank">тут.</a></p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment154">Какие строковые методы доступны в регулярном выражении</h4>

                    <div>
                        <p>Регулярные выражения имеют два строковых метода: search() и replace(). Метод
                            search() использует выражение для поиска совпадения и возвращает позицию совпадения.</p>

                        <pre>
let msg = "Hello John";
let n = msg.search(/John/i); // 6
                </pre>

                        <p>Метод replace() используется для возврата измененной строки, в которой заменен шаблон.</p>

                        <pre>
let msg = "Hello John";
let n = msg.replace(/John/i, "Buttler"); // Hello Buttler
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment155">Что такое модификаторы в регулярном выражении</h4>

                    <div>
                        <p>Модификаторы можно использовать для выполнения регистронезависимого и
                            глобального поиска. Давайте перечислим некоторые модификаторы:</p>

                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>Модификатор</th>
                                <th>Описание</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>i</td>
                                <td>Выполнить сопоставление без учета регистра</td>
                            </tr>
                            <tr>
                                <td>g</td>
                                <td>Выполните глобальное сопоставление, а не останавливайтесь на первом совпадении.</td>
                            </tr>
                            <tr>
                                <td>m</td>
                                <td>Выполнить многострочное сопоставление</td>
                            </tr>
                            </tbody>
                        </table>

                        <p>Давайте возьмем пример глобального модификатора:</p>

                        <pre>
let text = "Learn JS one by one";
let pattern = /one/g;
let result = text.match(pattern); // one,one
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment156">Что такое шаблоны регулярных выражений</h4>

                    <div>
                        <p>Регулярные выражения предоставляют группу шаблонов для сопоставления символов. В основном они
                            делятся на 3 типа:</p>

                        <ol>
                            <li>
                                Скобки: они используются для поиска диапазона символов. Например, ниже приведены
                                некоторые
                                варианты использования:

                                <ol>
                                    <li>[abc]: используется для поиска любого символа в скобках (a,b,c).</li>
                                    <li>[0-9]: используется для поиска любой цифры в скобках.</li>
                                    <li>(a|b): используется для поиска любой альтернативы, разделенной |</li>
                                </ol>
                            </li>
                            <li>Метасимволы: это символы, имеющие особое значение. Например, ниже приведены некоторые
                                варианты использования:

                                <ol>
                                    <li>\d: используется для поиска цифры.</li>
                                    <li>\s: используется для поиска символа пробела.</li>
                                    <li>\b: используется для поиска совпадения в начале или конце слова.</li>
                                </ol>
                            </li>
                            <li>Квантификаторы: они полезны для определения количества. Например, ниже приведены
                                некоторые
                                варианты использования:

                                <ol>
                                    <li>n+: используется для поиска совпадений для любой строки, содержащей хотя бы один
                                        n.
                                    </li>
                                    <li>n*: используется для поиска совпадений для любой строки, которая содержит ноль
                                        или
                                        более вхождений n.
                                    </li>
                                    <li>n?: используется для поиска совпадений для любой строки, которая содержит ноль
                                        или
                                        одно вхождение n.
                                    </li>
                                </ol>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment157">Что такое объект RegExp</h4>

                    <div>
                        <p>Облярного выражения с предопределенными свойствами и
                            методами. Давайте посмотрим простое использование объекта RegExp:
                        </p>

                        <pre>
let regexp = new RegExp("\\w+");
console.log(regexp);
// expected output: /\w+/
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment158">Как искать строку по шаблону</h4>

                    <div>
                        <p>Вы можете использовать метод регулярного выражения test(), чтобы найти строку
                            по шаблону и вернуть true или false в зависимости от результата.
                        </p>

                        <pre>
let pattern = /you/;
console.log(pattern.test("How are you?")); //true
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment159">Какова цель метода exec</h4>

                    <div>
                        <p>Цель метода exec() аналогична методу test(), но он выполняет поиск совпадения в указанной
                            строке
                            и возвращает массив результатов или значение null вместо возврата true/false.</p>

                        <pre>
let pattern = /you/;
console.log(pattern.exec("How are you?")); //["you", index: 8, input: "How are you?", groups: undefined]
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment160">Как изменить стиль HTML-элемента</h4>

                    <div>
                        <p>Вы можете изменить встроенный стиль или имя класса элемента HTML, используя
                            JavaScript.</p>

                        <ol>
                            <li>Использование свойства style: Вы можете изменить встроенный стиль, используя свойство
                                style:

                                <pre>document.getElementById("title").style.fontSize = "30px";</pre>
                            </li>
                            <li>
                                Использование свойства ClassName: класс элемента легко изменить,
                                используя свойство className:
                                <pre>document.getElementById("title").className = "custom-title";</pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment161">Каким будет результат 1+2+'3'</h4>

                    <div>
                        <p>Выходные данные будут 33. Поскольку 1 и 2 являются числовыми значениями,
                            результатом
                            первых двух цифр
                            будет числовое значение 3. Следующая цифра является значением строкового типа, поскольку в
                            результате
                            сложения числового значения 3 и Значение строкового типа 3 будет просто значением
                            конкатенации
                            33.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment162">Что такое оператор debugger</h4>

                    <div>
                        <p>Оператор debugger вызывает любые доступные функции отладки, например установку
                            брейкпоинта. Если
                            функции отладки недоступны, этот оператор не имеет никакого эффекта. Например, в приведенную
                            ниже
                            функцию был вставлен оператор отладчика. Таким образом, выполнение приостанавливается в
                            операторе
                            отладчика, как брейкпоинт в исходном коде сценария.
                        </p>

                        <pre>
function getProfile() {
    // code goes here
    debugger;
    // code goes here
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment163">Какова цель точек останова(брейкпоинтов) при отладке</h4>

                    <div>
                        <p>Вы можете установить точки останова(брейкпоинты) в коде JavaScript после
                            выполнения
                            оператора отладчика и появления
                            всплывающего окна отладчика. В каждой точке останова выполнение javascript прекращается и вы
                            можете
                            проверить значения JavaScript. После проверки значений вы можете возобновить выполнение кода
                            с
                            помощью
                            кнопки воспроизведения.
                        </p>
                    </div>
                </section>


                <section>
                    <h4 id="JSbasicsForEmployment164">Могу ли я использовать зарезервированные слова в качестве
                        идентификаторов</h4>

                    <div>
                        <p>Нет, вы не можете использовать зарезервированные слова в качестве переменных,
                            меток, имен объектов или функций. Давайте посмотрим один простой пример:</p>

                        <pre>let else = "hello"; // Uncaught SyntaxError: Unexpected token else</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment165">Как определить мобильный браузер</h4>

                    <div>
                        <p>Вы можете использовать регулярное выражение, которое возвращает значение true или false
                            в зависимости от того, просматривает ли пользователь мобильный телефон или нет.</p>

                        <pre>
window.mobilecheck = function () {
    let mobileCheck = false;
    (function (a) {
      if (
        /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
          a
        ) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
          a.substr(0, 4)
        )
      )
        mobileCheck = true;
    })(navigator.userAgent || navigator.vendor || window.opera);
    return mobileCheck;
};
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment166">Как определить мобильный браузер без регулярного выражения</h4>

                    <div>
                        <p>Вы можете обнаружить мобильные браузеры, просто просмотрев список устройств и
                            проверив, соответствует
                            ли чему-нибудь пользовательский агент. Это альтернативное решение для использования RegExp:
                        </p>

                        <pre>
function detectmob() {
    if (
      navigator.userAgent.match(/Android/i) ||
      navigator.userAgent.match(/webOS/i) ||
      navigator.userAgent.match(/iPhone/i) ||
      navigator.userAgent.match(/iPad/i) ||
      navigator.userAgent.match(/iPod/i) ||
      navigator.userAgent.match(/BlackBerry/i) ||
      navigator.userAgent.match(/Windows Phone/i)
    ) {
      return true;
    } else {
      return false;
    }
}
detectmob();
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment167">Как получить ширину и высоту изображения с помощью JS?</h4>

                    <div>
                        <p>Вы можете программно получить изображение и проверить размеры (ширину и высоту) с помощью
                            Javascript.</p>

                        <pre>
let img = new Image();
img.onload = function () {
    console.log(this.width + "x" + this.height);
};
img.src = "http://www.google.com/intl/en_ALL/images/logo.gif";
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment168">Как сделать синхронный HTTP-запрос</h4>

                    <div>
                        <p>Браузеры предоставляют объект XMLHttpRequest, который можно использовать для
                            выполнения синхронных HTTP-запросов из JavaScript.</p>

                        <pre>
function httpGet(URL) {
    let xmlHttpReq = new XMLHttpRequest();
    xmlHttpReq.open("GET", URL, false); // false for synchronous request
    xmlHttpReq.send(null);
    return xmlHttpReq.responseText;
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment169">Как сделать асинхронный HTTP-запрос</h4>

                    <div>
                        <p>Браузеры предоставляют объект XMLHttpRequest, который можно использовать для выполнения
                            асинхронных HTTP-запросов из JavaScript, передав третий параметр как true.</p>

                        <pre>
function httpGetAsync(URL, callback) {
    let xmlHttpReq = new XMLHttpRequest();
    xmlHttpReq.onreadystatechange = function () {
      if (xmlHttpReq.readyState == 4 && xmlHttpReq.status == 200)
        callback(xmlHttpReq.responseText);
    };
    xmlHttpReq.open("GET", URL, true); // true for asynchronous
    xmlHttpReq.send(null);
}
                </pre>

                        <p>Так же можно использовать <a href="#fetchApi">fetch</a></p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment170">Как преобразовать дату в другой часовой пояс в JavaScript</h4>

                    <div>
                        <p>Вы можете использовать метод toLocaleString() для преобразования дат из одного
                            часового пояса в другой. Например, давайте преобразуем текущую дату в часовой пояс
                            британского английского, как показано ниже:</p>

                        <pre>console.log(event.toLocaleString("en-GB", { timeZone: "UTC" })); //29/06/2019, 09:56:00</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment171">Какие свойства используются для получения размера окна</h4>

                    <div>
                        <p>Вы можете использовать свойства InsideWidth, InternalHeight, clientWidth, clientHeight окон,
                            элементов
                            документа и объектов тела документа, чтобы определить размер окна. Давайте воспользуемся
                            комбинацией
                            этих свойств для расчета размера окна или документа.</p>

                        <pre>
let width =
    window.innerWidth ||
    document.documentElement.clientWidth ||
    document.body.clientWidth;

let height =
    window.innerHeight ||
    document.documentElement.clientHeight ||
    document.body.clientHeight;
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment172">Что такое условный(тернарный) оператор в JavaScript</h4>

                    <div>
                        <p>Условный (тернарный) оператор — единственный оператор JavaScript, который
                            принимает три операнда и служит сокращением для операторов if.</p>

                        <pre>
let isAuthenticated = false;
console.log(
    isAuthenticated ? "Hello, welcome" : "Sorry, you are not authenticated"
); //Sorry, you are not authenticated
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment173">Можете ли вы применить цепочку к условному оператору?</h4>

                    <div>
                        <p>Да, вы можете применять цепочку к условным операторам, аналогично цепочке if…
                            else if… else if… else. Синтаксис будет таким, как показано ниже:
                        </p>

                        <pre>
function traceValue(someParam) {
    return condition1
        ? value1
        : condition2
        ? value2
        : condition3
        ? value3
        : value4;
}

// The above conditional operator is equivalent to:

function traceValue(someParam) {
    if (condition1) {
      return value1;
    } else if (condition2) {
      return value2;
    } else if (condition3) {
      return value3;
    } else {
      return value4;
    }
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment174">Каковы способы выполнения javascript после загрузки страницы?</h4>

                    <div>
                        <p>Вы можете выполнить JavaScript после загрузки страницы разными способами:</p>

                        <ol>
                            <li>window.onload: window.onload = function ...</li>
                            <li>document.onload: document.onload = function ...</li>
                            <li>body onload attribute: &lt;body onload="script();"&gt;</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment175">В чем разница между proto и prototype</h4>

                    <div>
                        <p>Объект __proto__ — это фактический объект, который используется в цепочке
                            поиска для разрешения методов и т. д. Тогда как prototype — это объект, который используется
                            для построения __proto__, когда вы создаете объект с помощью new.</p>

                        <pre>
new Employee().__proto__ === Employee.prototype;
new Employee().prototype === undefined;
                </pre>

                        <p>Есть еще несколько отличий:</p>

                        <div class="tableWrapper">
                            <table class="jsTheoryTable">
                                <thead>
                                <tr>
                                    <th>feature</th>
                                    <th>Prototype</th>
                                    <th>proto</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>

                                        <div>Доступ</div>
                                    </td>
                                    <td>Все конструкторы функций имеют свойство prototype.</td>
                                    <td>Все объекты имеют свойство __proto__.</td>
                                </tr>
                                <tr>
                                    <td>Цель</td>
                                    <td>Используется для уменьшения трат памяти с помощью одинарной копии функции.</td>
                                    <td>Используется в цепочке поиска для разрешения методов, конструкторов и т.д.</td>
                                </tr>
                                <tr>
                                    <td>ECMAScript</td>
                                    <td>Представлено в ES6</td>
                                    <td>Представлено в ES5</td>
                                </tr>
                                <tr>
                                    <td>Применение</td>
                                    <td>Часто используемый</td>
                                    <td>Редко используемый</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment176">Приведите пример, где действительно нужна точка с запятой</h4>

                    <div>
                        <p>Рекомендуется использовать точки с запятой после каждого оператора JavaScript.
                            Например, в приведенном
                            ниже случае во время выполнения выдается ошибка "... is not a function" из-за отсутствия
                            точки с
                            запятой.
                        </p>

                        <pre>
// define a function
let fn = (function () {
    //...
})(
    // semicolon missing at this line

    // then execute some code inside a closure
    function () {
        //...
    }
)();
                </pre>

                        <p>и это будет интерпретировано как:</p>

                        <pre>
let fn = (function () {
    //...
})(function () {
    //...
})();
                </pre>

                        <p>В этом случае мы передаем вторую функцию в качестве аргумента первой функции, а затем
                            пытаемся
                            вызвать
                            результат вызова первой функции как функцию. Следовательно, вторая функция завершится с
                            ошибкой
                            "... is not a function" во время выполнения.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment177">Что такое метод freeze()</h4>

                    <div>
                        <p>Метод Freeze() используется для замораживания объекта. Замораживание объекта
                            не позволяет добавлять к объекту новые свойства, предотвращает удаление и изменение
                            перечисляемости,
                            возможности настройки или записи существующих свойств. т. е. он возвращает переданный
                            объект и не создает замороженную копию.</p>

                        <pre>
const obj = {
    prop: 100,
};

Object.freeze(obj);
obj.prop = 200; // Throws an error in strict mode

console.log(obj.prop); //100
                </pre>

                        <p>Помните, что замораживание применяется только к свойствам верхнего уровня
                            объектов,
                            но не к вложенным
                            объектам. Например, давайте попробуем заморозить объект пользователя, который содержит
                            сведения
                            о
                            занятости в качестве вложенного объекта, и заметим, что данные были изменены.
                        </p>

                        <pre>
const user = {
    name: "John",
    employment: {
      department: "IT",
    },
};

Object.freeze(user);
user.employment.department = "HR";
console.log(user.employment.department); //HR
                </pre>

                        <p>Если переданный аргумент в метод freeze() не является объектом, то это вызовет
                            ошибку TypeError.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment178">В чем суть метода freeze()</h4>

                    <div>
                        <p>Ниже приведены основные преимущества использования метода freeze().</p>

                        <ol>
                            <li>Используется для замораживания объектов и массивов.</li>
                            <li>Используется для того, чтобы сделать объект иммутабельным(неизменяемым).</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment179">Почему мне нужно использовать метод freeze()</h4>

                    <div>
                        <p>В объектно-ориентированной парадигме существующий API содержит определенные
                            элементы, которые не предназначены для расширения, изменения или повторного использования
                            вне
                            их текущего контекста. Следовательно, оно работает как последнее ключевое слово,
                            которое используется в разных языках.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment180">Как определить языковые предпочтения браузера</h4>

                    <div>
                        <p>Вы можете использовать объект navigator для определения языковых предпочтений
                            браузера, как показано ниже:
                        </p>

                        <pre>
let language =
    (navigator.languages && navigator.languages[0]) ||  // Chrome / Firefox
    navigator.language ||                               // All browsers
    navigator.userLanguage;                             // IE &lt;= 10

console.log(language);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment181">Как преобразовать строку в регистр заголовка с помощью
                        JavaScript</h4>

                    <div>
                        <p>Регистр заголовка(Title case) означает, что первая буква каждого слова пишется с заглавной
                            буквы.
                            Вы можете преобразовать строку в регистр заголовка, используя функцию ниже:</p>

                        <pre>
function toTitleCase(str) {
    return str.replace(/\w\S*/g, function (txt) {
      return txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase();
    });
}
toTitleCase("good morning john"); // Good Morning John
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment182">Как обнаружить отключен ли JavaScript на странице</h4>

                    <div>
                        <p>Вы можете использовать тег <code>&lt;noscript&gt;</code>, чтобы определить отключенный или
                            нет
                            JavaScript. Блок кода
                            внутри <code>&lt;noscript&gt;</code> выполняется, когда JavaScript отключен, и обычно
                            используется для
                            отображения
                            альтернативного контента, когда страница генерируется в JavaScript.
                        </p>

                        <pre>
&lt;script type="javascript"&gt;
    // JS related code goes here
&lt;/script&gt;
&lt;noscript&gt;
    &lt;a href="next_page.html?noJS=true"&gt;JavaScript is disabled in the page. Please click Next Page&lt;/a&gt;
&lt;/noscript&gt;
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment183">Какие операторы поддерживаются JavaScript</h4>

                    <div>
                        <p>Оператор способен манипулировать (математическими и логическими вычислениями) определенным
                            значением
                            или операндом. Существуют различные операторы, поддерживаемые JavaScript, как показано
                            ниже:</p>

                        <ol>
                            <li>
                                Арифметические операторы: Включают + (сложение), – (вычитание), * (умножение), /
                                (деление),
                                %
                                (модуль), ++ (инкремент) и –– (декремент).
                            </li>
                            <li>
                                Операторы сравнения: Включают == (Равно), != (Не Равно), === (Равно
                                по типу), &gt; (Больше), &gt;= (Больше или Равно), &lt; (Меньше), &lt;= (Меньше или
                                равно)
                            </li>
                            <li>Логические операторы: Включают && (логическое И), || (логическое ИЛИ), ! (логическое
                                НЕ).
                            </li>
                            <li>
                                Операторы присваивания: включает = (оператор присваивания), += (оператор сложения и
                                присваивания),
                                –= (оператор вычитания и присваивания), *= (умножение и присваивание), /= (деление и
                                присваивание),
                                %= (модули и присваивание). )
                            </li>
                            <li>Тернарные операторы: включают условный (: ?) оператор.</li>
                            <li>Оператор typeof: используется для определения типа переменной. Синтаксис выглядит как
                                "typeof variableName"
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment184">Что такое параметр rest</h4>

                    <div>
                        <p>Параметр Rest — это улучшенный способ обработки параметров функции, который
                            позволяет нам представлять
                            неопределенное количество аргументов в виде массива. Синтаксис будет таким, как показано
                            ниже:
                        </p>

                        <pre>
function f(a, b, ...theArgs) {
    // ...
}
                </pre>

                        <p>Например, давайте возьмем пример суммы для расчета динамического количества параметров:</p>

                        <pre>
function sum(...args) {
    let total = 0;
    for (const i of args) {
        total += i;
    }
    return total;
}

console.log(sum(1, 2)); //3
console.log(sum(1, 2, 3)); //6
console.log(sum(1, 2, 3, 4)); //10
console.log(sum(1, 2, 3, 4, 5)); //15
                </pre>

                        <p>Примечание: Параметр Rest добавлен в ES2015 (ES6).</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment185">Что произойдет, если вы не используете параметр rest в качестве
                        последнего аргумента</h4>

                    <div>
                        <p>Параметр rest должен быть последним аргументом, поскольку его задача — собрать
                            все
                            оставшиеся аргументы
                            в массив. Например, если вы определите функцию, как показано ниже, это не будет иметь
                            никакого
                            смысла и
                            выдаст ошибку.
                        </p>

                        <pre>
function someFunc(a,…b,c){
    //You code goes here
    return;
} //SyntaxError
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment186">Какие побитовые операторы доступны в JavaScript</h4>

                    <div>
                        <p>Ниже приведен список побитовых логических операторов, используемых в
                            JavaScript:</p>

                        <ol>
                            <li>Побитовое И ( & )</li>
                            <li>Побитовое ИЛИ ( | )</li>
                            <li>Побитовое исключающее ИЛИ ( ^ )</li>
                            <li>Побитовое НЕ ( ~ )</li>
                            <li>Левый сдвиг ( &lt;&lt; )</li>
                            <li>Правый сдвиг, переносящий знак ( &gt;&gt; )</li>
                            <li>Правый сдвиг с заполнением нулями ( &gt;&gt;&gt; )</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment187">Что такое spread оператор</h4>

                    <div>
                        <p>Оператор Spread позволяет разворачивать итерации (массивы/объекты/строки) в отдельные
                            аргументы/элементы. Давайте рассмотрим пример, чтобы увидеть это поведение:</p>

                        <pre>
function calculateSum(x, y, z) {
    return x + y + z;
}

const numbers = [1, 2, 3];

console.log(calculateSum(...numbers)); // 6
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment188">Как определить, заморожен объект или нет?</h4>

                    <div>
                        <p>Метод Object.isFrozen() используется для определения того, заморожен объект
                            или нет. Объект замораживается, если все следующие условия выполняются:</p>

                        <ol>
                            <li>Если он не расширяемый.</li>
                            <li>Если все его свойства ненастраиваемые.</li>
                            <li>Если все его свойства данных недоступны для записи.</li>
                        </ol>

                        <p>Синтаксис выглядит следующим образом:</p>

                        <pre>
const object = {
    property: "Welcome JS world",
};
Object.freeze(object);
console.log(Object.isFrozen(object));
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment189">Как определить одинаковы ли два значения или нет используя
                        объект</h4>

                    <div>
                        <p>Метод Object.is() определяет, являются ли два значения одним и тем же
                            значением. Например, использование с различными типами значений будет таким:</p>

                        <pre>
Object.is("hello", "hello"); // true
Object.is(window, window); // true
Object.is([], []); // false
                </pre>

                        <p>Два значения являются одинаковыми, если выполняется одно из следующих
                            условий:</p>

                        <ol>
                            <li>оба undefined</li>
                            <li>оба null</li>
                            <li>оба истинны(true) или оба ложны(false)</li>
                            <li>обе строки одинаковой длины с одинаковыми символами в одном и том же порядке</li>
                            <li>оба одного и того же объекта (означает, что оба объекта имеют одинаковую ссылку)</li>
                            <li>оба числа и оба +0, оба -0, оба NaN, оба ненулевые, и оба не NaN, и оба имеют одинаковое
                                значение.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment190">Какая цель использования метода Object.is()</h4>

                    <div>
                        <p>Некоторые цели из применений метода Object.is:</p>

                        <ol>
                            <li>Используется для сравнения двух строк.</li>
                            <li>Используется для сравнения двух чисел.</li>
                            <li>Используется для сравнения полярности двух чисел.</li>
                            <li>Используется для сравнения двух объектов.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment191">Как скопировать свойства одного объекта в другой?</h4>

                    <div>
                        <p>Вы можете использовать метод Object.assign(), который используется для копирования значений и
                            свойств из одного или нескольких исходных объектов в целевой объект. Он возвращает целевой
                            объект,
                            свойства и значения которого скопированы из исходных объектов. Синтаксис будет таким, как
                            показано ниже:
                        </p>

                        <pre>Object.assign(target, ...sources);</pre>

                        <p>Давайте рассмотрим пример с одним исходным и одним целевым объектом:</p>

                        <pre>
const target = { a: 1, b: 2 };
const source = { b: 3, c: 4 };

const returnedTarget = Object.assign(target, source);

console.log(target); // { a: 1, b: 3, c: 4 }

console.log(returnedTarget); // { a: 1, b: 3, c: 4 }
                </pre>

                        <p>Как видно в приведенном выше коде, существует общее свойство (b) от источника
                            к цели, поэтому его значение было перезаписано.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment192">Какие есть применения метода assign?</h4>

                    <div>
                        <p>Ниже приведены некоторые основные применения метода Object.assign():</p>

                        <ol>
                            <li>Используется для клонирования объекта.</li>
                            <li>Используется для объединения объектов с одинаковыми свойствами.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment193">Что такое объект proxy</h4>

                    <div>
                        <p>Объект Proxy используется для определения пользовательского поведения для фундаментальных
                            операций,
                            таких как поиск свойств, присвоение, перечисление, вызов функций и т. д. Синтаксис будет
                            следующим:
                        </p>

                        <pre>let p = new Proxy(target, handler);</pre>

                        <p>Давайте возьмем пример объекта proxy:</p>

                        <pre>
let handler = {
    get: function (obj, prop) {
      return prop in obj ? obj[prop] : 100;
    },
};

let p = new Proxy({}, handler);
p.a = 10;
p.b = null;

console.log(p.a, p.b); // 10, null
console.log("c" in p, p.c); // false, 100
                </pre>

                        <p>В приведенном выше коде используется обработчик get, который определяет
                            поведение прокси-сервера при выполнении над ним операции.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment194">В чем суть метода seal()</h4>

                    <div>
                        <p>Метод Object.seal() используется для запечатывания объекта, предотвращая добавление к нему
                            новых
                            свойств и отмечая все существующие свойства как ненастраиваемые. Но значения текущих свойств
                            все
                            равно можно изменить, если они доступны для записи. Давайте посмотрим на приведенный ниже
                            пример,
                            чтобы лучше понять метод seal():
                        </p>

                        <pre>
const object = {
    property: "Welcome JS world",
};
Object.seal(object);
object.property = "Welcome to object world";
console.log(Object.isSealed(object)); // true
delete object.property; // You cannot delete when sealed
console.log(object.property); //Welcome to object world
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment195">Каковы применения метода seal()</h4>

                    <div>
                        <p>Ниже приведены основные применения метода Object.seal():</p>

                        <ol>
                            <li>Используется для запечатывания объектов и массивов.</li>
                            <li>Используется для того, чтобы сделать объект иммутабельным(неизменяемым).</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment196">В чем разница между методами freeze() и seal()</h4>

                    <div>
                        <p>Если объект заморожен с помощью метода Object.freeze(), его свойства становятся неизменяемыми
                            и в
                            них
                            невозможно внести изменения, тогда как если объект запечатан с помощью метода Object.seal(),
                            то
                            изменения можно внести в существующие свойства объекта.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment197">Как определить, применен ли к объекту метод seal() или нет</h4>

                    <div>
                        <p>Метод Object.isSealed() используется для определения того, запечатан ли объект
                            или нет. Объект запечатан, если выполняются все приведенные ниже условия:
                        </p>

                        <ol>
                            <li>Если он не расширяемый.</li>
                            <li>Если все его свойства ненастраиваемые.</li>
                            <li>Если свойства неудаляемые (но не обязательно незаписываемые).
                                Давайте посмотрим на это в действии:
                            </li>
                        </ol>

                        <pre>
const object = {
    property: "Hello, Good morning",
};

Object.seal(object); // Using seal() method to seal the object

console.log(Object.isSealed(object)); // checking whether the object is sealed or not
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment198">Как получить перечислимые пары ключей и значений?</h4>

                    <div>
                        <p>Метод Object.entries() используется для возврата массива собственных перечислимых
                            пар свойств [ключ, значение] данного объекта со строковыми ключами в том же порядке, что и в
                            цикле for...in. Давайте посмотрим на функциональность метода object.entries() на примере:
                        </p>

                        <pre>
const object = {
    a: "Good morning",
    b: 100,
};

for (let [key, value] of Object.entries(object)) {
    console.log(`${key}: ${value}`);
    // a: 'Good morning'
    // b: 100
}
                </pre>

                        <p>Примечание: Порядок не гарантируется как это определено(написано) в объекте.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment199">В чем основное различие между методом Object.values и
                        Object.entries?</h4>

                    <div>
                        <p>Поведение метода Object.values() аналогично методу Object.entries(), но он
                            возвращает массив значений вместо пар [ключ, значение].</p>

                        <pre>
const object = {
    a: "Good morning",
    b: 100,
};

for (let value of Object.values(object)) {
    console.log(`${value}`);
    // 'Good morning'
    // 100;
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment200">Как получить список ключей любого объекта</h4>

                    <div>
                        <p>Вы можете использовать метод Object.keys(), который используется для возврата массива имен
                            собственных
                            свойств данного объекта в том же порядке, что и в обычном цикле. Например, вы можете
                            получить
                            ключи
                            пользовательского объекта:
                        </p>

                        <pre>
const user = {
    name: "John",
    gender: "male",
    age: 40,
};

console.log(Object.keys(user)); //['name', 'gender', 'age']
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment201">Как создать объект с прототипом</h4>

                    <div>
                        <p>Метод Object.create() используется для создания нового объекта с указанным
                            объектом-прототипом и
                            свойствами. т. е. он использует существующий объект в качестве прототипа вновь созданного
                            объекта. Он возвращает новый объект с указанным объектом-прототипом и свойствами.
                        </p>

                        <pre>
const user = {
    name: "John",
    printInfo: function () {
        console.log(`My name is ${this.name}.`);
    },
};

const admin = Object.create(user);

admin.name = "Nick"; // Remember that "name" is a property set on "admin" but not on "user" object

admin.printInfo(); // My name is Nick
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment202">Что такое WeakSet</h4>

                    <div>
                        <p>WeakSet используется для хранения коллекции объектов со слабыми ссылками.
                            Синтаксис будет следующим:</p>

                        <pre>new WeakSet([iterable]);</pre>

                        <p>Давайте посмотрим на пример ниже, чтобы объяснить его поведение:</p>

                        <pre>
let ws = new WeakSet();
let user = {};
ws.add(user);
ws.has(user); // true
ws.delete(user); // removes user from the set
ws.has(user); // false, user has been removed
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment203">В чем разница между WeakSet и Set</h4>

                    <div>
                        <p>Основное отличие состоит в том, что ссылки на объекты в Set являются сильными, а ссылки на
                            объекты в
                            WeakSet — слабыми. т. е. объект в WeakSet может быть подвергнут сборке мусора, если на него
                            нет
                            другой ссылки. Другие различия заключаются в следующем:
                        </p>

                        <ol>
                            <li>Наборы могут хранить любое значение, тогда как WeakSets могут хранить только коллекции
                                объектов.
                            </li>
                            <li>WeakSet не имеет свойства size, в отличие от Set.</li>
                            <li>WeakSet не имеет таких методов, как clear, keys, values, entries, forEach.</li>
                            <li>WeakSet не итерируемый</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment204">Перечислите методы, доступные в WeakSet.</h4>

                    <div>
                        <p>Ниже приведен список методов, доступных в WeakSet:</p>

                        <ol>
                            <li>add(value): новый объект добавляется с заданным значением в weakSet.</li>
                            <li>delete(value): удаляет значение из коллекции WeakSet.</li>
                            <li>has(value): возвращает true, если значение присутствует в коллекции WeakSet, в противном
                                случае возвращает false.
                            </li>
                        </ol>

                        <p>Давайте посмотрим функциональность всех вышеперечисленных методов на примере:</p>

                        <pre>
let weakSetObject = new WeakSet();
let firstObject = {};
let secondObject = {};
// add(value)
weakSetObject.add(firstObject);
weakSetObject.add(secondObject);
console.log(weakSetObject.has(firstObject)); //true
weakSetObject.delete(secondObject);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment205">Что такое WeakMap</h4>

                    <div>
                        <p>Объект WeakMap представляет собой коллекцию пар ключ/значение, в которых ключи имеют слабую
                            ссылку.
                            В этом случае ключи должны быть объектами, а значения могут быть произвольными. Синтаксис
                            выглядит
                            следующим образом:</p>

                        <pre>new WeakMap([iterable]);</pre>

                        <p>Давайте посмотрим на пример ниже, чтобы объяснить его поведение:</p>

                        <pre>
let ws = new WeakMap();
let user = {};
ws.set(user);
ws.has(user); // true
ws.delete(user); // removes user from the map
ws.has(user); // false, user has been removed
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment206">В чем разница между WeakMap и Map</h4>

                    <div>
                        <p>Основное отличие состоит в том, что ссылки на ключевые объекты в Map являются сильными, а
                            ссылки
                            на
                            ключевые объекты в WeakMap — слабыми. т. е. ключевой объект в WeakMap может быть подвергнут
                            сборке
                            мусора, если на него нет другой ссылки. Другие различия заключаются в том:</p>

                        <ol>
                            <li>Maps могут хранить ключи любого типа, тогда как WeakMaps могут хранить только коллекции
                                ключей-объектов.
                            </li>
                            <li>WeakMap не имеет свойства size, в отличие от Map.</li>
                            <li>WeakMap не имеет таких методов, как clear, keys, values, entries, forEach.</li>
                            <li>WeakMap не итерируемый.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment207">Перечислите коллекцию методов, доступных для WeakMap.</h4>

                    <div>
                        <p>Ниже приведен список методов, доступных для WeakMap:</p>

                        <ol>
                            <li>set(key, value): устанавливает значение ключа в объекте WeakMap. Возвращает объект
                                WeakMap.
                            </li>
                            <li>delete(key): удаляет любое значение, связанное с ключом.</li>
                            <li>has(key): возвращает логическое значение, подтверждающее, было ли значение связано с
                                ключом
                                в объекте WeakMap или нет.
                            </li>
                            <li>get(key): Возвращает значение, связанное с ключом, или undefined, если его нет.</li>
                        </ol>

                        <p>Давайте посмотрим функциональность всех вышеперечисленных методов на примере:</p>

                        <pre>
let weakMapObject = new WeakMap();
let firstObject = {};
let secondObject = {};
// set(key, value)
weakMapObject.set(firstObject, "John");
weakMapObject.set(secondObject, 100);
console.log(weakMapObject.has(firstObject)); //true
console.log(weakMapObject.get(firstObject)); // John
weakMapObject.delete(secondObject);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment208">Какова цель uneval(устарела)</h4>

                    <div>
                        <p>uneval() — это встроенная функция, которая используется для создания строкового представления
                            исходного
                            кода объекта. Это функция верхнего уровня, не связанная ни с каким объектом. Давайте
                            посмотрим
                            на пример ниже, чтобы узнать больше о его функциональности:</p>

                        <pre>
let a = 1;
uneval(a); // returns a String containing 1
uneval(function user() {}); // returns "(function user(){})"
                </pre>

                        <p>Функция uneval() устарела. Рекомендуется использовать toString() для функций и
                            JSON.toStringify()
                            для других случаев.</p>

                        <pre>
function user() {}
console.log(user.toString()); // returns "(function user(){})"
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment209">Как вы кодируете URL-адрес</h4>

                    <div>
                        <p>Функция encodeURI() используется для кодирования полного URL, который содержит
                            специальные символы, за исключением символов (, / ? : @ & = + $ #).</p>

                        <pre>
let uri = "https://mozilla.org/?x=шеллы";
let encoded = encodeURI(uri);
console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment210">Как декодировать URL</h4>

                    <div>
                        <p>Функция decodeURI() используется для декодирования универсального идентификатора ресурса
                            (URI),
                            ранее созданного функцией encodeURI().</p>

                        <pre>
var uri = "https://mozilla.org/?x=шеллы";
var encoded = encodeURI(uri);
console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
try {
    console.log(decodeURI(encoded)); // "https://mozilla.org/?x=шеллы"
} catch (e) {
    // catches a malformed URI
    console.error(e);
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment211">Как распечатать содержимое веб-страницы</h4>

                    <div>
                        <p>Объект window предоставил метод print(), который используется для печати содержимого текущего
                            окна.
                            Откроется диалоговое окно «Печать», в котором можно выбрать различные параметры печати.
                            Давайте посмотрим на использование метода print на примере:</p>

                        <pre>&lt;input type="button" value="Print" onclick="window.print()"&gt;</pre>
                        <input type="button" value="Print" onclick="window.print()">

                        <p>Примечание: В большинстве браузеров он блокируется, пока открыто диалоговое окно печати.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment212">В чем разница между uneval и eval</h4>

                    <div>
                        <p>Функция uneval возвращает источник данного объекта; тогда как функция eval делает
                            противоположное,
                            оценивая этот исходный код в другой области памяти. Давайте посмотрим пример, чтобы
                            прояснить
                            разницу:</p>

                        <pre>
let msg = uneval(function greeting() {
    return "Hello, Good morning";
});
let greeting = eval(msg);
greeting(); // returns "Hello, Good morning"
                </pre>
                        <p>Uneval - DEPRECATED!!!</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment213">Что такое анонимная функция</h4>

                    <div>
                        <p>Анонимная функция — это функция без имени! Анонимные функции обычно присваиваются имени
                            переменной или
                            используются в качестве функции обратного вызова. Синтаксис будет таким, как показано ниже:
                        </p>

                        <pre>
function (optionalParameters) {
    //do something
}

const myFunction = function(){ //Anonymous function assigned to a variable
    //do something
};

[1, 2, 3].map(function(element){ //Anonymous function used as a callback function
    //do something
});
                </pre>

                        <p>Давайте посмотрим на приведенную выше анонимную функцию на примере:</p>

                        <pre>
let x = function (a, b) {
    return a * b;
};
let z = x(5, 10);
console.log(z); // 50
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment214">Каков порядок приоритета между локальными и глобальными
                        переменными?</h4>

                    <div>
                        <p>Локальная переменная имеет приоритет над глобальной переменной с тем же именем.
                            Давайте посмотрим на это поведение на примере:
                        </p>

                        <pre>
var msg = "Good morning";
function greeting() {
    msg = "Good Evening";
    console.log(msg); // Good Evening
}
greeting();
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment215">Что такое аксессоры JavaScript</h4>

                    <div>
                        <p>ECMAScript 5 представил средства доступа к объектам JavaScript или вычисляемые свойства через
                            геттеры и
                            сеттеры. Getters использует ключевое слово get, тогда как Setters использует ключевое слово
                            set.
                        </p>

                        <pre>
let user = {
    firstName: "John",
    lastName: "Abraham",
    language: "en",
    get lang() {
      return this.language;
    },
    set lang(lang) {
      this.language = lang;
    },
};
console.log(user.lang); // getter access lang as en
user.lang = "fr";
console.log(user.lang); // setter used to set lang as fr
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment216">Как определить свойство в конструкторе объекта</h4>

                    <div>
                        <p>Статический метод Object.defineProperty() используется для определения нового свойства
                            непосредственно
                            объекта или изменения существующего свойства объекта и возвращает объект. Давайте посмотрим
                            пример,
                            чтобы узнать, как определить свойство:
                        </p>

                        <pre>
const newObject = {};

Object.defineProperty(newObject, "newProperty", {
    value: 100,
    writable: false,
});

console.log(newObject.newProperty); // 100

newObject.newProperty = 200; // It throws an error in strict mode due to writable setting
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment217">В чем разница между get и defineProperty</h4>

                    <div>
                        <p>Оба имеют схожие результаты, пока вы не используете классы. Если вы
                            используете get, свойство будет определено в прототипе объекта, тогда как при использовании
                            Object.defineProperty() свойство будет определено в экземпляре, к которому оно
                            применяется.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment218">Каковы преимущества геттеров и сеттеров</h4>

                    <div>
                        <p>Ниже приведен список преимуществ геттеров и сеттеров:</p>

                        <ol>
                            <li>Они обеспечивают более простой синтаксис</li>
                            <li>Они используются для определения вычисляемых свойств или средств доступа в JS.</li>
                            <li>Полезно для обеспечения отношения эквивалентности между свойствами и методами.</li>
                            <li>Они могут обеспечить лучшее качество данных</li>
                            <li>Полезно для скрытых действий с инкапсулированной логикой.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment219">Могу ли я добавить геттеры и сеттеры, используя метод
                        defineProperty?</h4>

                    <div>
                        <p>Да, вы можете использовать метод Object.defineProperty() для добавления геттеров и сеттеров.
                            Например,
                            приведенный ниже объект счетчика использует свойства увеличения, уменьшения, добавления и
                            вычитания.</p>

                        <pre>
let obj = { counter: 0 };

// Define getters
Object.defineProperty(obj, "increment", {
    get: function () {
      this.counter++;
    },
});
Object.defineProperty(obj, "decrement", {
    get: function () {
      this.counter--;
    },
});

// Define setters
Object.defineProperty(obj, "add", {
    set: function (value) {
      this.counter += value;
    },
});
Object.defineProperty(obj, "subtract", {
    set: function (value) {
      this.counter -= value;
    },
});

obj.add = 10;
obj.subtract = 5;
console.log(obj.increment); //6
console.log(obj.decrement); //5
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment220">Какова цель switch-case</h4>

                    <div>
                        <p>Оператор switch case в JavaScript используется для принятия решений. В некоторых случаях
                            использование
                            оператора Switch Case будет более удобным, чем операторов if-else. Синтаксис будет таким,
                            как
                            показано ниже:
                        </p>

                        <pre>
switch (expression) {
    case value1:
        statement1;
        break;
    case value2:
        statement2;
        break;
    .
    .
    case valueN:
        statementN;
        break;
    default:
        statementDefault;
}
                        </pre>

                        <p>Приведенный выше оператор многопутевого ветвления обеспечивает простой способ распределения
                            выполнения различных частей кода в зависимости от значения выражения.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment221">Каковы правила использования switch case?</h4>

                    <div>
                        <p>Ниже приведен список соглашений, на которые следует обратить внимание.</p>

                        <ol>
                            <li>Выражение может иметь числовой или строковый тип.</li>
                            <li>Для выражения не допускаются повторяющиеся значения.</li>
                            <li>Оператор default является необязательным. Если выражение, переданное в переключатель, не
                                соответствует ни одному значению регистра, будет выполнен оператор default.
                            </li>
                            <li>Оператор Break используется внутри переключателя для завершения последовательности
                                операторов.
                            </li>
                            <li>Оператор Break не является обязательным. Но если он опущен, выполнение продолжится до
                                следующего случая.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment222">Что такое примитивные типы данных</h4>

                    <div>
                        <p>Примитивный тип данных — это данные, которые имеют примитивное значение (не имеющее
                            свойств или методов). Существует 7 типов примитивных типов данных:</p>

                        <ol>
                            <li>string</li>
                            <li>number</li>
                            <li>boolean</li>
                            <li>null</li>
                            <li>undefined</li>
                            <li>bigint</li>
                            <li>symbol</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment223">Какие существуют способы доступа к свойствам объекта?</h4>

                    <div>
                        <p>Существует 3 возможных способа доступа к свойству объекта.</p>

                        <ol>
                            <li>
                                Обозначение через точку: точка используется для доступа к свойствам.

                                <pre>objectName.property;</pre>
                            </li>
                            <li>Обозначение квадратных скобок: для доступа к свойствам используются квадратные скобки.

                                <pre>objectName["property"];</pre>
                            </li>
                            <li>
                                Обозначение выражения: используется выражение в квадратных скобках.

                                <pre>objectName[expression];</pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment224">Каковы правила параметров функции</h4>

                    <div>
                        <p>Функции JavaScript следуют приведенным ниже правилам для параметров:</p>

                        <ol>
                            <li>В определениях функций не указаны типы данных для параметров.</li>
                            <li>Не выполняйте проверку типа переданных аргументов.</li>
                            <li>Не проверяйте количество полученных аргументов. т. е. функция ниже следует приведенным
                                выше
                                правилам,
                            </li>
                        </ol>

                        <pre>
function functionName(parameter1, parameter2, parameter3) {
    console.log(parameter1); // 1
}
functionName(1);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment225">Что такое объект error</h4>

                    <div>
                        <p>Объект ошибки — это встроенный объект ошибки, который предоставляет информацию об ошибке при
                            возникновении ошибки. Он имеет два свойства: name и message. Например, приведенная ниже
                            функция
                            регистрирует сведения об ошибках:</p>

                        <pre>
try {
    greeting("Welcome");
} catch (err) {
    console.log(err.name + "&lt;br&gt;" + err.message);
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment226">Когда вы получаете синтаксическую ошибку</h4>

                    <div>
                        <p>SyntaxError выдается, если вы пытаетесь запустить код с синтаксической ошибкой.
                            Например, недостающая кавычка ниже для параметра функции вызывает синтаксическую ошибку.
                        </p>

                        <pre>
try {
    eval("greeting('welcome)"); // Missing ' will produce an error
} catch (err) {
    console.log(err.name);
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment227">Какие есть имена ошибок из объекта error?</h4>

                    <div>
                        <p>Существует 6 различных типов имен ошибок, возвращаемых объектом error:</p>

                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>Error Name</th>
                                <th>Описание</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>EvalError</td>
                                <td>Произошла ошибка в функции eval().</td>
                            </tr>
                            <tr>
                                <td>RangeError</td>
                                <td>Произошла ошибка: число "вне диапазона"</td>
                            </tr>
                            <tr>
                                <td>ReferenceError</td>
                                <td>Ошибка из-за незаконной ссылки</td>
                            </tr>
                            <tr>
                                <td>SyntaxError</td>
                                <td>Ошибка из-за синтаксической ошибки</td>
                            </tr>
                            <tr>
                                <td>TypeError</td>
                                <td>Ошибка из-за ошибки типа</td>
                            </tr>
                            <tr>
                                <td>URIError</td>
                                <td>Ошибка из-за encodeURI()</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment228">Какие существуют операторы обработки ошибок?</h4>

                    <div>
                        <p>Ниже приведен список операторов, используемых при обработке ошибок:</p>

                        <ol>
                            <li>try: этот оператор используется для проверки блока кода на наличие ошибок.</li>
                            <li>catch: этот оператор используется для обработки ошибки</li>
                            <li>throw: этот оператор используется для создания пользовательских ошибок.</li>
                            <li>finally: этот оператор используется для выполнения кода после try и catch независимо от
                                результата.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment229">Какие два типа циклов существуют в JavaScript?</h4>

                    <div>
                        <ol>
                            <li>
                                Циклы с контролируемым входом: в циклах этого типа тестовое условие проверяется перед
                                входом в тело цикла. Например, к этой категории относятся циклы For и While.
                            </li>
                            <li>
                                Циклы с контролируемым выходом: в этом типе цикла тестовое условие проверяется или
                                оценивается в
                                конце тела цикла. т. е. тело цикла выполнится хотя бы один раз, независимо от того,
                                истинно
                                или
                                ложно тестовое условие. Например, к этой категории относится цикл do-while.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment230">Что такое nodejs</h4>

                    <div>
                        <p>Node.js — это серверная платформа, созданная на основе среды выполнения JavaScript Chrome,
                            позволяющая
                            легко создавать быстрые и масштабируемые сетевые приложения. Это основанная на событиях
                            неблокирующая
                            асинхронная среда выполнения ввода-вывода, использующая движок JavaScript V8 от Google и
                            библиотеку libuv.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment231">Что такое Intl объект</h4>

                    <div>
                        <p>Объект Intl — это пространство имен для API интернационализации ECMAScript, который
                            обеспечивает
                            сравнение строк с учетом языка, форматирование чисел, а также форматирование даты и времени.
                            Он
                            обеспечивает доступ к нескольким конструкторам и функциям, чувствительным к языку.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment232">Как выполнить форматирование даты и времени для конкретного
                        языка?</h4>

                    <div>
                        <p>Вы можете использовать объект Intl.DateTimeFormat, который является конструктором для
                            объектов,
                            которые
                            обеспечивают форматирование даты и времени с учетом языка. Давайте посмотрим на это
                            поведение на
                            примере:
                        </p>

                        <pre>
let date = new Date(Date.UTC(2019, 07, 07, 3, 0, 0));
console.log(new Intl.DateTimeFormat("en-GB").format(date)); // 07/08/2019
console.log(new Intl.DateTimeFormat("en-AU").format(date)); // 07/08/2019
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment233">Что такое итератор</h4>

                    <div>
                        <p>Итератор — это объект, который определяет последовательность и возвращаемое значение после ее
                            завершения. Он реализует протокол Iterator с методом next(), который возвращает объект с
                            двумя
                            свойствами: value (следующее значение в последовательности) и Done (что верно, если
                            последнее
                            значение в последовательности было использовано).</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment234">Как работает синхронная итерация</h4>

                    <div>
                        <p>Синхронная итерация была введена в ES6 и работает с приведенным ниже набором компонентов:</p>

                        <p>Iterable(Итерируемый): это объект, который можно перебирать с помощью метода, ключ которого —
                            Symbol.iterator.
                            Iterator(Итератор): это объект, возвращаемый вызовом [Symbol.iterator]() для итерации. Этот
                            объект-итератор
                            оборачивает каждый итерируемый элемент в объект и возвращает его через метод next() один за
                            другим. IteratorResult:
                            это объект, возвращаемый методом next(). Объект содержит два свойства; Свойство value
                            содержит
                            повторяемый элемент,
                            а свойство Done определяет, является ли элемент последним элементом или нет.
                        </p>

                        <p>Давайте продемонстрируем синхронную итерацию с массивом, как показано ниже:</p>

                        <pre>
const iterable = ["one", "two", "three"];
const iterator = iterable[Symbol.iterator]();
console.log(iterator.next()); // { value: 'one', done: false }
console.log(iterator.next()); // { value: 'two', done: false }
console.log(iterator.next()); // { value: 'three', done: false }
console.log(iterator.next()); // { value: 'undefined, done: true }
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment235">Что такое цикл событий</h4>

                    <div>
                        <p>Цикл событий — это процесс, который постоянно отслеживает как стек вызовов, так и очередь
                            событий, а
                            также проверяет, пуст ли стек вызовов. Если стек вызовов пуст и в очереди событий есть
                            ожидающие
                            события, цикл событий удаляет событие из очереди событий и помещает его в стек вызовов. Стек
                            вызовов выполняет событие, и любые дополнительные события, сгенерированные во время
                            выполнения,
                            добавляются в конец очереди событий.
                        </p>

                        <p>Примечание: Цикл событий позволяет Node.js выполнять неблокирующие операции ввода-вывода,
                            даже
                            несмотря на
                            однопоточность JavaScript, по возможности перекладывая операции на ядро системы. Поскольку
                            большинство современных ядер являются многопоточными, они могут обрабатывать несколько
                            операций,
                            выполняемых в фоновом режиме.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment236"> Что такое стек вызовов</h4>

                    <div>
                        <p>Стек вызовов — это структура данных для интерпретаторов JavaScript, позволяющая отслеживать
                            вызовы функций (создает контекст выполнения) в программе. Он имеет два основных
                            действия:</p>

                        <ol>
                            <li>Всякий раз, когда вы вызываете функцию для ее выполнения, вы помещаете ее в стек.</li>
                            <li>Всякий раз, когда выполнение завершается, функция извлекается из стека.</li>
                        </ol>

                        <p>Давайте рассмотрим пример и представление его состояния в формате диаграммы:</p>

                        <pre>
function hungry() {
    eatFruits();
}
function eatFruits() {
    return "I'm eating fruits";
}

// Invoke the `hungry` function
hungry();
                </pre>

                        <p>Приведенный выше код обрабатывается в стеке вызовов, как показано ниже:</p>

                        <ol>
                            <li>Добавьте функцию hungry() в список стека вызовов и выполните код.</li>
                            <li>Добавьте функцию eatFruits() в список стека вызовов и выполните код.</li>
                            <li>Удалите функцию eatFruits() из нашего списка стека вызовов.</li>
                            <li>Удалите функцию hungry() из списка стека вызовов, так как в нем больше нет элементов.
                            </li>
                        </ol>

                        <div class="smallScreenContainer">
                            <img src="./assets/call-stack.png" alt="call-stack">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment237">Что такое очередь событий</h4>

                    <div>
                        <p>Очередь событий соответствует структуре данных очереди. Она хранит асинхронные колбэки для
                            добавления в стек вызовов. Она также известна как очередь колбэков или очередь
                            макрозадач.</p>

                        <p>Всякий раз, когда стек вызовов получает асинхронную функцию, она перемещается в веб-API. На
                            основе
                            функции веб-API выполняет ее и ожидает результата. По завершении колбэк перемещается в
                            очередь
                            событий (обратный вызов промиса перемещается в очередь микрозадач).
                        </p>

                        <p>Цикл событий постоянно проверяет, пуст ли стек вызовов. Когда стек вызовов пуст и в очереди
                            событий
                            есть колбэк, цикл событий перемещает колбэк в стек вызовов. Но если в очереди микрозадач
                            также есть колбэк, он перемещается первым. Очередь микрозадач имеет более высокий приоритет,
                            чем
                            очередь событий.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment238">Что такое декоратор</h4>

                    <div>
                        <p>Декоратор — это выражение, результатом которого является функция, которое принимает в
                            качестве
                            аргументов цель, имя и дескриптор декоратора. Кроме того, он опционально возвращает
                            дескриптор
                            декоратора для установки на целевой объект. Давайте определим декоратор администратора для
                            класса
                            пользователя во время разработки:
                        </p>

                        <pre>
//typescript decorator with experimental syntax

function admin(isAdmin) {
    return function(target) {
        target.isAdmin = isAdmin;
    }
}

@admin(true)
class User() {
}
console.log(User.isAdmin); //true

@admin(false)
class User() {
}
console.log(User.isAdmin); //false

//standard function decorator

let printFuncResult = (x) => {
    return x * 2;
}

const cacheDecorator = (func) => {
    let cache = new Map();

    return function (x) {
        if (cache.has(x)) {
            console.log("Value is from cache");
            return cache.get(x)
        }

        let result = func(x);
        cache.set(x, result);

        return result;
    }
}

printFuncResult = cacheDecorator(printFuncResult);
printFuncResult(2); // 4
printFuncResult(2); // 4 // Value is from cache
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment239">Какие есть свойства у объекта Intl</h4>

                    <div>
                        <p>Ниже приведен список свойств, доступных для объекта Intl:</p>

                        <ol>
                            <li>Collator: это объекты, которые позволяют сравнивать строки с учетом языка.</li>
                            <li>DateTimeFormat: это объекты, которые позволяют форматировать дату и время с учетом
                                языка.
                            </li>
                            <li>ListFormat: это объекты, которые позволяют форматировать список с учетом языка.</li>
                            <li>NumberFormat: объекты, которые позволяют форматировать числа с учетом языка.</li>
                            <li>PluralRules: объекты, которые обеспечивают форматирование с учетом множественного числа
                                и
                                специфичные для языка правила для множественного числа.
                            </li>
                            <li>RelativeTimeFormat: объекты, которые позволяют форматировать относительное время с
                                учетом
                                языка.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment240">Что такое унарный оператор</h4>

                    <div>
                        <p>Унарным называется оператор, который применяется к одному операнду. Например,
                            оператор унарный минус "-" меняет знак числа на противоположный:</p>

                        <pre>
//let x = 1;

x = -x;
alert( x ); // -1, применили унарный минус


//унарный плюс, преобразует значение операнда в число(подобно Number())
let x = "100";
let y = +x;
console.log(typeof x, typeof y); // string, number

let a = "Hello";
let b = +a;
console.log(typeof a, typeof b, b); // string, number, NaN
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment241">Как сортировать элементы в массиве</h4>

                    <div>
                        <p>Метод sort() используется для сортировки элементов массива и возвращает
                            отсортированный массив. Метод является калечащим!!! Пример
                            использования будет таким, как показано ниже:
                        </p>

                        <pre>
let months = ["Aug", "Sep", "Jan", "June"];
months.sort();
console.log(months); //  ["Aug", "Jan", "June", "Sep"]
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment242">Какова цель compareFunction при сортировке массивов?</h4>

                    <div>
                        <p>compareFunction используется для определения порядка сортировки. Если этот параметр опущен,
                            элементы
                            массива преобразуются в строки, а затем сортируются в соответствии со значением кодовой
                            точки
                            Юникода
                            каждого символа. Давайте рассмотрим пример, чтобы увидеть использование CompareFunction:
                        </p>

                        <pre>
let numbers = [1, 2, 5, 3, 4];
numbers.sort((a, b) => b - a); // arr.sort([compareFunction])
console.log(numbers); // [5, 4, 3, 2, 1]
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment243">Как вы переворачиваете массив</h4>

                    <div>
                        <p>Вы можете использовать метод reverse(), чтобы перевернуть элементы массива. Этот метод
                            полезен
                            для
                            сортировки массива в порядке убывания. Давайте посмотрим на использование метода reverse()
                            на
                            примере:
                        </p>

                        <pre>
let numbers = [1, 2, 5, 3, 4];
numbers.sort((a, b) => b - a); // [5, 4, 3, 2, 1]
numbers.reverse();
console.log(numbers); // [1, 2, 3, 4 ,5]
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment244">Как найти минимальное и максимальное значение в массиве</h4>

                    <div>
                        <p>Вы можете использовать методы Math.min и Math.max для переменных массива, чтобы найти
                            минимальный
                            и
                            максимальный элементы в массиве. Давайте создадим две функции для поиска минимального и
                            максимального
                            значения в массиве:
                        </p>

                        <pre>
let marks = [50, 20, 70, 60, 45, 30];
function findMin(arr) {
    return Math.min.apply(null, arr);
}
function findMax(arr) {
    return Math.max.apply(null, arr);
}

console.log(findMin(marks));
console.log(findMax(marks));
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment245">Как найти минимальные и максимальные значения без математических
                        функций?</h4>

                    <div>
                        <p>Вы можете написать функции, которые просматривают массив, сравнивая каждое значение с
                            наименьшим или
                            максимальным значением, чтобы найти минимальное и максимальное значения. Давайте создадим
                            эти
                            функции для поиска минимальных и максимальных значений:</p>

                        <pre>
let marks = [50, 20, 70, 60, 45, 30];
function findMin(arr) {
    let length = arr.length;
    let min = Infinity;
    while (length--) {
      if (arr[length] &lt; min) {
        min = arr[length];
      }
    }
    return min;
}

function findMax(arr) {
    let length = arr.length;
    let max = -Infinity;
    while (length--) {
      if (arr[length] &gt; max) {
        max = arr[length];
      }
    }
    return max;
}

console.log(findMin(marks));
console.log(findMax(marks));
                </pre>

                        <p>ну или посчитать прямо через цикл:</p>

                        <pre>
let marks = [50, 20, 70, 60, 45, 30];
let min = marks[0];
let max = marks[0];
marks.forEach(el => {
    if (el &lt; min) {
        min = el
    }
    if (el &lt; max) {
        max = el
    }
})
console.log(min) //20
console.log(max) //70
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment246">Что такое пустое заявление и его цель</h4>

                    <div>
                        <p>Пустой оператор представляет собой точку с запятой (;), указывающую, что ни один оператор не
                            будет
                            выполнен, даже если синтаксис JavaScript требует этого. Поскольку с пустым оператором нет
                            никаких
                            действий, вы можете подумать, что его использование значительно меньше, но пустой оператор
                            иногда
                            бывает полезен, когда вы хотите создать цикл с пустым телом. Например, вы можете
                            инициализировать
                            массив нулевыми значениями, как показано ниже:</p>

                        <pre>
// Initialize an array a
for (let i = 0; i &lt; a.length; a[i++] = 0);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment247">Как получить метаданные модуля</h4>

                    <div>
                        <p>Вы можете использовать объект import.meta, который представляет собой метасвойство,
                            предоставляющее
                            контекстно-зависимые метаданные модулю JavaScript. Он содержит информацию о текущем модуле,
                            например
                            URL-адрес модуля. В браузерах вы можете получить метаданные, отличные от NodeJS.
                        </p>

                        <pre>
&lt;script type="module" src="welcome-module.js"&gt;&lt;/script&gt;;
console.log(import.meta); // { url: "file:///home/user/welcome-module.js" }
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment248">Что такое оператор запятая</h4>

                    <div>
                        <p>Оператор запятая используется для оценки каждого из своих операндов слева направо и
                            возвращает значение
                            последнего операнда. Это полностью отличается от использования запятых в массивах, объектах,
                            аргументах
                            и параметрах функций. Например, использование числовых выражений будет выглядеть следующим
                            образом:</p>
                        <pre>
let x = 1;
x = (x++, x);

console.log(x); // 2
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment249">В чем преимущество оператора запятой</h4>

                    <div>
                        <p>Обычно этот оператор используется для включения нескольких выражений в место, где требуется
                            одно
                            выражение. Одним из распространенных вариантов использования этого оператора-запятой
                            является
                            предоставление
                            нескольких параметров в цикле for. Например, в приведенном ниже цикле for используется
                            несколько
                            выражений
                            в одном месте с использованием оператора-запятой:
                        </p>

                        <pre>for (let a = 0, b =10; a &lt;= 10; a++, b--)</pre>

                        <p>Вы также можете использовать оператор запятой в операторе возврата, где он обрабатывается
                            перед возвратом.</p>

                        <pre>
function myFunction() {
    let a = 1;
    return (a += 10), a; // 11
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment250">Что такое typescript</h4>

                    <div>
                        <p>TypeScript — это типизированный расширенный набор JavaScript, созданный Microsoft, который
                            добавляет
                            дополнительные типы, классы, async/await и многие другие функции и компилируется в простой
                            JavaScript.
                            Angular полностью построен на TypeScript и используется в качестве основного языка. Вы
                            можете установить его глобально как:</p>

                        <pre>npm install -g typescript</pre>

                        <p>Давайте посмотрим простой пример использования TypeScript:</p>

                        <pre>
function greeting(name: string): string {
    return "Hello, " + name;
}

let user = "Sudheer";

console.log(greeting(user));
                </pre>

                        <p>Метод greeting допускает в качестве аргумента только строковый тип.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment251">В чем разница между javascript и typescript</h4>

                    <div>
                        <p>Ниже приведен список различий между javascript и typescript:</p>

                        <div class="tableWrapper">
                            <table class="jsTheoryTable">
                                <thead>
                                <tr>
                                    <th>feature</th>
                                    <th>typescript</th>
                                    <th>javascript</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>Языковая парадигма</td>
                                    <td>Объектно-ориентированный язык программирования</td>
                                    <td>Язык сценариев</td>
                                </tr>
                                <tr>
                                    <td>Поддержка типов</td>
                                    <td>Поддерживает статическую типизацию.</td>
                                    <td>Имеет динамическую типизацию</td>
                                </tr>
                                <tr>
                                    <td>Модули</td>
                                    <td>Поддерживается</td>
                                    <td>Поддерживается только с ES6(2015)</td>
                                </tr>
                                <tr>
                                    <td>Интерфейс</td>
                                    <td>Имеет концепцию интерфейсов</td>
                                    <td>Не поддерживает интерфейсы</td>
                                </tr>
                                <tr>
                                    <td>Опциональные параметры</td>
                                    <td>Функции поддерживают необязательные параметры</td>
                                    <td>Нет поддержки опциональных параметров для функций.</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment252">Каковы преимущества typescript перед javascript</h4>

                    <div>
                        <p>Ниже приведены некоторые преимущества typescript перед javascript.</p>

                        <ol>
                            <li>
                                TypeScript способен находить ошибки времени компиляции только во время разработки и
                                снижает
                                количество ошибок во время выполнения. В то время как javascript является
                                интерпретируемым
                                языком.
                            </li>
                            <li>
                                TypeScript строго типизирован или поддерживает статическую типизацию, что позволяет
                                проверять
                                правильность типов во время компиляции. Это недоступно в JavaScript.
                            </li>
                            <li>
                                Компилятор TypeScript может компилировать файлы .ts в ES3, ES4 и ES5, в отличие от
                                функций
                                javascript ES6, которые могут не поддерживаться в некоторых браузерах.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment253">Что такое инициализатор объекта</h4>

                    <div>
                        <p>Инициализатор объекта — это выражение, описывающее инициализацию объекта.
                            Синтаксис этого выражения представлен в виде разделенного запятыми списка из нуля или
                            более пар имен свойств и связанных значений объекта, заключенных в фигурные скобки ({}).
                            Это также известно как буквальная(литеральная) запись.
                            Это один из способов создания объекта.</p>

                        <pre>
let initObject = { a: "John", b: 50, c: {} };

console.log(initObject.a); // John
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment254">Что такое метод конструктора</h4>

                    <div>
                        <p>Метод конструктора — это специальный метод для создания и инициализации объекта, созданного
                            внутри
                            класса. Если вы не укажете метод конструктора, используется конструктор по умолчанию. Пример
                            использования конструктора будет выглядеть следующим образом:
                        </p>

                        <pre>
class Employee {
    constructor() {
      this.name = "John";
    }
}

let employeeObject = new Employee();

console.log(employeeObject.name); // John
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment255">Что произойдет, если вы напишете конструктор более одного раза в
                        классе</h4>

                    <div>
                        <p>«Конструктор» в классе — это специальный метод, и его следует определять в
                            классе только один раз. т.е. если вы напишете метод конструктора более одного раза в классе,
                            он выдаст ошибку SyntaxError.</p>

                        <pre>
class Employee {
    constructor() {
      this.name = "John";
    }
    constructor() {   //  Uncaught SyntaxError: A class may only have one constructor
      this.age = 30;
    }
}

let employeeObject = new Employee();
console.log(employeeObject.name);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment256">Как вызвать конструктор родительского класса?</h4>

                    <div>
                        <p>Вы можете использовать ключевое слово super для вызова конструктора
                            родительского класса. Помните, что super() необходимо вызвать перед использованием ссылки
                            this.
                            В противном случае это приведет к ошибке ссылки. Пример:</p>

                        <pre>
class Square extends Rectangle {
    constructor(length) {
      super(length, length);
      this.name = "Square";
    }

    get area() {
      return this.width * this.height;
    }

    set area(value) {
      this.area = value;
    }
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment257">Как получить прототип объекта</h4>

                    <div>
                        <p>Вы можете использовать метод Object.getPrototypeOf(obj) для возврата прототипа указанного
                            объекта. то
                            есть значение внутреннего свойства прототипа. Если унаследованных свойств нет, возвращается
                            нулевое
                            значение.</p>

                        <pre>
const newPrototype = {};
const newObject = Object.create(newPrototype);

console.log(Object.getPrototypeOf(newObject) === newPrototype); // true
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment258">Что произойдет, если я передам тип строки для метода
                        getPrototype</h4>

                    <div>
                        <p>В ES5 будет выдано исключение TypeError, если параметр obj не является
                            объектом. Тогда как в ES2015 параметр будет привязан к объекту.</p>

                        <pre>
// ES5
Object.getPrototypeOf("James"); // TypeError: "James" is not an object
// ES2015
Object.getPrototypeOf("James"); // String.prototype
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment259">Как вы устанавливаете прототип одного объекта на другой?</h4>

                    <div>
                        <p>Вы можете использовать метод Object.setPrototypeOf(), который устанавливает
                            прототип
                            (т. е. внутреннее
                            свойство Prototype) указанного объекта в другой объект или в значение null. Например, если
                            вы
                            хотите
                            установить прототип square object в rectangle object, это будет выглядеть следующим образом:
                        </p>

                        <pre>
Object.setPrototypeOf(Square.prototype, Rectangle.prototype);
Object.setPrototypeOf({}, null);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment260">Как проверить, может ли объект быть расширяемым или нет?</h4>

                    <div>
                        <p>Метод Object.isExtensible() используется для определения того, является ли объект
                            расширяемым или нет. то есть, могут ли к нему быть добавлены новые свойства или нет.</p>

                        <pre>
const newObject = {};
console.log(Object.isExtensible(newObject)); //true
                </pre>

                        <p>Примечание: По умолчанию все объекты являются расширяемыми. т. е. новые
                            свойства могут быть добавлены или изменены.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment261">Как предотвратить расширение объекта</h4>

                    <div>
                        <p>Метод Object.preventExtensions() используется для предотвращения добавления новых свойств к
                            объекту.
                            Другими словами, это предотвращает будущие расширения объекта. Давайте посмотрим, как
                            используется
                            это свойство:</p>

                        <pre>
const newObject = {};
Object.preventExtensions(newObject); // NOT extendable

try {
    Object.defineProperty(newObject, "newProperty", {
      // Adding new property
      value: 100,
    });
} catch (e) {
    console.log(e); // TypeError: Cannot define property newProperty, object is not extensible
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment262">Какоие существуют способы сделать объект нерасширяемым?</h4>

                    <div>
                        <p>Вы можете пометить объект как нерасширяемый тремя способами:</p>

                        <ol>
                            <li>Object.preventExtensions</li>
                            <li>Object.seal</li>
                            <li>Object.freeze</li>
                        </ol>

                        <pre>
let newObject = {};

Object.preventExtensions(newObject); // Prevent objects are non-extensible
Object.isExtensible(newObject); // false

let sealedObject = Object.seal({}); // Sealed objects are non-extensible
Object.isExtensible(sealedObject); // false

let frozenObject = Object.freeze({}); // Frozen objects are non-extensible
Object.isExtensible(frozenObject); // false
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment263">Как определить/изменить несколько свойств объекта</h4>

                    <div>
                        <p>Метод Object.defineProperties() используется для определения новых или изменения существующих
                            свойств
                            непосредственно объекта и возврата объекта. Давайте определим несколько свойств пустого
                            объекта:</p>

                        <pre>
const newObject = {};

Object.defineProperties(newObject, {
    newProperty1: {
        value: "John",
        writable: true,
    },
    newProperty2: {},
});
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment264">Что такое MEAN в JavaScript</h4>

                    <div>
                        <p>Стек MEAN (MongoDB, Express, AngularJS и Node.js) — это самый популярный технологический стек
                            программного обеспечения JavaScript с открытым исходным кодом, доступный для создания
                            динамических
                            веб-приложений, где вы можете писать как серверную, так и клиентскую половины веб-проекта.
                            полностью на JavaScript.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment265">Что такое обфускация в JavaScript</h4>

                    <div>
                        <p>Обфускация — это преднамеренное действие по созданию запутанного кода
                            Javascript (т.е. исходного или машинного кода), который трудно понять людям.
                            Это похоже на шифрование, но машина может понять код и выполнить его.
                            Давайте посмотрим на функцию ниже перед обфускацией:</p>

                        <pre>
function greeting() {
   console.log("Hello, welcome to JS world");
}
                </pre>

                        <p>И после обфускации кода он будет выглядеть так, как показано ниже:</p>

                        <pre>
eval(
    (function (p, a, c, k, e, d) {
        e = function (c) {
          return c;
        };
        if (!"".replace(/^/, String)) {
          while (c--) {
            d[c] = k[c] || c;
          }
          k = [
            function (e) {
              return d[e];
            },
          ];
          e = function () {
            return "\\w+";
          };
          c = 1;
        }
        while (c--) {
          if (k[c]) {
            p = p.replace(new RegExp("\\b" + e(c) + "\\b", "g"), k[c]);
          }
        }
        return p;
    })(
        "2 1(){0.3('4, 7 6 5 8')}",
        9,
        9,
        "console|greeting|function|log|Hello|JS|to|welcome|world".split("|"),
        0,
        {}
    )
);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment266">Зачем нужна обфускация</h4>

                    <div>
                        <p>Ниже приведены несколько причин обфускации:</p>

                        <ol>
                            <li>Размер кода будет уменьшен. Таким образом, передача данных между
                                сервером и клиентом будет быстрой.
                            </li>
                            <li>Он скрывает бизнес-логику от внешнего мира и защищает код от других.</li>
                            <li>Реверс-инжиниринг очень сложен</li>
                            <li>Время загрузки будет сокращено</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment267">Что такое минификация</h4>

                    <div>
                        <p>Минификация — это процесс удаления всех ненужных символов (пустые пробелы удаляются), а
                            переменные
                            переименовываются без изменения их функциональности. Это также своего рода запутывание.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment268">В чем преимущества минификации</h4>

                    <div>
                        <p>Обычно рекомендуется использовать минификацию при интенсивном трафике и высоких
                            требованиях к ресурсам. Это уменьшает размеры файлов со следующими преимуществами:</p>

                        <ol>
                            <li>Уменьшает время загрузки веб-страницы</li>
                            <li>Экономит использование полосы пропускания</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment269">В чем разница между обфускацией и шифрованием</h4>

                    <div>
                        <p>Ниже приведены основные различия между обфускацией и шифрованием.</p>

                        <div class="tableWrapper">
                            <table class="jsTheoryTable">
                                <thead>
                                <tr>
                                    <th>Feature</th>
                                    <th>Obfuscation</th>
                                    <th>Encryption</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>Определение</td>
                                    <td>Изменение формы любых данных в любую другую форму</td>
                                    <td>Изменение формы информации в нечитаемый формат с помощью ключа</td>
                                </tr>
                                <tr>
                                    <td>Ключ для декодирования</td>
                                    <td>Можно расшифровать без какого-либо ключа</td>
                                    <td>Требуется</td>
                                </tr>
                                <tr>
                                    <td>Целевой формат данных</td>
                                    <td>Данные будут преобразованы в сложную форму</td>
                                    <td>Данные будут преобразованы в нечитаемый формат</td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment270">Какие общие инструменты используются для минификации</h4>

                    <div>
                        <p>Существует множество онлайн-/оффлайн-инструментов для минимизации файлов JavaScript:</p>

                        <ol>
                            <li>Google's Closure Compiler</li>
                            <li>UglifyJS2</li>
                            <li>jsmin</li>
                            <li>javascript-minifier.com/</li>
                            <li>prettydiff.com</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment271">Как выполнить валидацию формы с помощью JavaScript</h4>

                    <div>
                        <p>JavaScript можно использовать для проверки HTML-формы. Например, если поле формы пусто,
                            функция
                            должна
                            уведомить об этом и вернуть false, чтобы предотвратить отправку формы. Давайте выполним вход
                            пользователя в html-форму:
                        </p>

                        <pre>
&lt;form name="myForm" onsubmit="return validateForm()" method="post"&gt;
    User name: &lt;input type="text" name="uname" /&gt;
    &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
                </pre>

                        <p>И проверка входа пользователя приведена ниже:</p>

                        <pre>
function validateForm() {
    let x = document.forms["myForm"]["uname"].value;
    if (x == "") {
        alert("The username shouldn't be empty");
        return false;
    }
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment272">Как выполнить валидацию формы без JavaScript</h4>

                    <div>
                        <p>Вы можете выполнить проверку HTML-формы автоматически без использования JavaScript.
                            Проверка включается путем применения required атрибута для предотвращения отправки формы,
                            когда
                            ввод пуст.
                        </p>

                        <pre>
&lt;form method="post"&gt;
    &lt;input type="text" name="uname" required /&gt;
    &lt;input type="submit" value="Submit" /&gt;
&lt;/form&gt;
                </pre>

                        <p>Примечание: Автоматическая проверка формы не работает в Internet Explorer 9 и
                            более ранних версиях.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment273">Какие методы DOM доступны для проверки ограничений</h4>

                    <div>
                        <p>Приведенные ниже методы DOM доступны для проверки ограничений на недопустимый ввод:</p>

                        <ol>
                            <li>checkValidity(): возвращает true, если входной элемент содержит действительные данные.
                            </li>
                            <li>
                                setCustomValidity(): используется для установки свойства validationMessage
                                входного элемента. Давайте возьмем форму входа пользователя с проверкой DOM.

                                <pre>
function myFunction() {
    let userName = document.getElementById("uname");
    if (!userName.checkValidity()) {
        document.getElementById("message").innerHTML = userName.validationMessage;
    } else {
        document.getElementById("message").innerHTML = "Entered a valid username";
    }
}
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment274">Какие есть доступные свойства DOM для проверки ограничений?</h4>

                    <div>
                        <p>Ниже приведен список некоторых доступных свойств DOM для проверки ограничений.</p>

                        <ol>
                            <li>validity: предоставляет список логических свойств, связанных с достоверностью входного
                                элемента.
                            </li>
                            <li>validationMessage: отображает сообщение, когда действительность ложна.</li>
                            <li>willValidate: указывает, будет ли входной элемент проверен или нет.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment275">Каков список свойств validity</h4>

                    <div>
                        <p>Свойство validity input элемента предоставляет набор свойств, связанных с достоверностью
                            данных:</p>

                        <ol>
                            <li>customError: возвращает true, если установлено пользовательское сообщение о
                                достоверности.
                            </li>
                            <li>patternMismatch: возвращает true, если значение элемента не соответствует его pattern
                                атрибуту.
                            </li>
                            <li>rangeOverflow: возвращает true, если значение элемента больше его max атрибута.</li>
                            <li>rangeUnderflow: возвращает true, если значение элемента меньше его min атрибута.</li>
                            <li>stepMismatch: возвращает true, если значение элемента недопустимо в соответствии с
                                атрибутом
                                step.
                            </li>
                            <li>tooLong: возвращает true, если значение элемента превышает его атрибут maxLength.</li>
                            <li>typeMismatch: возвращает true, если значение элемента недопустимо в соответствии с
                                атрибутом
                                type.
                            </li>
                            <li>valueMissing: возвращает true, если элемент с required атрибутом не имеет значения.</li>
                            <li>valid: возвращает true, если значение элемента допустимо.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment276">Приведите пример использования свойства rangeOverflow.</h4>

                    <div>
                        <p>Если значение элемента больше, чем его атрибут max, свойство rangeOverflow возвращает true.
                            Например,
                            при отправке формы ниже выдается ошибка, если значение превышает 100:</p>

                        <pre>
&lt;input id="age" type="number" max="100" /&gt;
&lt;button onclick="myOverflowFunction()"&gt;OK&lt;/button&gt;

-----------------------------------------------------

function myOverflowFunction() {
    if (document.getElementById("age").validity.rangeOverflow) {
        alert("The mentioned age is not allowed");
    }
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment277">Доступна ли функционал enums в JavaScript?</h4>

                    <div>
                        <p>Нет, JavaScript изначально не поддерживает enums. Но существуют различные виды решений для их
                            моделирования, даже если они не могут обеспечить точных эквивалентов. Например, вы можете
                            использовать freeze или seal объекта:</p>

                        <pre>const DaysEnum = Object.freeze({"monday":1, "tuesday":2, "wednesday":3, ...})</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment278">Что такое enum(перечисление)</h4>

                    <div>
                        <p>enum — это тип, ограничивающий переменные одним значением из предопределенного набора
                            констант.
                            В JavaScript нет перечислений, но Typescript обеспечивает встроенную поддержку
                            перечислений.</p>

                        <pre>
//TS
enum Color {
    RED, GREEN, BLUE
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment279">Как составить список всех свойств объекта</h4>

                    <div>
                        <p>Вы можете использовать метод Object.getOwnPropertyNames(), который возвращает массив всех
                            свойств,
                            найденных непосредственно в данном объекте. Давайте использовать его в примере:</p>

                        <pre>
const newObject = {
    a: 1,
    b: 2,
    c: 3,
};

console.log(Object.getOwnPropertyNames(newObject)); // ["a", "b", "c"];
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment280">Как получить дескрипторы свойств объекта</h4>

                    <div>
                        <p>Вы можете использовать метод Object.getOwnPropertyDescriptors(), который возвращает все
                            собственные
                            дескрипторы свойств данного объекта. Пример использования этого метода приведен ниже:</p>

                        <pre>
const newObject = {
    a: 1,
    b: 2,
    c: 3,
};
const descriptorsObject = Object.getOwnPropertyDescriptors(newObject);
console.log(descriptorsObject.a.writable); //true
console.log(descriptorsObject.a.configurable); //true
console.log(descriptorsObject.a.enumerable); //true
console.log(descriptorsObject.a.value); // 1
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment281">Какие есть атрибуты, предоставляемые дескриптором свойства?</h4>

                    <div>
                        <p>Дескриптор свойства — это запись, которая имеет следующие атрибуты:</p>

                        <ol>
                            <li>value: значение, связанное со свойством.</li>
                            <li>writable: определяет, можно ли изменить значение, связанное со свойством, или нет.</li>
                            <li>configurable: возвращает true, если тип этого дескриптора свойства можно изменить и если
                                свойство можно удалить из соответствующего объекта.
                            </li>
                            <li>enumerable: определяет, отображается ли свойство во время перечисления
                                свойств соответствующего объекта или нет.
                            </li>
                            <li>set: функция, которая служит установщиком свойства.</li>
                            <li>get: функция, которая служит для получения свойства.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment282">Как создавать цепочку наследований классов(extends)</h4>

                    <div>
                        <p>Ключевое слово extends используется в объявлениях/выражениях для создания
                            класса, который является дочерним по отношению к другому классу. Его можно использовать для
                            создания подклассов пользовательских классов, а также встроенных объектов. Синтаксис будет
                            таким,
                            как показано ниже:</p>

                        <pre>class ChildClass extends ParentClass { ... }</pre>

                        <p>Давайте возьмем пример подкласса Square из родительского класса Rectangle:</p>

                        <pre>
class Square extends Rectangle {
    constructor(length) {
      super(length, length);
      this.name = "Square";
    }

    get area() {
      return this.width * this.height;
    }

    set area(value) {
      this.area = value;
    }
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment283">Как изменить URL без перезагрузки страницы</h4>

                    <div>
                        <p>Свойство window.location.href поможет изменить URL-адрес, но оно перезагружает страницу. В
                            HTML5
                            появились методы History.pushState() и History.replaceState(), которые позволяют добавлять и
                            изменять записи истории соответственно. Например, вы можете использовать pushState, как
                            показано
                            ниже:
                        </p>

                        <pre>window.history.pushState("page2", "Title", "/page2.html");</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment284">Как проверить, содержит ли массив определенное значение или
                        нет?</h4>

                    <div>
                        <p>Метод Array.includes() используется для определения того, включает ли массив определенное
                            значение
                            среди своих записей, возвращая либо true, либо false. Давайте посмотрим пример поиска
                            элемента
                            (числового и строкового) в массиве.
                        </p>

                        <pre>
const numericArray = [1, 2, 3, 4];
console.log(numericArray.includes(3)); // true

const stringArray = ["green", "yellow", "blue"];
console.log(stringArray.includes("blue")); //true
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment285">Как сравнивать скалярные массивы</h4>

                    <div>
                        <p>Вы можете использовать длину и every метод массивов для сравнения двух скалярных
                            (сравниваемых
                            напрямую
                            с использованием ===) массивов. Комбинация этих выражений может дать ожидаемый результат:
                        </p>

                        <pre>
const arrayFirst = [1, 2, 3, 4, 5];
const arraySecond = [1, 2, 3, 4, 5];
console.log(
    arrayFirst.length === arraySecond.length && arrayFirst.every((value, index) => value === arraySecond[index])
); // true
                </pre>

                        <p>Если вы хотите сравнить неотсортированные массивы, вам следует отсортировать их заранее:</p>

                        <pre>
const arrayFirst = [2, 3, 1, 4, 5];
const arraySecond = [1, 2, 3, 4, 5];
console.log(
    arrayFirst.length === arraySecond.length && arrayFirst.sort().every((value, index) => value === arraySecond[index])
); //true
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment286">Как получить значение из параметров get</h4>

                    <div>
                        <p>Новый объект URL() принимает строку URL-адреса, а свойство searchParams этого объекта можно
                            использовать для доступа к get параметрам. Помните, что вам может потребоваться использовать
                            полифилл или window.location для доступа к URL-адресу в старых браузерах (включая IE).
                        </p>

                        <pre>
let urlString = "http://www.some-domain.com/about.html?x=1&y=2&z=3"; //window.location.href
let url = new URL(urlString);
let parameterZ = url.searchParams.get("z");
console.log(parameterZ); // 3
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment287">Как печатать числа через запятую в виде разделителей тысяч?</h4>

                    <div>
                        <p>Вы можете использовать метод Number.prototype.toLocaleString(), который возвращает строку с
                            представлением этого числа, зависящим от языка, например разделителем тысяч, валютой и
                            т.д.</p>

                        <pre>
function convertToThousandFormat(x) {
    return x.toLocaleString();
}

console.log(convertToThousandFormat(12345.6789)); // 12,345.679
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment288">В чем разница между Java и JavaScript</h4>

                    <div>
                        <p>Оба языка программирования совершенно не связаны друг с другом, и между ними нет никакой
                            связи.
                            Java
                            статически типизирована, компилируется и работает на собственной виртуальной машине. В то
                            время
                            как
                            Javascript динамически типизируется, интерпретируется и запускается в средах браузера и
                            nodejs.
                            Давайте посмотрим основные различия в табличном формате:
                        </p>

                        <div class="tableWrapper">
                            <table class="jsTheoryTable">
                                <thead>
                                <tr>
                                    <th>Feature</th>
                                    <th>Java</th>
                                    <th>JavaScript</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>Типизация</td>
                                    <td>Строго типизированный язык</td>
                                    <td>Динамически типизированный язык</td>
                                </tr>
                                <tr>
                                    <td>Парадигма</td>
                                    <td>Объектно-ориентированного программирования</td>
                                    <td>Программирование на основе прототипов</td>
                                </tr>
                                <tr>
                                    <td>Scoping</td>
                                    <td>Block scoped</td>
                                    <td>Function-scoped</td>
                                </tr>
                                <tr>
                                    <td>Параллелизм</td>
                                    <td>На основе потоков</td>
                                    <td>На основе событий</td>
                                </tr>
                                <tr>
                                    <td>Память</td>
                                    <td>Использует больше памяти</td>
                                    <td>Использует меньше памяти. Следовательно, он будет использоваться для
                                        веб-страниц.
                                    </td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment289">Поддерживает ли JavaScript namespace(пространство имен)</h4>

                    <div>
                        <p>JavaScript по умолчанию не поддерживает пространство имен. Поэтому, если вы создаете
                            какой-либо
                            элемент
                            (функцию, метод, объект, переменную), он становится глобальным и загрязняет глобальное
                            пространство
                            имен. Давайте рассмотрим пример определения двух функций без какого-либо пространства имен:
                        </p>

                        <pre>
function func1() {
    console.log("This is a first definition");
}
function func1() {
    console.log("This is a second definition");
}
func1(); // This is a second definition
                </pre>

                        <p>Всегда вызывается второе определение функции. В этом случае пространство имен решило проблему
                            конфликта имен.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment290">Как вы объявляете пространство имен</h4>

                    <div>
                        <p>Несмотря на то, что в JavaScript отсутствуют пространства имен, мы можем
                            использовать Objects, IIFE для создания пространств имен.</p>

                        <ol>
                            <li>
                                Использование обозначения объектного литерала. Давайте обернем переменные и функции
                                внутри
                                литерала объекта, который действует как пространство имен. После этого вы можете
                                получить к
                                ним
                                доступ, используя нотацию объекта.
                                <pre>
let namespaceOne = {
    function func1() {
        console.log("This is a first definition");
    }
}
let namespaceTwo = {
    function func1() {
        console.log("This is a second definition");
    }
}
namespaceOne.func1(); // This is a first definition
namespaceTwo.func1(); // This is a second definition
                        </pre>
                            </li>
                            <li>
                                Использование IIFE (выражение функции с немедленным вызовом): внешняя пара круглых
                                скобок
                                IIFE
                                создает локальную область видимости для всего кода внутри него и превращает анонимную
                                функцию в
                                функциональное выражение. Благодаря этому вы можете создать одну и ту же функцию в двух
                                разных
                                выражениях функций, которые будут выступать в качестве пространства имен.
                                <pre>
(function () {
    function fun1() {
      console.log("This is a first definition");
    }
    fun1();
})();

(function () {
    function fun1() {
      console.log("This is a second definition");
    }
    fun1();
})();
                        </pre>
                            </li>
                            <li>
                                Использование блока и объявления let/const. В ECMAScript 6 вы можете просто использовать
                                блок и
                                объявление let, чтобы ограничить область действия переменной блоком.
                                <pre>
{
    let myFunction = function fun1() {
      console.log("This is a first definition");
    };
    myFunction();
}
//myFunction(): ReferenceError: myFunction is not defined.

{
    let myFunction = function fun1() {
      console.log("This is a second definition");
    };
    myFunction();
}
//myFunction(): ReferenceError: myFunction is not defined.
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment291">Как вызвать код JavaScript в iframe с родительской
                        страницы?(deprecated)</h4>

                    <div>
                        <p>Первоначально доступ к iFrame должен осуществляться с помощью document.getElementBy
                            или window.frames. После этого свойство contentWindow iFrame предоставляет доступ к
                            targetFunction.
                        </p>

                        <pre>
document.getElementById("targetFrame").contentWindow.targetFunction();
window.frames[0].frameElement.contentWindow.targetFunction(); // Accessing iframe this way may not work in latest versions chrome and firefox
                </pre>

                        <p>Информация устарела, об общении между окнами почитать можно <a
                                href="https://learn.javascript.ru/cross-window-communication" target="_blank">тут.</a>
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment292">Как получить смещение часового пояса относительно даты</h4>

                    <div>
                        <p>Вы можете использовать метод getTimezoneOffset объекта даты. Этот метод возвращает разницу
                            часовых поясов в минутах от текущего языкового стандарта (настройки хост-системы) до UTC.
                        </p>

                        <pre>
let offset = new Date().getTimezoneOffset();
console.log(offset); // -480
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment293">Как динамически загружать файлы CSS и JS</h4>

                    <div>
                        <p>Вы можете создавать элементы ссылок и сценариев в DOM и добавлять их в качестве дочерних
                            элементов к
                            тегу заголовка. Давайте создадим функцию для добавления ресурсов скриптов и стилей, как
                            показано
                            ниже:</p>

                        <pre>
function loadAssets(filename, filetype) {
    if (filetype == "css") {
      // External CSS file
      var fileReference = document.createElement("link");
      fileReference.setAttribute("rel", "stylesheet");
      fileReference.setAttribute("type", "text/css");
      fileReference.setAttribute("href", filename);
    } else if (filetype == "js") {
      // External JavaScript file
      var fileReference = document.createElement("script");
      fileReference.setAttribute("type", "text/javascript");
      fileReference.setAttribute("src", filename);
    }
    if (typeof fileReference != "undefined")
      document.getElementsByTagName("head")[0].appendChild(fileReference);
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment294">Какие существуют методы поиска HTML-элементов в DOM?</h4>

                    <div>
                        <p>Если вы хотите получить доступ к любому элементу HTML-страницы, вам нужно начать с доступа к
                            объекту
                            document. Позже вы можете использовать любой из следующих методов, чтобы найти элемент
                            HTML:</p>

                        <ol>
                            <li>document.getElementById(id): находит элемент по идентификатору.</li>
                            <li>document.getElementsByTagName(name): находит элемент по имени тега.</li>
                            <li>document.getElementsByClassName(name): находит элемент по имени класса.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment295">Что такое jQuery</h4>

                    <div>
                        <p>jQuery — это популярная кросс-браузерная библиотека JavaScript, которая обеспечивает обход
                            объектной
                            модели документа (DOM), обработку событий, анимацию и взаимодействие AJAX, сводя к минимуму
                            расхождения
                            между браузерами. Он широко известен своей философией «Пиши меньше, делай больше». Например,
                            вы
                            можете
                            отобразить приветственное сообщение при загрузке страницы с помощью jQuery, как показано
                            ниже:</p>

                        <pre>
$(document).ready(function () {
    // It selects the document and apply the function on page load
    alert("Welcome to jQuery world");
});
                </pre>

                        <p>Примечание: Вы можете скачать его с официального сайта jquery или установить с CDN, например
                            Google.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment296">Что такое движок JavaScript V8</h4>

                    <div>
                        <p>V8 — это высокопроизводительный движок JavaScript с открытым исходным кодом, используемый
                            браузером
                            Google Chrome и написанный на C++. Он также используется в проекте node.js. Он реализует
                            ECMAScript
                            и WebAssembly и работает в Windows 7 или более поздней версии, macOS 10.12+ и системах
                            Linux,
                            использующих
                            процессоры x64, IA-32, ARM или MIPS. Примечание. Он может работать автономно или быть
                            встроен в
                            любое приложение C++.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment297">Почему JavaScript называется динамическим языком</h4>

                    <div>
                        <p>JavaScript — это слабо типизированный или динамический язык, поскольку переменные в
                            JavaScript не связаны напрямую с каким-либо конкретным типом значения, и любой переменной
                            можно
                            присвоить/переназначить значения всех типов.</p>

                        <pre>
let age = 50; // age is a number now
age = "old"; // age is a string now
age = true; // age is a boolean
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment298">Что такое оператор void</h4>

                    <div>
                        <p>Оператор void оценивает данное выражение, а затем возвращает undefined (т. е. без
                            возврата значения). Синтаксис будет таким, как показано ниже:</p>

                        <pre>
void expression;
void expression;
                </pre>
                        <p>Давайте отобразим сообщение без перенаправления или перезагрузки:</p>

                        <pre>
&lt;a href="javascript:void(alert('Welcome to JS world'))"&gt;
    Click here to see a message
&lt;/a&gt;
                </pre>

                        <p>Примечание. Этот оператор часто используется для получения примитивного значения undefined с
                            помощью «void(0)».</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment299">Как поставить курсор на ожидание</h4>

                    <div>
                        <p>Курсор можно настроить на ожидание в JavaScript, используя свойство "cursor".
                            Давайте реализуем это поведение при загрузке страницы, используя функцию ниже.</p>

                        <pre>
function myFunction() {
    window.document.body.style.cursor = "wait";
}
                </pre>

                        <p>и эта функция вызывается при загрузке страницы</p>

                        <pre>&lt;body onload="myFunction()"&gt;&lt;/body&gt;</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment300">Как создать бесконечный цикл</h4>

                    <div>
                        <p>Вы можете создавать бесконечные циклы, используя циклы for и while, без использования
                            каких-либо выражений. Конструкция или синтаксис цикла for является лучшим подходом с точки
                            зрения
                            инструментов ESLint и оптимизатора кода.</p>

                        <pre>
for (;;) {}
while (true) {}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment301">Почему нужно избегать оператора "with"</h4>

                    <div>
                        <p>Оператор with в JavaScript был предназначен для сокращения записи повторяющихся обращений к
                            объектам.
                            Таким образом, это может помочь уменьшить размер файла за счет уменьшения необходимости
                            повторять
                            длинную ссылку на объект без снижения производительности. Давайте рассмотрим пример, где он
                            используется, чтобы избежать избыточности при многократном доступе к объекту.</p>

                        <pre>
a.b.c.greeting = "welcome";
a.b.c.age = 32;
                </pre>

                        <p>Использование «with» превращает это в:</p>

                        <pre>
with (a.b.c) {
    greeting = "welcome";
    age = 32;
}
                </pre>

                        <p>Но оператор with создает проблемы с производительностью, поскольку невозможно предсказать,
                            будет
                            ли
                            аргумент ссылаться на действительную переменную или на свойство внутри аргумента with.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment302">Каков вывод для приведенных ниже примеров циклов for</h4>

                    <div>
                <pre>
for (var i = 0; i &lt; 4; i++) {
    // global scope
    setTimeout(() => console.log(i));
}

for (let i = 0; i &lt; 4; i++) {
    // block scope
    setTimeout(() => console.log(i));
}
                </pre>

                        <p>Вывод приведенных выше циклов for равен 4 4 4 4 и 0 1 2 3.</p>
                        <p>Объяснение: Из-за очереди событий/цикла JavaScript функция обратного вызова setTimeout
                            вызывается
                            после
                            выполнения цикла. Поскольку переменная i объявлена с ключевым словом var, она стала
                            глобальной
                            переменной, и ее значение было равно 4 при использовании итерации при вызове функции time
                            setTimeout.
                            Следовательно, выход первого цикла равен 4 4 4 4.</p>
                        <p>В то время как во втором цикле переменная i объявлена как ключевое слово let, она становится
                            переменной
                            области действия блока и содержит новое значение (0, 1, 2 3) для каждой итерации.
                            Следовательно,
                            выход второго цикла равен 0 1 2 3.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment303">Перечислите некоторые возможности ES6.</h4>

                    <div>
                        <p>Ниже приведен список некоторых новых функций ES6:</p>

                        <ul>
                            <li>Поддержка констант или неизменяемых переменных</li>
                            <li>Поддержка блочной области видимости для переменных, констант и функций</li>
                            <li>Стрелочные функции (Arrow functions)</li>
                            <li>Параметры по умолчанию (Default parameters)</li>
                            <li>Операторы Rest and Spread (Rest and Spread Parameters)</li>
                            <li>Шаблонные литералы (Template Literals)</li>
                            <li>Многострочные строки (Multi-line Strings)</li>
                            <li>Деструктуризация (Destructuring Assignment)</li>
                            <li>Расширенные объектные литералы(Enhanced Object Literals)</li>
                            <li>Промисы (Promises)</li>
                            <li>Классы (Classes)</li>
                            <li>Модули (Modules)</li>
                        </ul>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment304">Что такое ES6</h4>

                    <div>
                        <p>ES6 — шестая редакция языка javascript, выпущенная в июне 2015 года. Первоначально он
                            был известен как ECMAScript 6 (ES6), а затем переименован в ECMAScript 2015. Почти все
                            современные браузеры
                            поддерживают ES6, но для старых браузеров существует множество транспиляторов, например
                            Babel.js
                            и т. д.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment305">Могу ли я переопределить переменные let и const?</h4>

                    <div>
                        <p>Нет, вы не можете переопределить переменные let и const. Если вы это сделаете,
                            он выдаст ошибку как показано ниже:</p>

                        <pre>Uncaught SyntaxError: Identifier 'someVariable' has already been declared</pre>

                        <p>Объяснение: Объявление переменной с ключевым словом var относится к области действия функции,
                            и
                            переменная обрабатывается так, как если бы она была объявлена в верхней части охватывающей
                            области
                            видимости из-за функции подъема. Таким образом, все многочисленные объявления, вносящие
                            вклад в
                            одну и ту же поднятую переменную, без каких-либо ошибок. Давайте рассмотрим пример
                            повторного
                            объявления переменных в одной области как для переменных var, так и для переменных
                            let/const.</p>

                        <pre>
let name = "John";
function myFunc() {
    var name = "Nick";
    var name = "Abraham"; // Re-assigned in the same function block
    alert(name); // Abraham
}
myFunc();
alert(name); // John
                </pre>

                        <p>Многократное объявление с областью действия блока выдает синтаксическую ошибку:</p>

                        <pre>
let name = "John";
function myFunc() {
    let name = "Nick";
    let name = "Abraham"; // Uncaught SyntaxError: Identifier 'name' has already been declared
    alert(name);
}

myFunc();
alert(name);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment306">Константная переменная делает значение неизменяемым?</h4>

                    <div>
                        <p>Нет, переменная const не делает значение неизменяемым. Но он запрещает последующие назначения
                            (т. е. вы можете объявить с присвоением, но не можете позже присвоить другое значение)</p>

                        <pre>
const userList = [];
userList.push("John"); // Can mutate even though it can't re-assign
console.log(userList); // ['John']
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment307">Что такое параметры по умолчанию</h4>

                    <div>
                        <p>В ES5 нам нужно полагаться на логические операторы ИЛИ для обработки значений параметров
                            функции
                            по
                            умолчанию. В то время как в ES6 функция параметров функции по умолчанию позволяет
                            инициализировать
                            параметры значениями по умолчанию, если не передано никакое значение или неопределенное
                            значение.
                            Давайте сравним поведение с примерами:</p>

                        <pre>
//ES5
var calculateArea = function (height, width) {
    height = height || 50;
    width = width || 60;

    return width * height;
};
console.log(calculateArea()); //300
                </pre>

                        <p>Параметры по умолчанию упрощают инициализацию:</p>

                        <pre>
//ES6
var calculateArea = function (height = 50, width = 60) {
    return width * height;
};

console.log(calculateArea()); //300
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment308">Что такое шаблонные литералы</h4>

                    <div>
                        <p>Литералы шаблонов или строки шаблонов — это строковые литералы, позволяющие встраивать
                            выражения.
                            Они
                            заключаются в обратную галочку (`) вместо двойных или одинарных кавычек. В ES6 эта функция
                            позволяет
                            использовать динамические выражения, как показано ниже:</p>

                        <pre>let greeting = `Welcome to JS World, Mr. ${firstName} ${lastName}.`;</pre>

                        <p>В ES5 вам нужно разорвать строку, как показано ниже:</p>

                        <pre>var greeting = 'Welcome to JS World, Mr. ' + firstName + ' ' + lastName;</pre>

                        <p>Примечание. С литералами шаблона можно использовать многострочные строки и функции
                            интерполяции
                            строк.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment309">Как писать многострочные строки в литералах шаблона</h4>

                    <div>
                        <p>В ES5 вам придется использовать escape-символы новой строки ('\n') и символы
                            конкатенации (+), чтобы получить многострочные строки.</p>

                        <pre>console.log("This is string sentence 1\n" + "This is string sentence 2");</pre>

                        <p>В то время как в ES6 вам не нужно упоминать какой-либо символ новой строки:</p>

                        <pre>
console.log(`This is string sentence
'This is string sentence 2`);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment310">Что такое шаблоны вложения(nesting templates)</h4>

                    <div>
                        <p>Шаблон вложения — это функция, поддерживаемая в синтаксисе литералов шаблона, позволяющая
                            использовать
                            внутренние обратные кавычки внутри заполнителя ${ } внутри шаблона. Например, приведенный
                            ниже
                            шаблон
                            вложения используется для отображения значков на основе разрешений пользователя, тогда как
                            внешний
                            шаблон проверяет тип платформы:</p>

                        <pre>
const iconStyles = `icon ${
    isMobilePlatform()
        ? ""
        : `icon-${user.isAuthorized ? "submit" : "disabled"}`
}`;
                </pre>

                        <p>Вы также можете написать приведенный выше вариант использования без вложения
                            функций шаблона. Однако функция шаблона вложения более компактна и удобочитаема.</p>

                        <pre>
//Without nesting templates
const iconStyles = `icon ${
    isMobilePlatform()
        ? ""
        : user.isAuthorized
        ? "icon-submit"
        : "icon-disabled"
}`;
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment311">Что такое теговые шаблоны(tagged templates)</h4>

                    <div>
                        <p>Шаблоны с тегами — это расширенная форма шаблонов, в которой теги позволяют
                            анализировать литералы
                            шаблона с помощью функции. Функция тега принимает первый параметр как массив строк, а
                            остальные
                            параметры как выражения. Эта функция также может возвращать измененные строки на основе
                            параметров.
                            Давайте посмотрим, как этот шаблон с тегами используется в наборе навыков ИТ-специалиста в
                            организации:</p>

                        <pre>
var user1 = "John";
var skill1 = "JavaScript";
var experience1 = 15;

var user2 = "Kane";
var skill2 = "JavaScript";
var experience2 = 5;

function myInfoTag(strings, userExp, experienceExp, skillExp) {
    var str0 = strings[0]; // "Mr/Ms. "
    var str1 = strings[1]; // " is a/an "
    var str2 = strings[2]; // "in"

    var expertiseStr;
    if (experienceExp &gt; 10) {
      expertiseStr = "expert developer";
    } else if (skillExp &gt; 5 && skillExp &lt;= 10) {
      expertiseStr = "senior developer";
    } else {
      expertiseStr = "junior developer";
    }

    return `${str0}${userExp}${str1}${expertiseStr}${str2}${skillExp}`;
}

var output1 = myInfoTag`Mr/Ms. ${user1} is a/an ${experience1} in ${skill1}`;
var output2 = myInfoTag`Mr/Ms. ${user2} is a/an ${experience2} in ${skill2}`;

console.log(output1); // Mr/Ms. John is a/an expert developer in JavaScript
console.log(output2); // Mr/Ms. Kane is a/an junior developer in JavaScript
                </pre>

                        <p>Подробнее модно почитать на <a href="https://habr.com/ru/companies/ruvds/articles/511590/"
                                                          target="_blank">Habr</a></p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment312">Что такое String.raw()</h4>

                    <div>
                        <p>ES6 предоставляет функцию необработанных строк с использованием метода String.raw(), который
                            используется
                            для получения необработанной строковой формы строк шаблона. Эта функция позволяет получить
                            доступ к
                            необработанным строкам в том виде, в котором они были введены, без обработки
                            escape-последовательностей.
                            Например, использование будет таким, как показано ниже:</p>

                        <pre>
let calculationString = String.raw`The sum of numbers is \n${
    1 + 2 + 3 + 4
}!`;
console.log(calculationString); // The sum of numbers is \n10!
                </pre>

                        <p>Если вы не используете необработанные строки, последовательность символов новой строки
                            будет обработана путем отображения вывода в нескольких строках:</p>

                        <pre>
let calculationString = `The sum of numbers is \n${1 + 2 + 3 + 4}!`;
console.log(calculationString);
// The sum of numbers is
// 10!
                </pre>

                        <p>Кроме того, свойство raw доступно для первого аргумента функции тега:</p>

                        <pre>
function tag(strings) {
    console.log(strings.raw[0]);
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment313">Что такое деструктуризация присваивания</h4>

                    <div>
                        <p>Присвоение деструктуризации — это выражение JavaScript, которое позволяет распаковывать
                            значения
                            из
                            массивов или свойства объектов в отдельные переменные. Давайте получим значения месяца из
                            массива,
                            используя деструктурирующее присваивание.</p>

                        <pre>
let [one, two, three] = ["JAN", "FEB", "MARCH"];

console.log(one); // "JAN"
console.log(two); // "FEB"
console.log(three); // "MARCH"
                </pre>

                        <p>и вы можете получить пользовательские свойства объекта, используя назначение
                            деструктуризации:</p>

                        <pre>
let { name, age } = { name: "John", age: 32 };

console.log(name); // John
console.log(age); // 32
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment314">Значения по умолчанию при назначении деструктуризации</h4>

                    <div>
                        <p>Переменной может быть присвоено значение по умолчанию, если значение, распакованное из
                            массива
                            или
                            объекта, не определено во время деструктурирующего присваивания. Это помогает избежать
                            установки
                            значений по умолчанию отдельно для каждого назначения. Давайте рассмотрим пример как для
                            массивов,
                            так и для случаев использования объектов:</p>
                        <p>Деструктуризация массивов:</p>

                        <pre>
var x, y, z;

[x = 2, y = 4, z = 6] = [10];
console.log(x); // 10
console.log(y); // 4
console.log(z); // 6
                </pre>

                        <p>Деструктуризация объектов:</p>

                        <pre>
let { x = 2, y = 4, z = 6 } = { x: 10 };

console.log(x); // 10
console.log(y); // 4
console.log(z); // 6
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment315">Как поменять местами переменные при деструктурировании
                        присваивания</h4>

                    <div>
                        <p>Если вы не используете деструктурирующее присваивание, для замены двух значений потребуется
                            временная
                            переменная. При использовании функции деструктуризации два значения переменных можно
                            поменять
                            местами в
                            одном выражении деструктуризации. Давайте поменяем местами две числовые переменные в
                            присваивании
                            деструктуризации массива:</p>

                        <pre>
var x = 10, y = 20;

[x, y] = [y, x];
console.log(x); // 20
console.log(y); // 10
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment316">Что такое расширенные литералы объектов</h4>

                    <div>
                        <p>Литералы объектов позволяют легко и быстро создавать объекты со свойствами внутри фигурных
                            скобок.
                            Например, он обеспечивает более короткий синтаксис для определения общих свойств объекта,
                            как
                            показано ниже.</p>

                        <pre>
//ES6
var x = 10, y = 20;
obj = { x, y };
console.log(obj); // {x: 10, y:20}
//ES5
var x = 10, y = 20;
obj = { x: x, y: y };
console.log(obj); // {x: 10, y:20}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment317">Что такое динамический импорт</h4>

                    <div>
                        <p>Динамический импорт с использованием синтаксиса функции import() позволяет нам загружать
                            модули
                            по
                            требованию, используя обещания или синтаксис async/await. В настоящее время эта функция
                            находится в
                            стадии предложения 4. Основным преимуществом динамического импорта является уменьшение
                            размеров
                            нашего пакета, ответа на размер/полезную нагрузку наших запросов и общее улучшение
                            пользовательского
                            опыта. Синтаксис динамического импорта будет выглядеть следующим образом:</p>

                        <pre>import("./Module").then((Module) => Module.method());</pre>

                        <p>Подробнее можно почитать на <a
                                href="https://learn.javascript.ru/modules-dynamic-imports?ysclid=lp37e3suuq686556051"
                                target="_blank">learn.javascript.ru</a></p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment318">Каковы варианты использования динамического импорта</h4>

                    <div>
                        <ol>
                            <li>
                                Импортируйте модуль по требованию или условно. Например, если вы хотите загрузить
                                полифилл в
                                устаревшем браузере:
                                <pre>
if (isLegacyBrowser()) {
    import(···)
      .then(···);
}
                        </pre>
                            </li>
                            <li>
                                Вычислите спецификатор модуля во время выполнения. Например, вы можете использовать его
                                для
                                интернационализации:
                                <pre>import(`messages_${getLocale()}.js`).then(···);</pre>
                            </li>
                            <li>Импортируйте модуль из обычного скрипта вместо модуля.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment319">Что такое типизированные массивы</h4>

                    <div>
                        <p>Типизированные массивы — это подобные массиву объекты из API ECMAScript 6 для обработки
                            двоичных данных. JavaScript предоставляет 8 типов типизированных массивов:</p>

                        <ol>
                            <li>Int8Array: массив 8-битных целых чисел со знаком.</li>
                            <li>Int16Array: массив 16-битных целых чисел со знаком.</li>
                            <li>Int32Array: массив 32-битных целых чисел со знаком.</li>
                            <li>Uint8Array: массив 8-битных целых чисел без знака.</li>
                            <li>Uint16Array: массив 16-битных целых чисел без знака.</li>
                            <li>Uint32Array: массив 32-битных целых чисел без знака.</li>
                            <li>Float32Array: An array of 32-bit floating point numbers</li>
                            <li>Float64Array: массив 64-битных чисел с плавающей запятой.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment320">В чем преимущества загрузчиков модулей</h4>

                    <div>
                        <p>Загрузчики модулей предоставляют следующие функции:</p>

                        <ol>
                            <li>Динамическая загрузка (Dynamic loading)</li>
                            <li>Изоляция состояния (State isolation)</li>
                            <li>Глобальная изоляция пространства имен (Global namespace isolation)</li>
                            <li>Хуки компиляции (Compilation hooks)</li>
                            <li>Вложенная виртуализация (Nested virtualization)</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment321">Что такое параметры сортировки</h4>

                    <div>
                        <p>Параметры сортировки используются для сортировки набора строк и поиска внутри набора строк.
                            Он
                            параметризуется локалью и поддерживает Unicode. Давайте возьмем функции сравнения и
                            сортировки:</p>

                        <ol>
                            <li>
                                Comparison(сравнение):
                                <pre>
let list = ["ä", "a", "z"]; // In German,  "ä" sorts with "a" Whereas in Swedish, "ä" sorts after "z"
let l10nDE = new Intl.Collator("de");
let l10nSV = new Intl.Collator("sv");
console.log(l10nDE.compare("ä", "z") === -1); // true
console.log(l10nSV.compare("ä", "z") === +1); // true
                        </pre>
                            </li>
                            <li>
                                Sorting(сортировка):
                                <pre>
let list = ["ä", "a", "z"]; // In German,  "ä" sorts with "a" Whereas in Swedish, "ä" sorts after "z"
let l10nDE = new Intl.Collator("de");
let l10nSV = new Intl.Collator("sv");
console.log(list.sort(l10nDE.compare)); // [ "a", "ä", "z" ]
console.log(list.sort(l10nSV.compare)); // [ "a", "z", "ä" ]
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment322">Что такое цикл for...of</h4>

                    <div>
                        <p>Оператор for...of создает цикл, перебирающий повторяемые объекты или элементы, такие как
                            встроенные
                            String, Array, объекты, подобные массиву (например, аргументы или NodeList), TypedArray,
                            Map,
                            Set и
                            определяемые пользователем итерации. Основное использование оператора for...of для массивов
                            будет таким, как показано ниже:</p>

                        <pre>
let arrayIterable = [10, 20, 30, 40, 50];

for (let value of arrayIterable) {
    value++;
    console.log(value); // 11 21 31 41 51
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment323">Каков вывод массива операторов распространения ниже?</h4>

                    <div>
                        <pre>[..."John Resig"];</pre>

                        <p>Выходные данные массива: ['J', 'o', 'h', 'n', '', 'R', 'e', 's', 'i', 'g']
                            Объяснение: Строка является итерируемым типом, и оператор spread внутри массива сопоставляет
                            каждый символ
                            итерируемого объекта с одним элементом. Следовательно, каждый символ строки становится
                            элементом
                            массива.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment324">Безопасно ли использовать PostMessage</h4>

                    <div>
                        <p>Да, postMessages можно считать очень безопасным, если программист/разработчик внимательно
                            проверяет
                            происхождение и источник приходящего сообщения. Но если вы попытаетесь отправить/получить
                            сообщение без
                            проверки его источника, это приведет к атакам с использованием межсайтовых сценариев.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment325">Какие существуют проблемы с целевым происхождением postmessage в
                        качестве<a
                                href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Wildcard">wildcard?</a>
                    </h4>

                    <div>
                        <p>Второй аргумент метода postMessage указывает, какому источнику разрешено получать сообщение.
                            Если
                            вы
                            используете подстановочный знак «*» в качестве аргумента, то любой источник может получить
                            сообщение. В
                            этом случае окно отправителя не может узнать, находится ли целевое окно в целевом источнике
                            при
                            отправке
                            сообщения. Если целевое окно было перенаправлено к другому источнику, другой источник
                            получит
                            данные.
                            Следовательно, это может привести к уязвимостям XSS.</p>

                        <pre>targetWindow.postMessage(message, "*");</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment326">Как избежать получения postMessage от злоумышленников</h4>

                    <div>
                        <p>Поскольку прослушиватель прослушивает любое сообщение, злоумышленник может обмануть
                            приложение,
                            отправив
                            сообщение из источника злоумышленника, что создает впечатление, что получатель получил
                            сообщение
                            из
                            фактического окна отправителя. Вы можете избежать этой проблемы, проверив происхождение
                            сообщения на
                            стороне получателя с помощью атрибута «message.origin». Для примера давайте проверим
                            происхождение
                            отправителя <a href="http://www.some-sender.com"
                                           target="_blank">http://www.some-sender.com</a>
                            на стороне получателя www.some-receiver.com:</p>

                        <pre>
//Listener on http://www.some-receiver.com/
window.addEventListener("message", function(message){
    if(/^http://www\.some-sender\.com$/.test(message.origin)){
        console.log('You received the data from valid sender', message.data);
    }
});
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment327">Можно ли полностью избежать использования postMessage?</h4>

                    <div>
                        <p>Вы не можете избежать использования postMessages полностью (или на 100%). Несмотря на то, что
                            ваше
                            приложение не использует postMessage, учитывая риски, многие сторонние скрипты используют
                            postMessage
                            для связи со сторонним сервисом. Таким образом, ваше приложение может использовать
                            postMessage
                            без
                            вашего ведома.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment328">Синхронен ли postMessages?</h4>

                    <div>
                        <p>Сообщения postMessage синхронны в браузере IE8, но они асинхронны в IE9 и всех других
                            современных
                            браузерах (например, IE9+, Firefox, Chrome, Safari). Из-за такого асинхронного поведения мы
                            используем
                            механизм обратного вызова при возврате сообщения postMessage.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment329">Какая парадигма представляет собой Javascript</h4>

                    <div>
                        <p>JavaScript — это мультипарадигмальный язык, поддерживающий императивное/процедурное
                            программирование,
                            объектно-ориентированное программирование и функциональное программирование. JavaScript
                            поддерживает
                            объектно-ориентированное программирование с прототипным наследованием.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment330">В чем разница между внутренним и внешним JavaScript</h4>

                    <div>
                        <p>Внутренний JavaScript: это исходный код внутри тега скрипта.<br>
                            Внешний JavaScript: исходный код хранится во внешнем файле (с расширением .js) и упоминается
                            в
                            теге.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment331">JavaScript быстрее, чем серверный скрипт?</h4>

                    <div>
                        <p>Да, JavaScript быстрее, чем серверные скрипты. Поскольку JavaScript является клиентским
                            скриптом,
                            для
                            его вычислений не требуется помощь какого-либо веб-сервера. Таким образом, JavaScript всегда
                            быстрее,
                            чем любой серверный скрипт, такой как ASP, PHP и т. д.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment332">Как узнать статус checkbox инпута</h4>

                    <div>
                        <p>Вы можете применить проверенное свойство к выбранному checkbox инпуту в DOM. Если значение
                            истинно,
                            это означает, что флажок установлен, в противном случае он снят. Например, к приведенному
                            ниже
                            элементу
                            checkbox HTML можно получить доступ с помощью JavaScript, как показано ниже:</p>

                        <pre>
&lt;input type="checkbox" id="checkboxname" value="Agree" &gt; // Agree the conditions

console.log(document.getElementById(‘checkboxname’).checked); // true or false
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment333">Какова цель оператора двойной тильды</h4>

                    <div>
                        <p>Оператор двойной тильды (~~) известен как побитовый оператор двойного НЕ. Этот оператор
                            является
                            немного более быстрой заменой Math.floor().</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment334">Как преобразовать символ в код ASCII</h4>

                    <div>
                        <p>Вы можете использовать метод String.prototype.charCodeAt() для преобразования строковых
                            символов
                            в числа
                            ASCII. Например, давайте найдем код ASCII для первой буквы строки ABC:</p>

                        <pre>"ABC".charCodeAt(0); // returns 65</pre>

                        <p>Тогда как метод String.fromCharCode() преобразует числа в эквивалентные символы ASCII.</p>

                        <pre>String.fromCharCode(65, 66, 67); // returns 'ABC'</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment335">Что такое ArrayBuffer</h4>

                    <div>
                        <p>Объект ArrayBuffer используется для представления универсального буфера необработанных
                            двоичных данных фиксированной длины. Вы можете создать его, как показано ниже:</p>

                        <pre>
let buffer = new ArrayBuffer(16); // create a buffer of length 16
alert(buffer.byteLength); // 16
                </pre>

                        <p>Чтобы манипулировать ArrayBuffer, нам нужно использовать объект “view”.</p>

                        <pre>
//Create a DataView referring to the buffer
let view = new DataView(buffer);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment336">Каков вывод приведенного ниже строкового выражения</h4>

                    <div>
                        <pre>console.log("Welcome to JS world"[0]);</pre>

                        <p>Результатом приведенного выше выражения является "W". Объяснение: Обозначение скобок с
                            определенным
                            индексом в строке возвращает символ в определенном месте. Следовательно, он возвращает
                            символ
                            «W»
                            строки. Поскольку это не поддерживается в версиях IE7 и ниже, вам может потребоваться
                            использовать
                            метод .charAt() для получения желаемого результата.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment337">Какова цель объекта Error</h4>

                    <div>
                        <p>Конструктор Error создает объект ошибки, и экземпляры объектов Error создаются при
                            возникновении
                            ошибок
                            во время выполнения. Объект Error также можно использовать в качестве базового объекта для
                            определяемых
                            пользователем исключений. Синтаксис объекта Error будет выглядеть следующим образом:</p>

                        <pre>new Error([message[, fileName[, lineNumber]]])</pre>

                        <p>Вы можете создавать определенные пользователем исключения или ошибки, используя объект
                            Error в блоке try...catch, как показано ниже:</p>

                        <pre>
try {
    if (withdraw > balance)
        throw new Error("Oops! You don't have enough balance");
} catch (err) {
    console.log(err.name + ": " + err.message);
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment338">Какова цель объекта EvalError</h4>

                    <div>
                        <p>Объект EvalError указывает на ошибку, связанную с глобальной функцией eval(). Несмотря на то,
                            что
                            это
                            исключение больше не генерируется JavaScript, объект EvalError остается для совместимости.
                            Синтаксис
                            этого выражения будет таким, как показано ниже:</p>

                        <pre>new EvalError([message[, fileName[, lineNumber]]])</pre>

                        <p>Вы можете использовать EvalError с помощью блока try...catch, как показано ниже:</p>

                        <pre>
try {
    throw new EvalError('Eval function error', 'someFile.js', 100);
} catch (e) {
    console.log(e.message, e.name, e.fileName); // "Eval function error", "EvalError", "someFile.js"
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment339">Каков список случаев ошибки, возникающей при переходе из
                        нестрогого режима(non-strict mode) в строгий режим(strict mode)?</h4>

                    <div>
                        <p>Когда вы применяете 'use strict'; синтаксис, в некоторых из приведенных ниже
                            случаев перед выполнением сценария будет выдана ошибка SyntaxError:</p>

                        <ol>
                            <li>
                                Когда вы используете восьмеричный синтаксис
                                <pre>var n = 022;</pre>
                            </li>
                            <li>Использование оператора with</li>
                            <li>Когда вы используете оператор delete для имени переменной</li>
                            <li>Использование eval или аргументов в качестве имени аргумента переменной или функции</li>
                            <li>Когда вы используете новые зарезервированные ключевые слова</li>
                            <li>
                                Когда вы объявляете функцию в блоке
                                <pre>
if (someCondition) {
    function f() {}
}
                        </pre>
                            </li>
                        </ol>
                        <p>Следовательно, ошибки из приведенных выше случаев помогают избежать ошибок в средах
                            разработки/производства.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment340">У всех ли объектов есть прототипы?</h4>

                    <div>
                        <p>Нет. У всех объектов есть прототипы, за исключением базового объекта, созданного
                            пользователем, или объекта, созданного с использованием ключевого слова new.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment341">В чем разница между параметром и аргументом</h4>

                    <div>
                        <p>Параметр — это имя переменной определения функции, тогда как аргумент представляет
                            значение, данное функции при ее вызове. Давайте объясним это с помощью простой функции:</p>

                        <pre>
function myFunction(parameter1, parameter2, parameter3) {
    console.log(arguments[0]); // "argument1"
    console.log(arguments[1]); // "argument2"
    console.log(arguments[2]); // "argument3"
}
myFunction("argument1", "argument2", "argument3");
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment342">Какова цель метода some() в массивах</h4>

                    <div>
                        <p>Метод some() используется для проверки того, проходит ли хотя бы один элемент массива тест,
                            реализованный
                            предоставленной функцией. Метод возвращает логическое значение. Давайте возьмем пример для
                            проверки
                            любых нечетных элементов:</p>

                        <pre>
const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

const odd = (element) => element % 2 !== 0;

console.log(array.some(odd)); // true (the odd element exists)
// console.log(array.some(el => el % 2 !== 0))
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment343">Как объединить два или более массива</h4>

                    <div>
                        <p>Метод concat() используется для объединения двух или более массивов путем возврата
                            нового массива, содержащего все элементы. Синтаксис будет таким, как показано ниже:</p>

                        <pre>array1.concat(array2, array3, ..., arrayX)</pre>

                        <p>Давайте рассмотрим пример объединения массива с массивами овощей и фруктов:</p>

                        <pre>
const veggies = ["Tomato", "Carrot", "Cabbage"];
const fruits = ["Apple", "Orange", "Pears"];
const veggiesAndFruits = veggies.concat(fruits);
console.log(veggiesAndFruits); // Tomato, Carrot, Cabbage, Apple, Orange, Pears
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment344">В чем разница между поверхностной и глубокой копией</h4>

                    <div>
                        <p>Есть два способа скопировать объект:</p>
                        <p>Неглубокая копия: Неглубокая копия — это побитовая копия объекта. Создается новый объект,
                            имеющий
                            точную
                            копию значений исходного объекта. Если какое-либо из полей объекта является ссылкой на
                            другие
                            объекты,
                            копируются только адреса ссылок, т. е. копируется только адрес памяти. Пример:</p>

                        <pre>
const empDetails = {
    name: "John",
    age: 25,
    expertise: "Software Developer",
};

// to create a duplicate

const empDetailsShallowCopy = empDetails; //Shallow copying!
                </pre>

                        <p>если мы изменим какое-либо значение свойства в дубликате следующим образом:</p>

                        <pre>empDetailsShallowCopy.name = "Johnson";</pre>

                        <p>Приведенный выше оператор также изменит имя empDetails, поскольку у нас есть неполная копия.
                            Это означает, что мы также теряем исходные данные.</p>
                        <p>Глубокое копирование: При глубоком копировании копируются все поля и создаются копии
                            динамически
                            выделяемой памяти, на которую указывают поля. Глубокое копирование происходит, когда объект
                            копируется
                            вместе с объектами, на которые он ссылается. Пример:</p>

                        <pre>
const empDetails = {
    name: "John",
    age: 25,
    expertise: "Software Developer",
};

//Create a deep copy by using the properties from the original object into new variable

const empDetailsDeepCopy = {
    name: empDetails.name,
    age: empDetails.age,
    expertise: empDetails.expertise,
};
                </pre>

                        <p>Теперь, если вы измените empDetailsDeepCopy.name, это повлияет только на
                            empDetailsDeepCopy, а не на empDetails.</p>
                        <p>Так же существует метод <a
                                href="https://learn.javascript.ru/object-copy?ysclid=lp5qqx56pd185065270"
                                target="_blank">Object.assign(dest, [src1, src2, src3...])</a></p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment345">Как создать определенное количество копий строки</h4>

                    <div>
                        <p>Метод repeat() используется для создания и возврата новой строки, содержащей указанное
                            количество
                            копий строки, из которой он был вызван, объединенных вместе. Помните, что этот метод был
                            добавлен в
                            спецификацию ECMAScript 2015. Давайте возьмем пример строки Hello и повторим ее 4 раза:</p>

                        <pre>"Hello".repeat(4); // 'HelloHelloHelloHello'</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment346">Как вернуть все совпадающие строки по регулярному выражению</h4>

                    <div>
                        <p>Метод matchAll() можно использовать для возврата итератора всех результатов, соответствующих
                            строке
                            регулярному выражению. Например, приведенный ниже пример возвращает массив совпадающих
                            строковых
                            результатов по регулярному выражению:</p>

                        <pre>
let regexp = /Hello(\d?))/g;
let greeting = "Hello1Hello2Hello3";

let greetingList = [...greeting.matchAll(regexp)];

console.log(greetingList[0]); //Hello1
console.log(greetingList[1]); //Hello2
console.log(greetingList[2]); //Hello3
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment347">Как обрезать строку в начале или конце?</h4>

                    <div>
                        <p>Метод trim() прототипа строки используется для обрезки строки с обеих сторон. Но если вы
                            хотите
                            обрезать
                            особенно начало или конец строки, вы можете использовать методы TrimStart/trimLeft и
                            TrimEnd/TrimRight.
                            Давайте посмотрим пример этих методов в приветственном сообщении:</p>

                        <pre>
let greeting = " Hello, Goodmorning! ";

console.log(greeting); // " Hello, Goodmorning! "
console.log(greeting.trimStart()); // "Hello, Goodmorning! "
console.log(greeting.trimLeft()); // "Hello, Goodmorning! "

console.log(greeting.trimEnd()); // "   Hello, Goodmorning!"
console.log(greeting.trimRight()); // "   Hello, Goodmorning!"

console.log(greeting.trim()); // "Hello, Goodmorning!"
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment348">Каков вывод приведенного ниже оператора консоли с унарным
                        оператором?</h4>

                    <div>
                        <p>Давайте возьмем оператор консоли с унарным оператором, как показано ниже:</p>

                        <pre>console.log(+"Hello");</pre>

                        <p>Вывод приведенного выше оператора журнала консоли возвращает NaN. Поскольку элемент имеет
                            префикс
                            унарного оператора, и интерпретатор JavaScript попытается преобразовать этот элемент в
                            числовой
                            тип.
                            Поскольку преобразование завершается неудачей, значение оператора приводит к значению
                            NaN.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment349">Использует ли JavaScript миксины(примеси)?</h4>

                    <div>
                        <p>Mixin — это общий термин объектно-ориентированного программирования — это класс, содержащий
                            методы,
                            которые могут использоваться другими классами без необходимости наследования от него. В
                            JavaScript мы
                            можем наследовать только один объект. то есть. У объекта может быть только один
                            [[прототип]].</p>
                        <p>Но иногда нам требуется расширить более одного класса. Чтобы решить эту проблему, мы можем
                            использовать
                            Mixin, который помогает скопировать методы в прототип другого класса.</p>
                        <p>Скажем, у нас есть два класса User и CleanRoom. Предположим, нам нужно добавить
                            функциональность
                            CleanRoom в User, чтобы пользователь мог убирать комнату по требованию. Вот тут-то и
                            появляется
                            концепция миксинов.</p>

                        <pre>
// mixin
let cleanRoomMixin = {
    cleanRoom() {
        alert(`Hello ${this.name}, your room is clean now`);
    },
    sayBye() {
        alert(`Bye ${this.name}`);
    },
};

// usage:
class User {
    constructor(name) {
      this.name = name;
    }
}

// copy the methods
Object.assign(User.prototype, cleanRoomMixin);

// now User can clean the room
new User("Dude").cleanRoom(); // Hello Dude, your room is clean now!
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment350">Что такое функция thunk</h4>

                    <div>
                        <p>Thunk — это просто функция, которая задерживает вычисление значения. Он не принимает никаких
                            аргументов,
                            но возвращает значение всякий раз, когда вы вызываете thunk. т. е. он используется не для
                            выполнения сейчас, а для выполнения когда-нибудь в будущем. Возьмем синхронный пример:</p>

                        <pre>
const add = (x, y) => x + y;

const thunk = () => add(2, 3);

thunk(); // 5
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment351">Что такое асинхронный thunk</h4>

                    <div>
                        <p>Асинхронный thunk полезен для выполнения сетевых запросов. Давайте посмотрим
                            пример сетевых запросов:</p>

                        <pre>
function fetchData(fn) {
    fetch("https://jsonplaceholder.typicode.com/todos/1")
      .then((response) => response.json())
      .then((json) => fn(json));
}

const asyncThunk = function () {
    return fetchData(function getData(data) {
      console.log(data);
    });
};

asyncThunk();
                </pre>

                        <p>Функция getData не будет вызываться немедленно, а будет вызвана только тогда, когда данные
                            станут
                            доступны из конечной точки API. Функция setTimeout также используется для асинхронности
                            нашего
                            кода. Лучшим примером реального времени является библиотека управления состоянием Redux,
                            которая
                            использует asyncThunk для задержки отправки действий.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment352">Каков результат следующих вызовов функций?</h4>

                    <div>
                        <p>Фрагмент кода:</p>

                        <pre>
const circle = {
    radius: 20,
    diameter() {
      return this.radius * 2;
    },
    perimeter: () => 2 * Math.PI * this.radius,
};

console.log(circle.diameter());
console.log(circle.perimeter());
                </pre>

                        <p>Вывод:</p>
                        <p>Вывод — 40 и NaN. Помните, что diameter — это регулярная функция, тогда как значение
                            perimeter —
                            стрелочная функция. Ключевое слово this обычной функции (т. е. diameter) относится к
                            окружающей
                            области, которая является классом (т. е. объектом circle). Принимая во внимание, что это
                            ключевое слово
                            функции perimeter относится к окружающей области, которая является объектом window.
                            Поскольку у
                            объекта
                            window нет свойства радиуса, оно возвращает undefined значение, а значение, кратное числу,
                            возвращает
                            значение NaN.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment353">Как удалить все разрывы строк из строки</h4>

                    <div>
                        <p>Самый простой подход — использовать регулярные выражения для обнаружения и замены символов
                            новой
                            строки в
                            строке. В этом случае мы используем функцию replace вместе со строкой для замены, которая в
                            нашем случае
                            является пустой строкой.</p>

                        <pre>
function remove_linebreaks( var message ) {
    return message.replace( /[\r\n]+/gm, "" );
}
                </pre>

                        <p>В приведенном выше выражении g и m относятся к глобальным и многострочным флагам.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment354">В чем разница между reflow и repaint</h4>

                    <div>
                        <p>Перерисовка(repaint) происходит, когда вносятся изменения, которые влияют на видимость
                            элемента,
                            но не на его
                            макет. Примеры этого включают контур, видимость или цвет фона. Перекомпоновка(reflow)
                            включает в
                            себя
                            изменения, которые влияют на макет части страницы (или всей страницы). Изменение размера
                            окна
                            браузера,
                            изменение шрифта, изменение содержимого (например, ввод текста пользователем), использование
                            методов
                            JavaScript, включающих вычисляемые стили, добавление или удаление элементов из DOM и
                            изменение
                            классов
                            элементов — вот лишь некоторые из вещей, которые могут вызвать перекомпоновку.
                            Перекомпоновка(reflow)
                            элемента вызывает последующую перекомпоновку всех дочерних и родительских элементов, а также
                            любых элементов,
                            следующих за ним в DOM.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment355">Что происходит при отрицании(!) массива</h4>

                    <div>
                        <p>Отрицание массива с помощью ! символ преобразует массив в логическое значение.
                            Поскольку массивы считаются правдивыми, отрицание возвращает false.</p>

                        <pre>console.log(![]); // false</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment356">Что произойдет, если мы добавим два массива</h4>

                    <div>
                        <p>Если вы добавите два массива вместе, они преобразуются в строки и объединятся.
                            Например, результат добавления массивов будет таким, как показано ниже:</p>

                        <pre>
console.log(["a"] + ["b"]); // "ab"
console.log([] + []); // ""
console.log(![] + []); // "false", because ![] returns false.
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment357">Каков результат операции добавления аддитивного оператора(+) к
                        ложным значениям?</h4>

                    <div>
                        <p>Если вы добавляете оператор добавления (+) к ложным значениям (нуль, undefined, NaN, false,
                            ""),
                            ложное значение преобразуется в нулевое числовое значение. Давайте отобразим их в консоли
                            браузера, как показано ниже:</p>

                        <pre>
console.log(+null); // 0
console.log(+undefined); // NaN
console.log(+false); // 0
console.log(+NaN); // NaN
console.log(+""); // 0
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment358">Как создать собственную строку, используя специальные символы</h4>

                    <div>
                        <p>Собственная строка может быть сформирована из комбинации символов []()!+.
                            Чтобы достичь этого шаблона, вам необходимо запомнить следующие паттерны:</p>

                        <ol>
                            <li>Поскольку массивы являются истинными значениями, отрицание массивов
                                приведет к ложному результату: ![] === false
                            </li>
                            <li>Согласно правилам приведения JavaScript, сложение массивов приведет
                                к их типу string: [] + [] === ""
                            </li>
                            <li>Добавление массива в начало с помощью оператора + преобразует массив в false, отрицание
                                сделает
                                его истинным, и, наконец, преобразование результата даст значение '1': +(!(+[])) === 1
                            </li>
                        </ol>

                        <p>Применяя приведенные выше правила, мы можем получить следующие условия:</p>

                        <pre>(![] + [] === "false" + !+[]) === 1;</pre>

                        <p>Теперь образец символа будет создан, как показано ниже:</p>

                        <pre>
      s               e               l               f
^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^

(![] + [])[3] + (![] + [])[4] + (![] + [])[2] + (![] + [])[0]
^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^
(![] + [])[+!+[]+!+[]+!+[]] +
(![] + [])[+!+[]+!+[]+!+[]+!+[]] +
(![] + [])[+!+[]+!+[]] +
(![] + [])[+[]]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

(![]+[])[+!+[]+!+[]+!+[]]+(![]+[])[+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+!+[]+!+[]]+(![]+[])[+[]]
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment359">Как удалить ложные значения из массива</h4>

                    <div>
                        <p>Вы можете применить метод filter() к массиву, передав логическое значение в качестве
                            параметра.
                            Таким образом, он удаляет из массива все ложные значения (0, undefined, null, false и
                            ""):</p>

                        <pre>
const myArray = [false, null, 1, 5, undefined];
myArray.filter(Boolean); // [1, 5] // is same as myArray.filter(x => x);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment360">Как получить уникальные значения массива</h4>

                    <div>
                        <p>Вы можете получить уникальные значения массива с помощью комбинации синтаксиса Set и
                            rest/spread
                            выражения (...).</p>

                        <pre>console.log([...new Set([1, 2, 4, 4, 3])]); // [1, 2, 4, 3]</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment361">Что такое деструктуризация псевдонимов</h4>

                    <div>
                        <p>Иногда вам может понадобиться деструктурированная переменная с именем, отличным от имени
                            свойства. В этом
                            случае вы будете использовать "value : newName", чтобы указать имя переменной. Этот процесс
                            называется
                            деструктуризацией псевдонимов.</p>

                        <pre>
const obj = { x: 1 };
// Grabs obj.x as { otherName }
const { x: otherName } = obj;
console.log(otherName) // 1
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment362">Напишите полифил метода map для массивов(Как мэппизировать
                        значения массива без использования map метода)</h4>

                    <div>
                        <p>Вы можете сопоставить(мэппизировать) значения массива без использования метода map, просто
                            используя
                            метод Array.from(). Давайте сопоставим названия городов из массива Countries:</p>

                        <pre>
const countries = [
    { name: "India", capital: "Delhi" },
    { name: "US", capital: "Washington" },
    { name: "Russia", capital: "Moscow" },
    { name: "Singapore", capital: "Singapore" },
    { name: "China", capital: "Beijing" },
    { name: "France", capital: "Paris" },
];

const cityNames = Array.from(countries, ({ capital }) => capital);
console.log(cityNames); // ['Delhi, 'Washington', 'Moscow', 'Singapore', 'Beijing', 'Paris']
                </pre>

                        <p>Подробнее про Array.from() можно почитать на
                            <a href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/from"
                               target="_blank">MDN</a>
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment363">Как очистить массив</h4>

                    <div>
                        <p>Вы можете быстро очистить массив, установив длину массива равной нулю.</p>

                        <pre>
let cities = ["Singapore", "Delhi", "London"];
cities.length = 0; // cities becomes []
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment364">Как округлить числа до определенных десятичных знаков?</h4>

                    <div>
                        <p>Вы можете округлять числа до определенного количества десятичных знаков, используя метод
                            toFixed
                            из встроенного JavaScript.</p>

                        <pre>
let pie = 3.141592653;
pie = pie.toFixed(3); // 3.142
                </pre>

                        <p>Math.round() округляет до ближайшего ЦЕЛОГО числа!!!</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment365">Как проще всего преобразовать массив в объект?</h4>

                    <div>
                        <p>Вы можете преобразовать массив в объект с теми же данными, используя оператор
                            spread(...).</p>

                        <pre>
let  fruits = ["banana", "apple", "orange", "watermelon"];
let fruitsObject = { ...fruits };
console.log(fruitsObject); // {0: "banana", 1: "apple", 2: "orange", 3: "watermelon"}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment366">Как создать массив с данными</h4>

                    <div>
                        <p>Вы можете создать массив с данными или массив с теми же значениями, используя метод fill.</p>

                        <pre>
let newArray = new Array(5).fill("0");
console.log(newArray); // ["0", "0", "0", "0", "0"]
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment367">Что такое заполнители(placeholders) из объекта console</h4>

                    <div>
                        <p>Ниже приведен список заполнителей(placeholders), доступных из объекта console.</p>

                        <ol>
                            <li>%o — принимает объект</li>
                            <li>%s — принимает строку</li>
                            <li>
                                %d — используется для десятичных или целых чисел. Эти заполнители могут
                                быть представлены в console.log, как показано ниже.

                                <pre>
const user = { name: "John", id: 1, city: "Delhi" };
console.log(
    "Hello %s, your details %o are available in the object form",
    "John",
    user
); // Hello John, your details {name: "John", id: 1, city: "Delhi"} are available in object
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment368">Можно ли добавить CSS в сообщения консоли?</h4>

                    <div>
                        <p>Да, вы можете применять стили CSS к сообщениям консоли, похожим на текст HTML на
                            веб-странице.</p>

                        <pre>
console.log(
    "%c The text has blue color, with large font and red background",
    "color: blue; font-size: x-large; background: red"
);
                </pre>

                        <p>Текст будет отображаться, как показано ниже:</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/console-css.png" alt="console-css">
                        </div>

                        <p>Примечание: К сообщениям консоли можно применять все стили CSS.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment369">Какова цель метода dir объекта console</h4>

                    <div>
                        <p>console.dir() используется для отображения интерактивного списка свойств
                            указанного объекта JavaScript в формате JSON.</p>

                        <pre>
const user = { name: "John", id: 1, city: "Delhi" };
console.dir(user);
                </pre>

                        <p>Объект user, отображаемый в представлении JSON:</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/console-dir.png" alt="console-dir">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment370">Можно ли отлаживать HTML-элементы в консоли?</h4>

                    <div>
                        <p>Да, HTML-элементы можно получать и отлаживать в консоли точно так же, как и при проверке
                            элементов.</p>

                        <pre>
const element = document.getElementsByTagName("body")[0];
console.log(element);
                        </pre>

                        <p>Элемент HTML печатается в консоли:</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/console-html.png" alt="console-html">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment371">Как отображать данные в табличном формате с помощью объекта
                        console?</h4>

                    <div>
                        <p>console.table() используется для отображения данных в консоли в табличном
                            формате для визуализации сложных массивов или объектов:</p>

                        <pre>
const users = [
    { name: "John", id: 1, city: "Delhi" },
    { name: "Max", id: 2, city: "London" },
    { name: "Rod", id: 3, city: "Paris" },
];
console.table(users);
                </pre>

                        <p>Данные визуализируются в виде таблицы:</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/console-table.png" alt="console-table">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment372">Как проверить, является ли аргумент числом или нет?</h4>

                    <div>
                        <p>Комбинация методов IsNaN и isFinite используется для подтверждения того, является ли аргумент
                            числом или нет.</p>

                        <pre>
function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment373">Как создать кнопку "Копировать в буфер обмена"</h4>

                    <div>
                        <p>Вам необходимо выбрать содержимое (с помощью метода .select()) входного элемента и выполнить
                            команду
                            копирования с помощью execCommand (т. е. execCommand('copy')). Вы также можете выполнять
                            другие
                            системные команды, такие как cut и paste:</p>
                        <p>DEPRECATED!!!</p>
                        <pre>
document.querySelector("#copy-button").onclick = function () {
    // Select the content
    document.querySelector("#copy-input").select();
    // Copy to the clipboard
    document.execCommand("copy");
};
                </pre>

                        <p>Подробнее об execCommand можно почитать на <a
                                href="https://developer.mozilla.org/ru/docs/Web/API/Document/execCommand"
                                target="_blank">MDN</a>
                        </p>
                        <p>На данный момент существует "navigator.clipboard.writeText(someText).then()"</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment374">Какой ярлык позволяет получить текущую дату</h4>

                    <div>
                        <p>Вы можете использовать new Date().getTime(), чтобы получить текущую дату.
                            Существует альтернативный способ получить значение.</p>

                        <pre>
console.log(+new Date());
console.log(Date.now());
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment375">Как вы выравниваете многомерные массивы?</h4>

                    <div>
                        <p>Сглаживание двумерных массивов с помощью оператора Spread выполняется тривиально.</p>

                        <pre>
const biDimensionalArr = [11, [22, 33], [44, 55], [66, 77], 88, 99];
const flattenArr = [].concat(...biDimensionalArr); // [11, 22, 33, 44, 55, 66, 77, 88, 99]
                </pre>

                        <p>Но вы можете конвертировать многомерные массивы с помощью рекурсивных вызовов:</p>

                        <pre>
function flattenMultiArray(arr) {
    const flattened = [].concat(...arr);
    return flattened.some((item) => Array.isArray(item))
       ? flattenMultiArray(flattened)
       : flattened;
}
const multiDimensionalArr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];
const flatArr = flattenMultiArray(multiDimensionalArr); // [11, 22, 33, 44, 55, 66, 77, 88, 99]

//или так
function flatFunc(arr) {
    let flattedArr = [];
    arr.forEach(item => {
        if (Array.isArray(item)) {
            flattedArr = flattedArr.concat(flatFunc(item));
        } else {
            flattedArr.push(item);
        }
    })
    return flattedArr;
}
                </pre>

                        <p>Также вы можете использовать метод Array.flat():</p>

                        <pre>
const arr = [1, [2, 3], 4, 5, [6, 7]];
const fllattenArr = arr.flat(); // [1, 2, 3, 4, 5, 6, 7]

// And for multiDemensional arrays
const multiDimensionalArr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];
const oneStepFlat = multiDimensionalArr.flat(1); // [11, 22, 33, 44, [55, 66, [77, [88]], 99]]
const towStep = multiDimensionalArr.flat(2); // [11, 22, 33, 44, 55, 66, [77, [88]], 99]
const fullyFlatArray = multiDimensionalArr.flat(Infinity); // [11, 22, 33, 44, 55, 66, 77, 88, 99]
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment376">Какая самая простая проверка нескольких условий?</h4>

                    <div>
                        <p>Вы можете использовать indexOf для сравнения входных данных с несколькими значениями
                            вместо проверки каждого значения как одного условия.</p>

                        <pre>
// Verbose approach
if (
    input === "first" ||
    input === 1 ||
    input === "second" ||
    input === 2
) {
    someFunction();
}

// Shortcut
if (["first", 1, "second", 2].indexOf(input) !== -1) {
    someFunction();
}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment377">Как активировать кнопку возврата браузера(не щелкая по ней в самом
                        браузере)</h4>

                    <div>
                        <p>Событие beforeunload срабатывает, когда window, document и его ресурсы собираются
                            выгрузиться.
                            Это
                            событие полезно для предупреждения пользователей о потере текущих данных и обнаружения
                            события
                            кнопки
                            «Назад».</p>

                        <pre>
window.addEventListener('beforeunload', () => {
    console.log('Clicked browser back button');
});
                </pre>

                        <p>Вы также можете использовать событие popstate для обнаружения кнопки возврата браузера.
                            Примечание: Запись истории была активирована с помощью метода History.pushState.</p>

                        <pre>
window.addEventListener('popstate', () => {
    console.log('Clicked browser back button');
    box.style.backgroundColor = 'white';
});

const box = document.getElementById('div');

box.addEventListener('click', () => {
    box.style.backgroundColor = 'blue';
    window.history.pushState({}, null, null);
});
                </pre>

                        <p>В приведенном выше коде при щелчке по элементу поля цвет его фона отображается синим цветом
                            и меняется на цвет while при нажатии кнопки возврата браузера с использованием обработчика
                            событий popstate. Свойство `state` `popstate` содержит копию состояния объекта записи
                            истории.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment378">Как отключить щелчок правой кнопкой мыши на веб-странице</h4>

                    <div>
                        <p>Щелчок правой кнопкой мыши на странице можно отключить, вернув false из
                            атрибута
                            oncontextmenu элемента body.</p>

                        <pre>&lt;body oncontextmenu="return false;"&gt;&lt;/body&gt;</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment379">Что такое объекты-обертки</h4>

                    <div>
                        <p>Примитивные значения, такие как строка, число и логическое значение, не имеют свойств и
                            методов,
                            но они
                            временно преобразуются или принуждаются к объекту (объекту-оболочке), когда вы пытаетесь
                            выполнить
                            над ними действия. Например, если вы примените метод toUpperCase() к примитивному строковому
                            значению,
                            он не выдаст ошибку, а вернет строку в верхнем регистре.</p>

                        <pre>
let name = "john";

console.log(name.toUpperCase()); // Behind the scenes treated as console.log(new String(name).toUpperCase());
                </pre>

                        <p>Т.е. каждый примитив, кроме null и undefined, имеет объекты-оболочки, а список
                            объектов-оболочек представляет собой String, Number, Boolean, Symbol and BigInt.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment380">Что такое AJAX(асинхронный JS и XML)</h4>

                    <div>
                        <p>AJAX означает асинхронный JavaScript и XML и представляет собой группу связанных технологий
                            (HTML, CSS,
                            JavaScript, XMLHttpRequest API и т. д.), используемых для асинхронного отображения данных.
                            т. е.
                            мы можем отправлять данные на сервер и получать данные с сервера без перезагрузки
                            веб-страницы.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment381">Какие есть способы работы с асинхронным кодом</h4>

                    <div>
                        <p>Ниже приведен список различных способов работы с асинхронным кодом:</p>
                        <ol>
                            <li>Callbacks</li>
                            <li>Promises</li>
                            <li>Async/await</li>
                            <li>Сторонние библиотеки, такие как async.js, bluebird и т. д.</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment382">Как отменить fetch запрос</h4>

                    <div>
                        <p>Еще несколько дней назад одним из недостатков встроенных промисов было отсутствие прямого
                            способа
                            отменить fetch запрос. Но новый AbortController из спецификации js позволяет вам
                            использовать
                            { signal } для прерывания одного или нескольких fetch вызовов. Основной процесс отмены fetch
                            запроса будет выглядеть следующим образом:</p>

                        <ol>
                            <li>Создайте экземпляр AbortController</li>
                            <li>Получите свойство signal экземпляра и передайте его в качестве опции выборки для signal.
                            </li>
                            <li>
                                Вызовите свойство abort из AbortController, чтобы отменить все выборки, использующие
                                этот
                                signal.
                                Например, давайте передадим один и тот же signal нескольким fetch вызовам, которые
                                отменят
                                все
                                запросы с этим signal.
                            </li>
                        </ol>

                        <pre>
const controller = new AbortController();
const { signal } = controller;

fetch("http://localhost:8000", { signal })
   .then((response) => {
     console.log(`Request 1 is complete!`);
   })
   .catch((e) => {
     if (e.name === "AbortError") {
       // We know it's been canceled!
     }
   });

fetch("http://localhost:8000", { signal })
   .then((response) => {
     console.log(`Request 2 is complete!`);
   })
   .catch((e) => {
     if (e.name === "AbortError") {
       // We know it's been canceled!
     }
   });

// Wait 2 seconds to abort both requests
setTimeout(() => controller.abort(), 2000);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment383">Что такое web speech API</h4>

                    <div>
                        <p>Web speech API используется для того, чтобы современные браузеры могли распознавать и
                            синтезировать речь
                            (т. е. голосовые данные в веб-приложениях). Этот API был представлен сообществом W3C в 2012
                            году. Он
                            состоит из двух основных частей:</p>

                        <ol>
                            <li>
                                SpeechRecognition (асинхронное распознавание речи или преобразование речи в текст): оно
                                обеспечивает возможность распознавать голосовой контекст из аудиовхода и реагировать
                                соответствующим образом. Доступ к нему осуществляется через интерфейс SpeechRecognition.
                                В приведенном ниже примере показано, как использовать этот API для получения текста из
                                речи.
                                <pre>
window.SpeechRecognition =
   window.webkitSpeechRecognition || window.SpeechRecognition; // webkitSpeechRecognition for Chrome and SpeechRecognition for FF
const recognition = new window.SpeechRecognition();
recognition.onresult = (event) => {
    // SpeechRecognitionEvent type
    const speechToText = event.results[0][0].transcript;
    console.log(speechToText);
};
recognition.start();
                        </pre>
                                <p>В этом API браузер запросит у вас разрешение на использование микрофона.</p>
                            </li>
                            <li>
                                SpeechSynthesis (преобразование текста в речь): обеспечивает возможность распознавать
                                голосовой контекст из аудиовхода и реагировать. Доступ к нему осуществляется через
                                интерфейс
                                SpeechSynthesis. Например, приведенный ниже код используется для получения голоса/речи
                                из текста:

                                <pre>
if ("speechSynthesis" in window) {
    let speech = new SpeechSynthesisUtterance("Hello World!");
    speech.lang = "en-US";
    window.speechSynthesis.speak(speech);
}
                        </pre>

                                Приведенные выше примеры можно протестировать в консоли разработчика браузера Chrome
                                (33+).
                                Примечание. Этот API все еще является рабочим проектом и доступен только в браузерах
                                Chrome и Firefox (конечно, Chrome реализовал только эту спецификацию).
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment384">Что такое регулирование минимального таймаута(minimum timeout
                        throttling)</h4>

                    <div>
                        <p>И браузер, и среда JavaScript NodeJS регулируют минимальную задержку, превышающую 0 мс. Это
                            означает, что
                            установка задержки в 0 мс не произойдет мгновенно. Браузеры: у них минимальная задержка 4
                            мс.
                            Это регулирование происходит, когда запускаются последовательные вызовы из-за вложенности
                            обратных
                            вызовов (определенной глубины) или после определенного количества последовательных
                            интервалов.
                            Примечание. В старых браузерах минимальная задержка составляет 10 мс. Nodejs: у них
                            минимальная
                            задержка 1 мс.
                            Это регулирование происходит, когда задержка превышает 2147483647 или меньше 1. Лучшим
                            примером,
                            объясняющим такое поведение регулирования тайм-аута, является приведенный ниже фрагмент
                            кода.</p>

                        <pre>
function runMeFirst() {
    console.log("My script is initialized");
}
setTimeout(runMeFirst, 0);
console.log("Script loaded");

//and the output would be in(вывод в консоли будет в следующей последовательности)

Script loaded
My script is initialized
                </pre>

                        <p>Если вы не используете setTimeout, порядок будет последовательным.</p>

                        <pre>
function runMeFirst() {
    console.log("My script is initialized");
}
runMeFirst();
console.log("Script loaded");

//output(вывод в консоли)

My script is initialized
Script loaded
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment385">Как реализовать нулевой таймаут в современных браузерах</h4>

                    <div>
                        <p>Вы не можете использовать setTimeout(fn, 0) для немедленного выполнения кода из-за
                            минимальной
                            задержки
                            более 0 мс. Но вы можете использовать window.postMessage() для достижения такого
                            поведения.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment386">Что такое задачи в цикле событий</h4>

                    <div>
                        <p>Задача — это любой код/программа Javascript, запуск которого запланирован с помощью
                            стандартных
                            механизмов, таких как первоначальный запуск программы, запуск обратного вызова события или
                            запуск интервала или тайм-аута. Все эти задачи планируются в очереди задач. Ниже приведен
                            список
                            вариантов использования для добавления задач в очередь задач.</p>

                        <ol>
                            <li>
                                Когда новая программа javascript запускается непосредственно из консоли или
                                с помощью элемента <code>&lt;script&gt;</code>, задача будет добавлена в очередь задач.
                            </li>
                            <li>При возникновении события, обратный вызов события добавляется в очередь задач.</li>
                            <li>При достижении setTimeout или setInterval соответствующий обратный вызов добавляется в
                                очередь задач.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment387">Что такое микрозадача</h4>

                    <div>
                        <p>Микрозадача — это код JavaScript, который необходимо выполнить сразу после завершения текущей
                            задачи/микрозадачи. Они носят своего рода блокирующий характер. т. е. основной поток будет
                            заблокирован
                            до тех пор, пока очередь микрозадач не станет пустой. Основными источниками микрозадач
                            являются
                            Promise.resolve, Promise.reject, MutationObservers, IntersectionObservers и т. д.</p>
                        <p>Примечание: Все эти микрозадачи обрабатываются в одном и том же цикле событий.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment388">Что такое разные циклы событий</h4>

                    <div>
                        <p>В JavaScript существует несколько циклов событий, которые можно использовать в зависимости
                            от контекста вашего приложения. Наиболее распространенные циклы событий:</p>

                        <ol>
                            <li>Цикл событий браузера</li>
                            <li>Цикл событий Node.js</li>
                        </ol>

                        <p>Цикл событий браузера: цикл событий браузера используется в клиентских приложениях JavaScript
                            и
                            отвечает за обработку событий, происходящих в среде браузера, таких как взаимодействие с
                            пользователем
                            (клики, нажатия клавиш и т. д.), HTTP-запросы и другие асинхронные действия.</p>
                        <p>Цикл событий Node.js используется в серверных приложениях JavaScript и отвечает за обработку
                            событий,
                            происходящих в среде выполнения Node.js, таких как файловый ввод-вывод, сетевой ввод-вывод и
                            другие
                            асинхронные действия.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment389">Какова цель queueMicrotask</h4>

                    <div>
                        <p>Функция queueMicrotask используется для планирования микрозадачи, которая представляет собой
                            функцию,
                            которая будет выполняться асинхронно в очереди микрозадач. Цель queueMicrotask —
                            гарантировать
                            выполнение
                            функции после завершения текущей задачи, но до того, как браузер выполнит какой-либо
                            рендеринг
                            или
                            обработает пользовательские события.</p>

                        <pre>
//queueMicrotask example

console.log("Start"); //1

queueMicrotask(() => {
    console.log("Inside microtask"); // 3
});

console.log("End"); //2
                </pre>

                        <p>Используя queueMicrotask, вы можете гарантировать, что определенные задачи или обратные
                            вызовы
                            будут
                            выполняться при первой возможности во время цикла событий JavaScript, что делает его
                            полезным
                            для
                            выполнения работы, которую необходимо выполнять асинхронно, но с более высоким приоритетом,
                            чем
                            обычные обратные вызовы setTimeout или setInterval.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment390">Как использовать библиотеки JavaScript в typescript файле?</h4>

                    <div>
                        <p>Известно, что не все библиотеки или фреймворки JavaScript имеют файлы объявлений TypeScript.
                            Но
                            если вы
                            по-прежнему хотите использовать библиотеки или платформы в наших файлах TypeScript, не
                            получая
                            ошибок
                            компиляции, единственным решением является объявление ключевого слова вместе с объявлением
                            переменной.
                            Например, предположим, что у вас есть библиотека customLibrary, которая не имеет объявления
                            TypeScript и
                            имеет пространство имен customLibrary в глобальном пространстве имен. Вы можете использовать
                            эту
                            библиотеку в typescript коде, как показано ниже:</p>

                        <pre>declare var customLibrary;</pre>

                        <p>Во время выполнения typescript предоставит тип переменной customLibrary как тип any.
                            Другая альтернатива без использования ключевого слова объявления приведена ниже.</p>

                        <pre>let customLibrary: any;</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment391">В чем разница между promise и observable</h4>

                    <div>
                        <p>Что вообще такое observable можно почитать на <a href="https://habr.com/ru/articles/568064/"
                                                                            target="_blank">Habr</a></p>
                        <p>Некоторые основные различия в табличной форме:</p>
                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>Promises</th>
                                <th>observables</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Выдает только одно значение за раз</td>
                                <td>Выдает несколько значений за определенный период времени (поток значений от 0 до
                                    нескольких)
                                </td>
                            </tr>
                            <tr>
                                <td>Вызов происходит немедленно</td>
                                <td>Для вызова необходима подписка</td>
                            </tr>
                            <tr>
                                <td>Промис всегда асинхронен, даже если он выполняется немедленно.</td>
                                <td>Observable может быть синхронным или асинхронным.</td>
                            </tr>
                            <tr>
                                <td>Не предоставляет никаких операторов</td>
                                <td>Предоставляет такие операторы, как map, forEach, filter, reduce, retry, and
                                    retryWhen и
                                    т.д.
                                </td>
                            </tr>
                            <tr>
                                <td>Не может быть отменено</td>
                                <td>Отменяется с помощью метода unsubscribe()</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment392">Что такое heap</h4>

                    <div>
                        <p>Куча (или куча памяти) — это ячейка памяти, в которой хранятся объекты, когда мы определяем
                            переменные.
                            т. е. это место, где происходят все выделения и освобождение памяти. И куча, и стек вызовов
                            представляют
                            собой два контейнера среды выполнения JS. Всякий раз, когда среда выполнения встречает в
                            коде
                            переменные
                            и объявления функций, она сохраняет их в куче.</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/heap.png" alt="heap">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment393">Что такое таблица событий</h4>

                    <div>
                        <p>Таблица событий — это структура данных, которая хранит и отслеживает все события, которые
                            будут
                            выполняться асинхронно, например, через определенный интервал времени или после разрешения
                            некоторых
                            запросов API. То есть всякий раз, когда вы вызываете функцию setTimeout или вызываете
                            асинхронную
                            операцию, она добавляется в таблицу событий. Он не выполняет функции сам по себе. Основная
                            цель
                            таблицы событий — отслеживать события и отправлять их в очередь событий, как показано на
                            диаграмме
                            ниже:</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/event-table.png" alt="event-table">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment394">Что такое очередь микрозадач</h4>

                    <div>
                        <p>Очередь микрозадач — это новая очередь, в которой все задачи, инициированные объектами
                            обещаний,
                            обрабатываются до очереди обратного вызова. Очередь микрозадач обрабатывается перед
                            следующими
                            заданиями рендеринга и рисования. Но если эти микрозадачи выполняются долго, то это приводит
                            к
                            ухудшению зрения.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment395">В чем разница между шиммом и полифиллом</h4>

                    <div>
                        <p>shim — это библиотека, которая переносит новый API в старую среду, используя только средства
                            этой
                            среды. Это не обязательно ограничивается веб-приложением. Например, es5-shim.js используется
                            для
                            эмуляции функций ES5 в старых браузерах (в основном до IE9). Принимая во внимание, что
                            полифилл
                            — это фрагмент кода (или плагин), который предоставляет технологию, которую вы, разработчик,
                            ожидаете
                            от браузера изначально. Проще говоря, полифилл — это оболочка для API браузера.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment396">Как определить примитивный или не примитивный тип значения</h4>

                    <div>
                        <p>В JavaScript к примитивным типам относятся логические значения, строки, числа, BigInt, null,
                            символ и неопределенные. В то время как непримитивные типы включают Objects. Но вы можете
                            легко
                            идентифицировать их с помощью функции ниже:</p>

                        <pre>
let myPrimitive = 30;
let myNonPrimitive = {};
function isPrimitive(val) {
    return Object(val) !== val;
}

isPrimitive(myPrimitive);
isPrimitive(myNonPrimitive);
                </pre>

                        <p>Если значение является примитивным типом данных, конструктор Object создает новый
                            объект-оболочку
                            для
                            значения. Но если значение является непримитивным типом данных (объектом), конструктор
                            объекта
                            предоставит тот же объект.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment397">Что такое babel</h4>

                    <div>
                        <p>Babel — это транспилятор JavaScript для преобразования кода ECMAScript 2015+ в
                            обратно
                            совместимую версию
                            JavaScript в текущих и старых браузерах или средах. Некоторые из основных функций
                            перечислены
                            ниже:</p>

                        <ol>
                            <li>Синтаксис преобразования</li>
                            <li>Функции Polyfill, отсутствующие в вашей целевой среде (с использованием
                                @babel/polyfill).
                            </li>
                            <li>Преобразования исходного кода (или модификации кода)</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment398">Является ли Node.js полностью однопоточным?</h4>

                    <div>
                        <p>Node — это однопоточный процесс, но некоторые функции, включенные в стандартную библиотеку
                            Node.js
                            (например, функции модуля fs), не являются однопоточными. т. е. их логика работает за
                            пределами
                            одного потока Node.js, чтобы повысить скорость и производительность программы.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment399">Каковы распространенные случаи использования observable</h4>

                    <div>
                        <p>Некоторые из наиболее распространенных случаев использования observable — это веб-сокеты с
                            push-уведомлениями, изменения пользовательского ввода, повторение интервалов и т. д.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment400">Что такое RxJS</h4>

                    <div>
                        <p>RxJS (Reactive Extensions for JavaScript(дословно: Реактивные расширения для JavaScript)) —
                            это
                            библиотека для реализации реактивного программирования с использованием observables, которая
                            упрощает
                            составление асинхронного кода или кода на основе обратного вызова. Он также предоставляет
                            служебные
                            функции для создания observables и работы с ними.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment401">В чем разница между конструктором функции и объявлением
                        функции</h4>

                    <div>
                        <p>Функции, созданные с помощью конструктора функций, не создают замыканий для контекстов своего
                            создания,
                            но они всегда создаются в глобальной области видимости. т. е. функция может обращаться
                            только к
                            своим собственным локальным переменным и переменным глобальной области видимости. В то время
                            как
                            объявления функций также могут получать доступ к внешним переменным функции
                            (замыканиям).</p>
                        <p>Давайте посмотрим на эту разницу на примере:</p>

                        <pre>
// Function Constructor:

var a = 100;
function createFunction() {
    var a = 200;
    return new Function("return a;");
}
console.log(createFunction()()); // 100

// Function declaration:

var a = 100;
function createFunction() {
    var a = 200;
    return function func() {
      return a;
    };
}
console.log(createFunction()()); // 200
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment402">Что такое короткое замыкание</h4>

                    <div>
                        <p>Условия короткого замыкания предназначены для сокращенного написания простых операторов if.
                            Продемонстрируем сценарий на примере. Если вы хотите войти на портал с условием
                            аутентификации,
                            выражение будет таким, как показано ниже:</p>

                        <pre>
if (authenticate) {
    loginToPorta();
}
                </pre>

                        <p>Поскольку логические операторы JavaScript оцениваются слева направо, приведенное выше
                            выражение
                            можно упростить с помощью логического оператора &&(оператора короткого замыкания):</p>

                        <pre>authenticate && loginToPorta();</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment403">Как проще всего изменить размер массива</h4>

                    <div>
                        <p>Свойство length массива полезно для быстрого изменения размера или очистки массива. Давайте
                            применим
                            свойство длины к числовому массиву, чтобы изменить размер количества элементов с 5 до 2.</p>

                        <pre>
const array = [1, 2, 3, 4, 5];
console.log(array.length); // 5

array.length = 2;
console.log(array.length); // 2
console.log(array); // [1,2]
                </pre>

                        <p>массив также можно очистить:</p>

                        <pre>
const array = [1, 2, 3, 4, 5];
array.length = 0;
console.log(array.length); // 0
console.log(array); // []
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment404">Что такое observable</h4>

                    <div>
                        <p>Observable – это, по сути, функция, которая может возвращать наблюдателю(observer) поток
                            значений
                            синхронно или асинхронно с течением времени. Потребитель(consumer) может получить значение,
                            вызвав
                            метод subscribe(). Давайте посмотрим на простой пример Observable:</p>

                        <pre>
import { Observable } from "rxjs";

const observable = new Observable((observer) => {
    setTimeout(() => {
      observer.next("Message from a Observable!");
    }, 3000);
});

observable.subscribe((value) => console.log(value));
                </pre>

                        <div class="smallScreenContainer">
                            <img src="./assets/observables.png" alt="observables">
                        </div>

                        <p>Примечание: Observables пока не являются частью языка JavaScript, но их предлагается добавить
                            в
                            язык.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment405">В чем разница между объявлениями функций и классов</h4>

                    <div>
                        <p>Основное различие между объявлениями функций и объявлениями классов — это
                            подъем(hoisting). Объявления функций поднимаются, a объявления классов - нет.</p>

                        <pre>
Classes:

const user = new User(); // ReferenceError

class User {}

//Constructor Function:

const user = new User(); // No error

function User() {}
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment406">Что такое асинхронная функция</h4>

                    <div>
                        <p>Асинхронная функция — это функция, объявленная с ключевым словом async, которая позволяет
                            писать
                            асинхронное поведение на основе промисов в более чистом стиле, избегая цепочек промисов. Эти
                            функции могут содержать ноль или более выражений «await».</p>
                        <p>Давайте возьмем приведенный ниже пример асинхронной функции:</p>

                        <pre>
async function logger() {
    let data = await fetch("http://someapi.com/users"); // pause until fetch returns
    console.log(data);
}
logger();
                </pre>

                        <p>По сути, это синтаксический сахар над промисами и генераторами ES2015.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment407">Как предотвратить ошибки, связанные с проглатыванием
                        промисов?</h4>

                    <div>
                        <p>При использовании асинхронного кода промисов ES6 JavaScript могут значительно облегчить вашу
                            жизнь без
                            пирамид обратных вызовов и обработки ошибок в каждой второй строке. Но у промисов есть
                            некоторые
                            подводные камни, и самый большой из них — это проглатывание ошибок по умолчанию.</p>
                        <p>Допустим, вы ожидаете вывести в консоль ошибку во всех следующих случаях:</p>

                        <pre>
Promise.resolve("promised value").then(function () {
    throw new Error("error");
});

Promise.reject("error value").catch(function () {
    throw new Error("error");
});

new Promise(function (resolve, reject) {
    throw new Error("error");
});
                </pre>

                        <p>Но существует множество современных сред JavaScript, которые не выводят никаких
                            ошибок. Эту проблему можно решить разными способами:</p>
                        <ol>
                            <li>
                                Добавьте блок catch в конец каждой цепочки: вы можете добавить блок catch в
                                конец каждой цепочки обещаний.

                                <pre>
Promise.resolve("promised value")
   .then(function () {
     throw new Error("error");
   })
   .catch(function (error) {
     console.error(error.stack);
   });
                        </pre>
                                Но печатать для каждой цепочки обещаний довольно сложно, да и многословно.
                            </li>
                            <li>
                                Добавить метод Done: вы можете заменить блоки "then" и "catch"
                                первого решения методом Done.
                                <pre>
Promise.resolve("promised value").done(function () {
    throw new Error("error");
});
                        </pre>
                                Допустим, вы хотите получить данные с помощью HTTP, а затем выполнить асинхронную
                                обработку полученных данных. Вы можете написать готовый блок, как показано ниже:
                                <pre>
getDataFromHttp()
   .then(function (result) {
     return processDataAsync(result);
   })
   .done(function (processed) {
     displayData(processed);
   });
                        </pre>

                                В будущем, если API библиотеки обработки изменится на синхронный, вы можете
                                удалить блок "done", как показано ниже:
                                <pre>
getDataFromHttp().then(function (result) {
    return displayData(processDataAsync(result));
});
                        </pre>

                                и если вы забыли добавить блок "done" к блоку "then", то это приводит к скрытым ошибкам.
                            </li>
                            <li>
                                Расширение промисов ES6 с помощью Bluebird: Bluebird расширяет API промисов ES6, чтобы
                                избежать
                                проблемы во втором решении. Эта библиотека имеет обработчик onRejection “default”,
                                который
                                выводит все ошибки из отклоненных промисов в stderr. После установки вы можете
                                обрабатывать
                                необработанные отклонения
                                <pre>
Promise.onPossiblyUnhandledRejection(function (error) {
    throw error;
});
                        </pre>

                                и отбросить отказ, просто обработайте его пустым catch

                                <pre>Promise.reject("error value").catch(function () {});</pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment408">Что такое deno</h4>

                    <div>
                        <p>Deno — это простая, современная и безопасная среда выполнения для JavaScript и TypeScript,
                            использующая движок JavaScript V8 и язык программирования Rust.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment409">Как сделать объект итерируемым в JavaScript?</h4>

                    <div>
                        <p>По умолчанию простые объекты не являются итерируемыми. Но вы можете сделать
                            объект итерируемым, определив для него свойство Symbol.iterator.</p>
                        <p>Продемонстрируем это на примере:</p>

                        <pre>
const collection = {
   one: 1,
   two: 2,
   three: 3,
   [Symbol.iterator]() {
      const values = Object.keys(this);
      let i = 0;
      return {
         next: () => {
            return {
               value: this[values[i++]],
               done: i > values.length,
            };
         },
      };
   },
};

const iterator = collection[Symbol.iterator]();

console.log(iterator.next()); // → {value: 1, done: false}
console.log(iterator.next()); // → {value: 2, done: false}
console.log(iterator.next()); // → {value: 3, done: false}
console.log(iterator.next()); // → {value: undefined, done: true}
                </pre>

                        <p>Вышеописанный процесс можно упростить, используя функцию генератора:</p>

                        <pre>
const collection = {
    one: 1,
    two: 2,
    three: 3,
    [Symbol.iterator]: function* () {
        for (let key in this) {
            yield this[key];
        }
    },
};
const iterator = collection[Symbol.iterator]();
console.log(iterator.next()); // {value: 1, done: false}
console.log(iterator.next()); // {value: 2, done: false}
console.log(iterator.next()); // {value: 3, done: false}
console.log(iterator.next()); // {value: undefined, done: true}
                </pre>
                    </div>
                </section>


                <section>
                    <h4 id="JSbasicsForEmployment410">Что такое правильный хвостовой вызов</h4>

                    <div>
                        <p>Во-первых, мы должны знать о хвостовом вызове, прежде чем говорить о "правильном хвостовом
                            вызове".
                            Хвостовой вызов — это вызов подпрограммы или функции, выполняемый как последнее действие
                            вызывающей
                            функции. Принимая во внимание, что правильный хвостовой вызов (PTC) — это метод, при котором
                            программа или код не будут создавать дополнительные кадры стека для рекурсии, когда вызов
                            функции является
                            хвостовым вызовом.</p>
                        <p>Например, приведенная ниже классическая или головная рекурсия функции факториала использует
                            стек для каждого шага. Каждый шаг должен быть обработан до n * factorial(n - 1).</p>

                        <pre>
function factorial(n) {
    if (n === 0) {
      return 1;
    }
    return n * factorial(n - 1);
}
console.log(factorial(5)); //120
                </pre>

                        <p>Но если вы используете функции хвостовой рекурсии, они продолжают передавать
                            все необходимые данные по рекурсии, не полагаясь на стек.</p>

                        <pre>
function factorial(n, acc = 1) {
    if (n === 0) {
      return acc;
    }
    return factorial(n - 1, n * acc);
}
console.log(factorial(5)); //120
                </pre>

                        <p>Приведенный выше шаблон возвращает тот же результат, что и первый. Но аккумулятор отслеживает
                            сумму в качестве аргумента, не используя память стека при рекурсивных вызовах.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment411">Как проверить, является ли объект промисом или нет?</h4>

                    <div>
                        <p>Если вы не знаете, является ли значение промисом или нет, оберните значение
                            как Promise.resolve(value), которое возвращает промис.</p>

                        <pre>
function isPromise(object) {
    if (Promise && Promise.resolve) {
      return Promise.resolve(object) == object;
    } else {
      throw "Promise not supported in your environment";
    }
}

var i = 1;
var promise = new Promise(function (resolve, reject) {
    resolve();
});

console.log(isPromise(i)); // false
console.log(isPromise(promise)); // true
                </pre>

                        <p>Другой способ — проверить тип обработчика .then().</p>

                        <pre>
function isPromise(value) {
    return Boolean(value && typeof value.then === "function");
}
var i = 1;
var promise = new Promise(function (resolve, reject) {
    resolve();
});

console.log(isPromise(i)); // false
console.log(isPromise(promise)); // true
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment412">Как определить, вызывается ли функция как конструктор</h4>

                    <div>
                        <p>Вы можете использовать псевдосвойство new.target, чтобы определить, была ли функция
                            вызвана как конструктор (с использованием оператора new) или как обычный вызов функции.</p>

                        <ol>
                            <li>Если конструктор или функция вызывается с помощью оператора new,
                                new.target возвращает ссылку на конструктор или функцию.
                            </li>
                            <li>
                                Для вызовов функций new.target - undefined.
                                <pre>
function Myfunc() {
    if (new.target) {
      console.log("called with new");
    } else {
      console.log("not called with new");
    }
}

new Myfunc(); // called with new
Myfunc(); // not called with new
Myfunc.call({}); // not called with new
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment413">Каковы различия между объектом аргументов и параметром rest</h4>

                    <div>
                        <p>Существует три основных различия между объектом аргументов и остальными параметрами:</p>

                        <ol>
                            <li>
                                Объект аргументов похож на массив, но не является массивом. Тогда как
                                остальные параметры являются экземплярами массива.
                            </li>
                            <li>
                                Объект аргументов не поддерживает такие методы, как sort, map, forEach
                                или pop. Тогда как эти методы можно использовать в остальных параметрах.
                            </li>
                            <li>
                                Rest параметры — это только те, которым не присвоено отдельное имя, а
                                объект аргументов содержит все аргументы, переданные в функцию.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment414">В чем разница между spread оператором и rest параметром</h4>

                    <div>
                        <p>Параметр Rest собирает все оставшиеся элементы в массив. В то время как оператор Spread
                            позволяет
                            разделять итерируемые элементы (массивы/объекты/строки) на отдельне аргументы/элементы. т.
                            е.
                            параметр Rest противоположен оператору spread.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment415">Какие существуют виды генераторов</h4>

                    <div>
                        <p>Существует пять видов генераторов:</p>

                        <ol>
                            <li>
                                Объявление функции генератора(Generator function declaration):
                                <pre>
function* myGenFunc() {
    yield 1;
    yield 2;
    yield 3;
}
const genObj = myGenFunc();
                        </pre>
                            </li>
                            <li>
                                Выражения генераторной функции(Generator function expressions):
                                <pre>
const myGenFunc = function* () {
    yield 1;
    yield 2;
    yield 3;
};
const genObj = myGenFunc();
                        </pre>
                            </li>
                            <li>
                                Определения методов генератора в объектных литералах(Generator method definitions in
                                object
                                literals):

                                <pre>
const myObj = {
    *myGeneratorMethod() {
      yield 1;
      yield 2;
      yield 3;
    },
};
const genObj = myObj.myGeneratorMethod();
                        </pre>
                            </li>
                            <li>
                                Определения методов генератора в классе(Generator method definitions in class):
                                <pre>
class MyClass {
    *myGeneratorMethod() {
      yield 1;
      yield 2;
      yield 3;
    }
}
const myObject = new MyClass();
const genObj = myObject.myGeneratorMethod();
                        </pre>
                            </li>
                            <li>
                                Генератор как вычисляемое свойство:(Generator as a computed property):
                                <pre>
const SomeObj = {
    *[Symbol.iterator]() {
      yield 1;
      yield 2;
      yield 3;
    },
};

console.log(Array.from(SomeObj)); // [ 1, 2, 3 ]
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment416">Какие есть встроенные итерируемые сущности</h4>

                    <div>
                        <p>Ниже приведен список встроенных итераций в JavaScript:</p>

                        <ol>
                            <li>Массивы и типизированные массивы</li>
                            <li>Строки: перебор каждого символа или кодовых точек Юникода.</li>
                            <li>Maps: перебор пары ключ-значение.</li>
                            <li>Sets: перебор их элементов.</li>
                            <li>аргументы: специальная переменная, подобная массиву, в функциях.</li>
                            <li>Коллекция DOM, такая как NodeList.</li>
                        </ol>
                    </div>
                </section>


                <section>
                    <h4 id="JSbasicsForEmployment417">В чем разница между операторами for...of и for...in</h4>

                    <div>
                        <p>Операторы for...in и for...of перебирают структуры данных js.
                            Единственная разница заключается в том, что они итерируют:</p>

                        <ol>
                            <li>for..in перебирает все перечислимые ключи свойств объекта</li>
                            <li>for..of перебирает значения итерируемого объекта.</li>
                        </ol>

                        <p>Поясним эту разницу на примере:</p>

                        <pre>
let arr = ["a", "b", "c"];

arr.newProp = "newValue";

// key are the property keys
for (let key in arr) {
    console.log(key); // 0, 1, 2 & newValue
}

// value are the property values
for (let value of arr) {
    console.log(value); // a, b, c
}
                </pre>

                        <p>Поскольку цикл for..in перебирает ключи объекта, первый цикл регистрирует 0, 1, 2 и newProp
                            при
                            переборе
                            объекта массива. Цикл for..of перебирает значения структуры данных arr и записывает a, b, c
                            в
                            консоль.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment418">Как вы определяете свойства экземпляра и неэкземпляра</h4>

                    <div>
                        <p>Свойства экземпляра должны быть определены внутри методов класса. Например,
                            свойства name и age, определенные внутри конструктора, как показано ниже:</p>

                        <pre>
class Person {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }
}
                </pre>

                        <p>Но свойства данных Static(class) и прототипа должны быть определены вне объявления
                            ClassBody. Давайте присвоим значение возраста для класса Person, как показано ниже:</p>

                        <pre>
Person.staticAge = 30;
Person.prototype.prototypeAge = 40;
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment419">В чем разница между isNaN и Number.isNaN?</h4>

                    <div>
                        <ol>
                            <li>
                                isNaN: глобальная функция isNaN преобразует аргумент в число и
                                возвращает true, если результирующее значение равно NaN.
                            </li>
                            <li>
                                Number.isNaN: этот метод не преобразует аргумент. Но он возвращает
                                true, если тип — число, а значение — NaN.
                            </li>
                        </ol>

                        <p>Давайте посмотрим разницу на примере:</p>

                        <pre>
isNaN(‘hello’);   // true
Number.isNaN('hello'); // false
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment420">Как вызвать IIFE без дополнительных скобок?</h4>

                    <div>
                        <p>Для выражений с немедленным вызовом функций (IIFE) требуется пара круглых
                            скобок, чтобы обернуть функцию, содержащую набор операторов.</p>

                        <pre>
(function (dt) {
    console.log(dt.toLocaleTimeString());
})(new Date());
                </pre>

                        <p>Поскольку и IIFE, и оператор void отбрасывают результат выражения, вы можете избежать
                            дополнительных скобок, используя оператор void для IIFE, как показано ниже:</p>

                        <pre>
void (function (dt) {
    console.log(dt.toLocaleTimeString());
})(new Date());
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment421">Можно ли использовать выражения в switch case цикле?</h4>

                    <div>
                        <p>Возможно, вы видели выражения, используемые в switch condition, но их также можно
                            использовать
                            для switch case, присвоив условию переключения истинное значение. Давайте посмотрим на
                            погодные
                            условия в зависимости от температуры в качестве примера:</p>

                        <pre>
const weather = (function getWeather(temp) {
   switch (true) {
      case temp &lt; 0:
         return "freezing";
      case temp &lt; 10:
         return "cold";
      case temp &lt; 24:
         return "cool";
      default:
         return "unknown";
   }
})(10);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment422">Как проще всего игнорировать ошибки промисов?</h4>

                    <div>
                        <p>Самый простой и безопасный способ игнорировать ошибки промисов — аннулировать
                            эту ошибку. Этот подход также дружелюбен к ESLint.</p>

                        <pre>await promise.catch((e) =&gt; void e);</pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment423">Как оформить вывод консоли с помощью CSS?</h4>

                    <div>
                        <p>Вы можете добавить стиль CSS к выводу консоли, используя спецификатор содержимого формата CSS
                            %c.
                            Строковое сообщение консоли можно добавить после спецификатора и стиля CSS в другом
                            аргументе.
                            Давайте напечатаем текст красного цвета, используя console.log и спецификатор CSS, как
                            показано ниже:</p>

                        <pre>console.log("%cThis is a red text", "color:red");</pre>

                        <p>Также возможно добавить больше стилей для контента. Например, размер шрифта
                            можно изменить для приведенного выше текста.</p>

                        <pre>
console.log(
    "%cThis is a red text with bigger font",
    "color:red; font-size:20px"
);
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment424">Что такое нулевой оператор слияния (??)?</h4>

                    <div>
                        <p>Это логический оператор, который возвращает свой правый операнд, когда его левый операнд
                            имеет значение null или undefined, и в противном случае возвращает свой левый операнд.
                            Это можно противопоставить логическому оператору ИЛИ (||), который возвращает правый
                            операнд,
                            если левый операнд имеет любое ложное значение, а не null или undefined.</p>

                        <pre>
console.log(null ?? true); // true
console.log(false ?? true); // false
console.log(undefined ?? true); // true
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment425">Как группировать и вкладывать вывод консоли?</h4>

                    <div>
                        <p>console.group() можно использовать для группировки связанных сообщений журнала, чтобы можно
                            было
                            легко
                            читать журналы и использовать console.groupEnd() для закрытия группы. Наряду с этим вы также
                            можете
                            вкладывать группы, что позволяет выводить сообщения в иерархическом порядке.</p>
                        <p>Например, если вы регистрируете данные пользователя:</p>

                        <pre>
console.group("User Details");
console.log("name: Sudheer Jonna");
console.log("job: Software Developer");

// Nested Group
console.group("Address");
console.log("Street: Commonwealth");
console.log("City: Los Angeles");
console.log("State: California");

// Close nested group
console.groupEnd();

// Close outer group
console.groupEnd();
                </pre>

                        <p>Вы также можете использовать console.groupCollapsed() вместо console.group(),
                            если хотите, чтобы группы по умолчанию были свернуты.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment426">В чем разница между плотными и разреженными массивами?</h4>

                    <div>
                        <p>Массив, содержащий элементы под каждым индексом, начиная с первого (0) до последнего
                            (array.length - 1),
                            называется плотным массивом. А если по какому-либо индексу отсутствует хотя бы один элемент,
                            массив
                            называется разреженным.</p>
                        <p>Давайте посмотрим на два типа массивов ниже:</p>

                        <pre>
const avengers = ["Ironman", "Hulk", "CaptainAmerica"];
console.log(avengers[0]); // 'Ironman'
console.log(avengers[1]); // 'Hulk'
console.log(avengers[2]); // 'CaptainAmerica'
console.log(avengers.length); // 3

const justiceLeague = ["Superman", "Aquaman", , "Batman"];
console.log(justiceLeague[0]); // 'Superman'
console.log(justiceLeague[1]); // 'Aquaman'
console.log(justiceLeague[2]); // undefined
console.log(justiceLeague[3]); // 'Batman'
console.log(justiceLeague.length); // 4
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment427">Какие существуют способы создания разреженных массивов?</h4>

                    <div>
                        <p>Существует 4 различных способа создания разреженных массивов в JavaScript:</p>

                        <ol>
                            <li>
                                Литерал массива: пропустите значение при использовании литерала массива.

                                <pre>
const justiceLeague = ["Superman", "Aquaman", , "Batman"];
console.log(justiceLeague); // ['Superman', 'Aquaman', empty ,'Batman']
                        </pre>
                            </li>
                            <li>

                                <div>Конструктор Array(): вызов Array(length) или нового Array(length)
                                </div>
                                <pre>
const array = Array(3);
console.log(array); // [empty, empty ,empty]
                        </pre>
                            </li>
                            <li>
                                Оператор delete: использование оператора delete array[index] в массиве.

                                <pre>
const justiceLeague = ["Superman", "Aquaman", "Batman"];
delete justiceLeague[1];
console.log(justiceLeague); // ['Superman', empty, ,'Batman']
                        </pre>
                            </li>
                            <li>
                                Увеличение свойства length: увеличение свойства length массива.

                                <pre>
const justiceLeague = ["Superman", "Aquaman", "Batman"];
justiceLeague.length = 5;
console.log(justiceLeague); // ['Superman', 'Aquaman', 'Batman', empty, empty]
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment428">В чем разница между setTimeout, setImmediate и
                        process.nextTick?</h4>

                    <div>
                        <ol>
                            <li>
                                Set Timeout: setTimeout() предназначен для планирования выполнения однократного
                                обратного
                                вызова после задержки в миллисекундах.
                            </li>
                            <li>Set Immediate: функция setImmediate используется для выполнения
                                функции сразу после завершения текущего цикла событий.
                            </li>
                            <li>
                                Process NextTick: Если на определенной фазе вызывается process.nextTick(), все обратные
                                вызовы,
                                переданные в process.nextTick(), будут разрешены до продолжения цикла обработки событий.
                                Это
                                заблокирует цикл событий и создаст голодание ввода-вывода, если process.nextTick()
                                вызывается рекурсивно.
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment429">Как перевернуть массив, не изменяя исходный массив?</h4>

                    <div>
                        <p>Метод reverse() меняет порядок элементов в массиве, но изменяет исходный массив.
                            Давайте возьмем простой пример, чтобы продемонстрировать этот случай:</p>

                        <pre>
const originalArray = [1, 2, 3, 4, 5];
const newArray = originalArray.reverse();


console.log(newArray); // [ 5, 4, 3, 2, 1]
console.log(originalArray); // [ 5, 4, 3, 2, 1]
                </pre>

                        <p>Есть несколько решений, которые не изменят исходный массив:</p>

                        <ol>
                            <li>
                                Использование методов slice и reverse. В этом случае просто вызовите метод slice() для
                                массива, чтобы создать неполную копию, а затем вызовите метод reverse() для копии:

                                <pre>
const originalArray = [1, 2, 3, 4, 5];
const newArray = originalArray.slice().reverse(); //Slice an array gives a new copy

console.log(originalArray); // [1, 2, 3, 4, 5]
console.log(newArray); // [ 5, 4, 3, 2, 1]
                        </pre>
                            </li>
                            <li>
                                Использование методов spread и reverse. В этом случае давайте воспользуемся
                                синтаксисом spread(...) для создания копии массива с последующим вызовом метода
                                reverse() для копии:

                                <pre>
const originalArray = [1, 2, 3, 4, 5];
const newArray = [...originalArray].reverse();

console.log(originalArray); // [1, 2, 3, 4, 5]
console.log(newArray); // [ 5, 4, 3, 2, 1]
                        </pre>
                            </li>
                            <li>
                                Использование методов reduce и spread: здесь выполните функцию reducer для элементов
                                массива и добавьте накопленный массив справа, используя spread синтаксис:

                                <pre>
const originalArray = [1, 2, 3, 4, 5];
const newArray = originalArray.reduce((accumulator, value) => {
    return [value, ...accumulator];
}, []);

console.log(originalArray); // [1, 2, 3, 4, 5]
console.log(newArray); // [ 5, 4, 3, 2, 1]
                        </pre>
                            </li>
                            <li>
                                Использование методов reduceRight и spreadя: здесь выполните функцию right reducer
                                (т.е. направление, противоположное методу reduce) для элементов массива и добавьте
                                накопленный массив с левой стороны, используя spread синтаксис:

                                <pre>
const originalArray = [1, 2, 3, 4, 5];
const newArray = originalArray.reduceRight((accumulator, value) => {
    return [...accumulator, value];
}, []);

console.log(originalArray); // [1, 2, 3, 4, 5]
console.log(newArray); // [ 5, 4, 3, 2, 1]
                        </pre>
                            </li>
                            <li>
                                Использование методов reduceRight и push: здесь выполняется функция right reducer
                                (т.е. противоположное направлению метода reduce) для элементов массива и помещается
                                итерированное значение в аккумулятор.

                                <pre>
const originalArray = [1, 2, 3, 4, 5];
const newArray = originalArray.reduceRight((accumulator, value) => {
    accumulator.push(value);
    return accumulator;
}, []);

console.log(originalArray); // [1, 2, 3, 4, 5]
console.log(newArray); // [ 5, 4, 3, 2, 1]
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment430">Как создать кастомный HTML-элемент?</h4>

                    <div>
                        <p>Создание пользовательских элементов HTML включает в себя два основных этапа:</p>

                        <ol>
                            <li>
                                Определите свой собственный элемент HTML. Сначала вам нужно определить некоторый
                                собственный
                                класс, расширив класс HTMLElement. После этого определите свойства вашего компонента
                                (стили,
                                текст и т. д.), используя метод linkedCallback. Примечание. Браузер предоставляет
                                функцию
                                customElements.define для повторного использования элемента.

                                <pre>
class CustomElement extends HTMLElement {
    connectedCallback() {
        this.innerHTML = "This is a custom element";
    }
}
customElements.define("custom-element", CustomElement);
                        </pre>
                            </li>
                            <li>
                                Используйте пользовательский элемент так же, как и другой элемент HTML:
                                объявите свой пользовательский элемент как тег HTML.

                                <pre>
&lt;body&gt;
    &lt;custom-element&gt;
&lt;/body&gt;
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment431">Что такое глобальный контекст выполнения?</h4>

                    <div>
                        <p>Глобальный контекст выполнения — это контекст по умолчанию или первый контекст выполнения,
                            который
                            создается движком JavaScript перед выполнением любого кода (т. е. при первой загрузке файла
                            в
                            браузере). Весь глобальный код, который не находится внутри функции или объекта, будет
                            выполняться внутри
                            этого глобального контекста выполнения. Поскольку движок JS является однопоточным, будет
                            только
                            одна
                            глобальная среда и только один глобальный контекст выполнения.</p>
                        <p>Например, приведенный ниже код, отличный от кода внутри какой-либо функции или
                            объекта, выполняется внутри глобального контекста выполнения.</p>

                        <pre>
var x = 10;

function A() {
    console.log("Start function A");

    function B() {
        console.log("In function B");
    }

    B();
}

A();

console.log("GlobalContext");
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment432">Что такое контекст выполнения функции?</h4>

                    <div>
                        <p>Всякий раз, когда вызывается функция, механизм JavaScript создает другой тип контекста
                            выполнения,
                            известный как контекст выполнения функции (FEC), внутри глобального контекста выполнения
                            (GEC),
                            чтобы оценить и выполнить код внутри этой функции.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment433">Что такое debouncing?</h4>

                    <div>
                        <p>Устранение дрожания (дебаунсинг) — это шаблон программирования, который позволяет отложить
                            выполнение
                            некоторого фрагмента кода до определенного времени, чтобы избежать ненужных циклов ЦП,
                            вызовов
                            API и
                            повысить производительность. Функция дебаунсинга гарантирует, что ваш код запускается только
                            один раз для
                            каждого пользовательского ввода. Распространенными вариантами использования являются
                            предложения
                            в окне
                            поиска, автоматическое сохранение текстовых полей и исключение двойных нажатий кнопок.</p>
                        <p>Допустим, вы хотите показывать подсказки по поисковому запросу, но только после того, как
                            посетитель
                            закончил его вводить. Итак, здесь вы пишете дебаунс функцию, в которой пользователь
                            продолжает
                            писать символы в течение 500 мс, после чего предыдущий таймер очищается с помощью
                            ClearTimeout
                            и перепланирует вызов API/запрос к базе данных на новое время — 300 мс в будущем:</p>

                        <pre>
function debounce(func, timeout = 500) {
    let timer;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => {
        func.apply(this, args);
      }, timeout);
    };
}
function fetchResults() {
    console.log("Fetching input suggestions");
}
const processChange = debounce(() => fetchResults());
                </pre>

                        <p>Функцию debounce() можно использовать для событий input, button и window:</p>

                        <pre>
// Input:

&lt;input type="text" onkeyup="processChange()" /&gt;

// Button:

&lt;button onclick="processChange()"&gt;Click me&lt;/button&gt;

// Windows event:

window.addEventListener("scroll", processChange);
                        </pre>
                    </div>
                </section>


                <section>
                    <h4 id="JSbasicsForEmployment434">Что такое троттлинг(throttling)</h4>

                    <div>
                        <p>Регулирование — это метод, используемый для ограничения выполнения функции обработчика
                            событий,
                            даже если
                            это событие срабатывает постоянно из-за действий пользователя. Распространенными случаями
                            использования
                            являются изменение размера браузера, прокрутка окон и т. д.</p>
                        <p>В приведенном ниже примере создается функция регулирования для уменьшения количества событий
                            для
                            каждого
                            изменения пикселя и запуска события прокрутки каждые 100 мс, за исключением первого
                            события.</p>

                        <pre>
const throttle = (func, limit) => {
    let inThrottle;
    return (...args) => {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => (inThrottle = false), limit);
      }
    };
};
window.addEventListener("scroll", () => {
    throttle(handleScrollAnimation, 100);
});
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment435">Что такое optional chaining?</h4>

                    <div>
                        <p>Согласно официальной документации MDN, необязательный оператор цепочки (?.) позволяет читать
                            значение свойства, расположенного глубоко внутри цепочки связанных объектов, без
                            необходимости
                            явно
                            проверять правильность каждой ссылки в цепочке.</p>
                        <p>?. оператор похож на . оператор цепочки, за исключением того, что вместо того, чтобы вызывать
                            ошибку,
                            если ссылка имеет нулевое значение (null или undefined), выражение замыкается и возвращает
                            значение
                            undefined. При использовании с вызовами функций он возвращает значение undefined, если
                            данная
                            функция
                            не существует.</p>

                        <pre>
const adventurer = {
    name: "Alice",
    cat: {
        name: "Dilan",
    },
};

const dogName = adventurer.dog?.name;
console.log(dogName);
// expected output: undefined

console.log(adventurer.someNonExistentMethod?.());
// expected output: undefined
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment436">Что такое запись environment record?</h4>

                    <div>
                        <p>Согласно спецификации ECMAScript 262 (9.1): <a
                                href="https://262.ecma-international.org/12.0/#sec-environment-records" target="_blank">Environment
                            Record</a> — это тип спецификации, используемый для
                            определения связи идентификаторов с конкретными переменными и функциями на основе
                            лексической
                            структуры
                            вложенности кода ECMAScript.</p>
                        <p>Обычно Environment Record связана с некоторой конкретной синтаксической
                            структурой
                            кода ECMAScript, такой
                            как
                            FunctionDeclaration, BlockStatement или Catch TryStatement.</p>
                        <p>Каждый раз при оценке такого кода создается новая запись среды для записи
                            привязок
                            идентификаторов,
                            созданных этим кодом.</p>
                        <p>Немного о environment record можно почитать на <a
                                href="https://risen.dev/ru/posts/js-in-details-part-1/"
                                target="_blank">risen.dev</a></p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment437">Как проверить, является ли переменная массивом?</h4>

                    <div>
                        <p>Проверить, является ли переменная экземпляром массива, можно тремя разными способами:</p>

                        <ol>
                            <li>
                                Метод Array.isArray(): Служебная функция Array.isArray(value) используется для
                                определения
                                того, является ли значение массивом или нет. Эта функция возвращает истинное логическое
                                значение, если переменная является массивом, и ложное значение, если это не так.

                                <pre>
const numbers = [1, 2, 3];
const user = { name: "John" };
Array.isArray(numbers); // true
Array.isArray(user); //false
                        </pre>
                            </li>
                            <li>
                                Оператор instanceof: оператор instanceof используется для проверки типа массива во время
                                выполнения. Он возвращает true, если тип переменной — массив, или false для другого
                                типа.
                                <pre>
const numbers = [1, 2, 3];
const user = { name: "John" };
console.log(numbers instanceof Array); // true
console.log(user instanceof Array); // false
                        </pre>
                            </li>
                            <li>
                                Проверка типа конструктора: свойство конструктора переменной используется
                                для определения того, является ли переменная типом Array или нет.

                                <pre>
const numbers = [1, 2, 3];
const user = { name: "John" };
console.log(numbers.constructor === Array); // true
console.log(user.constructor === Array); // false
                        </pre>
                            </li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment438">Что такое передача по значению и передача по ссылке?</h4>

                    <div>
                        <p>Передача по значению создает новое пространство в памяти и копирует значение. Примитивы,
                            такие
                            как
                            строка, число, логическое значение и т.д., фактически создают новую копию. Следовательно,
                            обновление
                            одного значения не влияет на другое значение. Т.е. значения независимы друг от друга.</p>

                        <pre>
let a = 5;
let b = a;

b++;
console.log(a, b); //5, 6
                </pre>

                        <p>В приведенном выше фрагменте кода значение a присваивается значению b, а переменная b
                            увеличивается.
                            Поскольку для переменной b создано новое пространство, любое обновление этой переменной не
                            влияет на переменную a.</p>
                        <p>Передача по ссылке не создает новое пространство в памяти, но новая переменная принимает
                            адрес
                            памяти
                            исходной переменной. Непримитивы, такие как объекты, массивы и функции, получают ссылку на
                            инициализируемую переменную. Т.е. обновление одного значения повлияет на другую
                            переменную.</p>

                        <pre>
let user1 = {
    name: "John",
    age: 27,
};
let user2 = user1;
user2.age = 30;

console.log(user1.age, user2.age); // 30, 30
                </pre>

                        <p>В приведенном выше фрагменте кода обновление свойства age одного объекта
                            повлияет на другое свойство из-за той же ссылки.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment439">В чем разница между примитивами и непримитивами?</h4>

                    <div>
                        <p>В языке JavaScript есть как примитивы, так и непримитивы, но между ними мало
                            различий, как показано ниже:</p>

                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>Primitives</th>
                                <th>Non-primitives</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Эти типы предопределены</td>
                                <td>Созданы разработчиком</td>
                            </tr>
                            <tr>
                                <td>Неизменяемые</td>
                                <td>Изменяемые</td>
                            </tr>
                            <tr>
                                <td>Сравниваются по значению</td>
                                <td>Сравниваются по ссылке</td>
                            </tr>
                            <tr>
                                <td>Хранятся в стеке</td>
                                <td>Хранятся в куче</td>
                            </tr>
                            <tr>
                                <td>Содержат определенное значение</td>
                                <td>Может также содержать NULL</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment440">Как создать свой собственный метод bind, используя метод call или
                        apply?</h4>

                    <div>
                        <p>Пользовательскую функцию bind необходимо создать на прототипе функции, чтобы использовать ее
                            как
                            другие встроенные функции. Эта пользовательская функция должна возвращать функцию,
                            аналогичную
                            исходному методу bind, а реализация внутренней функции должна использовать вызов метода
                            Apply.</p>
                        <p>Функция, которая будет выполнять привязку(bind) с использованием специального метода
                            myOwnBind,
                            действует как
                            присоединенная функция (boundTargetFunction), а аргумент — как объект для вызова метода
                            Apply:</p>

                        <pre>
Function.prototype.myOwnBind = function (whoIsCallingMe) {
    if (typeof this !== "function") {
        throw new Error(this + "cannot be bound as it's not callable");
    }
    const boundTargetFunction = this;
    return function () {
        boundTargetFunction.apply(whoIsCallingMe, arguments);
    };
};
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment441">В чем разница между чистыми и нечистыми функциями?</h4>

                    <div>
                        <p>Некоторые из основных различий между чистой и нечистой функцией приведены ниже:</p>

                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>Чистая функция(Pure function)</th>
                                <th>Нечистая функция(Impure function)</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Не имеет побочных эффектов</td>
                                <td>Вызывает побочные эффекты</td>
                            </tr>
                            <tr>
                                <td>Всегда возвращает один и тот же результат</td>
                                <td>Возвращает разные результаты при каждом вызове</td>
                            </tr>
                            <tr>
                                <td>Легко читать и дебажить</td>
                                <td>Трудно читать и дебажить, поскольку на них влияет внешний код.</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment442">Что такое ссылочная прозрачность?</h4>

                    <div>
                        <p>Выражение в JavaScript, которое можно заменить его значением, не влияя на поведение
                            программы, называется ссылочной прозрачностью. Чистые функции ссылочно прозрачны.</p>

                        <pre>
const add = (x, y) => x + y;
const multiplyBy2 = (x) => x * 2;

//Now add (2, 3) can be replaced by 5.

multiplyBy2(add(2, 3));
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment443">Какие существуют побочные эффекты в JavaScript?</h4>

                    <div>
                        <p>Побочным эффектом является изменение состояния посредством вызова функции или выражения. Эти
                            побочные
                            эффекты по умолчанию делают нашу функцию нечистой. Ниже приведены некоторые побочные
                            эффекты,
                            которые делают функцию нечистой:</p>

                        <ul>
                            <li>
                                Когда делаем HTTP-запрос. Асинхронные функции, такие как fetch и promise, являются
                                нечистыми.
                            </li>
                            <li>Манипуляции с DOM</li>
                            <li>Мутация input данных</li>
                            <li>Печать на экран или консоль: например, console.log() и alert().</li>
                            <li>Получение текущего времени</li>
                            <li>Вызовы Math.random(): изменяют внутреннее состояние объекта Math.</li>
                        </ul>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment444">Что такое функции компоновки и конвейера?</h4>

                    <div>
                        <p>"Компоновка"(compose) и "конвейер"(pipe) — это два метода, обычно используемые в
                            функциональном
                            программировании для упрощения сложных операций и повышения читабельности кода. Они не
                            являются
                            родными для JavaScript и функций высшего порядка. compose() применяет справа налево любое
                            количество
                            функций к выводу предыдущей функции.</p>
                    </div>
                </section>


                <section>
                    <h4 id="JSbasicsForEmployment445">Что такое шаблон модуля?</h4>

                    <div>
                        <p>Шаблон модуля — это разработанный шаблон, используемый для объединения набора переменных и
                            функций в
                            одной области, возвращаемой в виде объекта. В JavaScript нет спецификаторов доступа,
                            подобных
                            другим
                            языкам (Java, Python и т. д.), чтобы обеспечить частную область действия. Он использует IIFE
                            (выражение
                            функции с немедленным вызовом), чтобы разрешить частные области. то есть замыкание,
                            защищающее
                            переменные и методы.</p>
                        <p>Шаблон модуля выглядит следующим образом:</p>

                        <pre>
(function () {
    // Private variables or functions goes here.

    return {
      // Return public variables or functions here.
    };
})();
                </pre>

                        <p>Давайте посмотрим пример шаблона модуля для сотрудника с частным и публичным доступом:</p>

                        <pre>
const createEmployee = (function () {
    // Private
    const name = "John";
    const department = "Sales";
    const getEmployeeName = () => name;
    const getDepartmentName = () => department;

    // Public
    return {
        name,
        department,
        getName: () => getEmployeeName(),
        getDepartment: () => getDepartmentName(),
    };
})();

console.log(createEmployee.name);
console.log(createEmployee.department);
console.log(createEmployee.getName());
console.log(createEmployee.getDepartment());
                        </pre>

                        <p>Примечание: Он имитирует концепцию классов с частными переменными и методами.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment446">Что такое композиция функций?</h4>

                    <div>
                        <p>Это подход, при котором результат одной функции передается следующей функции, которая
                            передается
                            другой до тех пор, пока последняя функция не будет выполнена для окончательного
                            результата.</p>

                        <pre>
//example
const double = (x) => x * 2;
const square = (x) => x * x;

var output1 = double(2);
var output2 = square(output1);
console.log(output2);

var output_final = square(double(2));
console.log(output_final);
                </pre>
                    </div>
                </section>

                <section>
                    <h4 id="JSbasicsForEmployment447">Как использовать await вне асинхронной функции до ES2022?</h4>

                    <div>
                        <p>До версии ES2022 попытка использовать await вне асинхронной функции приводила к ошибке
                            SyntaxError.</p>

                        <pre>await Promise.resolve(console.log("Hello await")); // SyntaxError: await is only valid in async function</pre>

                        <p>Но вы можете решить эту проблему с помощью альтернативного IIFE (выражение немедленно
                            вызываемой функции), чтобы получить доступ к этой функции.</p>

                        <pre>
(async function () {
    await Promise.resolve(console.log("Hello await")); // Hello await
})();
                </pre>

                        <p>В ES2022 вы можете написать await верхнего уровня без каких-либо хаков.</p>

                        <pre>await Promise.resolve(console.log("Hello await")); //Hello await</pre>
                    </div>
                </section>
            </section>

            <section id="JSpracticeNav">
                <h3 id="JSPracticeHeader">JavaScript практика</h3>

                <section>
                    <h4 id="JSlesson1">UNIT 1. СТАРТУЕМ И ПИШЕМ ПЕРВУЮ ПРОГРАММУ</h4>

                    <p id="out"></p>

                    <p class="queryselector1"></p>

                    <p id="multiplikation"></p>

                    <p id="queryselector2"></p>

                    <div class="tree"></div>

                    <div class="fraktion"></div>

                    <div class="jslink smallScreenContainer"></div>

                    <div class="calc"></div>

                    <div class="separ"></div>
                    <div class="test-1"></div>
                    <div class="test-2"></div>
                    <div class="s3"></div>
                    <div class="s4"></div>
                </section>

                <section>
                    <h4 id="JSlesson2">UNIT 2. ОСНОВЫ ВВОДА ДАННЫХ</h4>

                    <input aria-label="text input" type="text" id="input-in" value="">
                    <button id="clacbutton">клац</button>
                    <div class="output"></div>
                    <br>

                    <input aria-label="text input" type="text" id="name1">
                    <input aria-label="text input" type="text" id="secondname1">
                    <button id="summbut">Приветствие</button>
                    <br>

                    <input aria-label="number input" type="number" id="name2">
                    <input aria-label="number input" type="number" id="secondname2">
                    <button id="summbut1">сложение</button>
                    <div class="output1"></div>
                    <br>

                    <input aria-label="text input" type="text" id="seven" value="77">
                    <br>
                    <input aria-label="text input" type="text" id="borderinput">
                    <br>
                    <input aria-label="number input" type="number" id="name3">
                    <input aria-label="number input" type="number" id="secondname3">
                    <button id="summbut2">сложение</button>
                    <div class="output2"></div>
                    <br>
                    <input aria-label="text input" type="text" id="textinput">
                    <button id="parsebutt">парс</button>
                    <br>
                    <input aria-label="text input" type="text" id="name4" value="имя">
                    <input aria-label="text input" type="text" id="secondname4" placeholder="фамилия">
                    <input aria-label="number input" type="number" id="userage" placeholder="возраст">
                    <input aria-label="text input" type="text" id="userjob" value="профессия">
                    <button id="submitbut">отправить</button>
                    <div class="output3"></div>

                    <hr>
                </section>

                <section>
                    <h4 id="JSlesson3">UNIT 3. ОПЕРАТОР IF, ELSE, SWITCH CASE - ВЫБОР В JAVASCRIPT</h4>

                    <label for="age1butt">Enter age:</label>
                    <input aria-label="text input" type="text" class="age1">
                    <button id="age1butt">ok</button>

                    <ol>
                        <li>
                            <p>При нажатии кнопки b-1 срабатывает функция f1. Функция должна прочитать содержимое i-1 и
                                сравнить
                                его
                                с числом 4 (сравнение ==). Результат сравнения - true или false выведите в out-1.</p>
                            <input aria-label="number input" type="number" id="i-1">
                            <button id="b-1">клацай</button>
                            <div class="out-1"></div>
                        </li>
                        <li>
                            <p>Даны две переменные a21 и a22. При нажатии кнопки b-2, запускается функция f2. Функция
                                должна
                                сравнить переменные с помощью if else и вывести в out-2 число, которое больше.
                                Вариант равенства переменных не рассматриваем.</p>
                            <input aria-label="number input" type="number" id="a-21">
                            <input aria-label="number input" type="number" id="a-22">
                            <button id="b-2">клацай</button>
                            <div class="out-2">Большее:</div>
                        </li>
                        <li>
                            <p>Даны 2 input - i-31 и i-32, оба - input[type=number]. При нажатии кнопки b-3 срабатывает
                                функция
                                f3.
                                Функция должна прочитать содержимое i-31 и i-32 в переменные и сравнить их, вывести в
                                out-3
                                большее
                                число.
                                Проведите самостоятельный тест работы, введите пары чисел 4 и 9, 9 и 22, 5 и 111.</p>
                            <input aria-label="number input" type="number" id="i-31">
                            <input aria-label="number input" type="number" id="i-32">
                            <button id="b-3">клацай</button>
                            <div class="out-3">Большее:</div>

                        </li>
                        <li>
                            <p>Создайте на странице input[type=number] с классом i-4, куда пользователь может ввести год
                                своего
                                рождения. Есть кнопка b-4 которая запускает функцию f4.
                                Функция должна вывести в .out-4 число 1 если пользователю больше или равно 18 лет, и 0
                                если
                                меньше.</p>
                            <label>birthdate: </label>
                            <input aria-label="number input" type="number" id="i-4">
                            <button id="b-4">клацай</button>
                            <div class="out-4">1- эдалт, 0- малолетка</div>
                        </li>
                        <li>
                            <p>Создайте на странице input[type=number] с классом i-5, куда пользователь может ввести
                                число.
                                Есть
                                кнопка b-5 которая запускает функцию f5.
                                Функция должна вывести в .out-5 символ m если число меньше нуля, 0 если число равно нулю
                                и 1
                                если
                                больше.</p>
                            <input aria-label="number input" type="number" id="i-5">
                            <button id="b-5">клацай</button>
                            <div class="out-5">больше, равно или меньше нуля(m/0/1)</div>
                        </li>
                        <li>
                            <p>Создайте на странице input[type=number] с классом i-6, куда пользователь может ввести
                                число.
                                Есть
                                кнопка b-6 которая запускает функцию f6.
                                Функция должна вывести в .out-6 слово even если число четное и odd если нечетное. Для
                                проверки
                                четности используется целочисленный остаток от деления на 2 (оператор %).
                                Если остаток равен нулю - четное, нет - нечетное.</p>
                            <input aria-label="number input" type="number" id="i-6">
                            <button id="b-6">клацай</button>
                            <div class="out-6">четное(even) нечетное(odd)</div>
                        </li>
                        <li>
                            <p>Даны 2 input - i-71 и i-72, оба - input[type=number]. При нажатии кнопки b-7 срабатывает
                                функция
                                f7.
                                Функция должна число из i-71 возвести в степень i-72, вывести результат в out-7.
                                Для возведения в степень можно использовать **, или Math.pow.</p>
                            <input aria-label="number input" type="number" id="i-7">
                            <input aria-label="number input" type="number" id="o-7">
                            <button id="b-7">клац</button>
                            <div class="out-7">результат возведения в степень</div>
                        </li>
                        <li>
                            <p>Дан select s-8, который содержит 3 значения: 1, 2, 3. Дана кнопка b-8. При ее нажатии
                                срабатывает
                                функция f8.
                                Функция должна получить выбранное в select число, потом с помощью switch case сравнить
                                его
                                поочередно с ‘1’, ‘2’, ‘3’.
                                И если число выбрано - 1, то вывести в out-8 строку one, если 2 - two, если 3 -
                                three.</p>
                            <select aria-label="selector" id="s-8">
                                <option value="1">1</option>
                                <option value="2">2</option>
                                <option value="3">3</option>
                            </select>
                            <button id="b-8">клац</button>
                            <div class="out-8">совершенный выбор</div>
                        </li>
                        <li>
                            <p>Создайте на странице input[type=number] с классом i-9, куда пользователь может ввести
                                номер
                                квартиры.
                                Есть кнопка b-9 которая запускает функцию f9.
                                Функция должна вывести в .out-9 номер подъезда, в котором находится квартира.</p>
                            <ul>
                                <li>если от 1 до 32 - то вывести цифру 1</li>
                                <li>если от 33 до 43 - то вывести 2</li>
                                <li>если от 44 до 64 - то 3.</li>
                                <li>В противном случае, вывести 0.</li>
                            </ul>

                            <br>

                            <input aria-label="number input" type="number" id="i-9">
                            <button id="b-9">клацай</button>
                            <div class="out-9">номер подъезда</div>
                        </li>
                        <li>
                            <p>Дан select s-100. По нажатию кнопки, выведите value выбранного option в out-10.</p>
                            <label>Номер квартиры:</label>
                            <select aria-label="selector" id="s-10">
                                <option value="1">1-32</option>
                                <option value="2">33-43</option>
                                <option value="3">44-64</option>
                            </select>
                            <button id="b-10">клац</button>
                            <div class="out-10">номер подъезда:</div>
                        </li>
                        <li>
                            <p>Дан select s-110. По изменению состояния select (событие onchange) выведите value
                                выбранного
                                option в
                                out-11.</p>
                            <label>Номер квартиры:</label>
                            <select aria-label="selector" id="s-11">
                                <option value="1">1-32</option>
                                <option value="2">33-43</option>
                                <option value="3">44-64</option>
                            </select>
                            <div class="out-11">номер подъезда:</div>
                        </li>
                        <li>
                            <p>Дан input i-120. По нажатию кнопки получите значение из input в переменную, а затем
                                выведите
                                в
                                out-12
                                typeof полученной переменной.</p>
                            <input aria-label="text input" type="text" id="i-12">
                            <button id="b-12">клацай</button>
                            <div class="out-12">тип текста</div>
                        </li>
                        <li>
                            <p>Дан input i-130. В отличие от предыдущего задания - input type number. По нажатию кнопки
                                получите
                                значение из input в переменную, а затем выведите в out-13 typeof полученной переменной.
                                Typeof позволяет определить тип данных. Если вы правильно все сделали - то удивительно,
                                но
                                тип
                                данных будет string! Подумайте почему так?</p>
                            <input aria-label="number input" type="number" id="i-13">
                            <button id="b-13">клацай</button>
                            <div class="out-13">тип текста</div>
                        </li>
                        <li>
                            <p>Дан input-141 и input-142, type=number. Дан select s-143, который содержит две операции -
                                +,
                                -,
                                *, /
                                . Дана кнопка b-14, при нажатии на которую срабатывает функция f14.
                                Функция выводит в out-14 результат операций выбранной в 3-м select к числам введенным в
                                первом и
                                втором input. Например выбрано 1 13 +, нужно вывести результат операции 1+13 т.е.
                                14.</p>
                            <input aria-label="number input" type="number" id="i-14">
                            <input aria-label="number input" type="number" id="o-14">
                            <label>тип операции</label>
                            <select aria-label="selector" id="s-14">
                                <option value="+">+</option>
                                <option value="-">-</option>
                                <option value="*">*</option>
                                <option value="/">/</option>
                            </select>
                            <button id="b-14">клацай</button>
                            <div class="out-14">результат:</div>
                        </li>
                        <li>
                            <p>Дан select s-151 и s-152, каждый из которых содержит 1 и 0. Дан select s-153, который
                                содержит
                                две
                                операции - && и || . Дана кнопка b-15, при нажатии на которую срабатывает функция f15.
                                Функция выводит в out-15 результат логических операций выбранных в 3 select к числам
                                выбранным в
                                первом и втором select. Например выбрано 1 1 &&, нужно вывести результат операции 1&&1
                                т.е.
                                1
                                или
                                0.</p>
                            <select aria-label="selector" id="s-15">
                                <option value="1">1</option>
                                <option value="0">0</option>
                            </select>
                            <select aria-label="selector" id="o-15">
                                <option value="1">1</option>
                                <option value="0">0</option>
                            </select>
                            <select aria-label="selector" id="z-15">
                                <option value="&&">&&</option>
                                <option value="||">||</option>
                            </select>
                            <button id="b-15">клацай</button>
                            <div class="out-15">результат:</div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson4">UNIT 4. РАБОТАЕМ С ФОРМАМИ: INPUT, RANGE, TEXTAREA, CHECKBOX...</h4>

                    <input aria-label="password input" type="password" id="inpas" placeholder="type = 'password'">
                    <button id="butinpas">accept</button>
                    <div class="showinpas">password</div>
                    <br>

                    <input aria-label="color input" type='color' id="incol">
                    <button id="butincol">accept</button>
                    <div class="showincol">color id</div>
                    <br>

                    <input aria-label="date input" type='date' id="indate">
                    <button id="butindate">accept</button>
                    <div class="showindate">date</div>
                    <br>

                    <input aria-label="range input" type='range' id="inrange" min="0" max="200" value="50">
                    <div class="showinrange">range</div>
                    <br>

                    <input type="checkbox" id="incheckbox" value="hallo"><label for="incheckbox">click checkbox</label>
                    <button id="butcheckbox">accept</button>
                    <div class="showcheckbox">checkbox</div>
                    <br>

                    <form id="formexamp">
                        <textarea aria-label="textarea" id="textarea" cols="30" rows="10"></textarea>
                        <input aria-label="text input" type="text" id="inptextform">
                        <button id="butform">push</button>
                        <div class="showform">результат</div>
                    </form>

                    <ol>
                        <li>
                            <p>Создайте button - при нажатии на него выводите alert с номером задачи.</p>
                            <button id="buttinp1">Алерт: номер задачи</button>
                        </li>
                        <li>
                            <p>Создайте input type=button - при нажатии на него выводите alert с номером задачи. Номер
                                задачи
                                просто
                                пропишите вручную.</p>
                            <input type="button" id="buttinp2" value="Алерт: номер задачи">
                        </li>
                        <li>
                            <p>Создайте p - при нажатии на него выводите alert с номером задачи.</p>
                            <p class="pinp3">Алерт: номер задачи</p>
                        </li>
                        <li>
                            <p>Создайте input(checkbox) и button - при нажатии на кнопку выводите true если checkbox
                                выбран
                                и
                                false
                                если не выбран.</p>
                            <input aria-label="checkbox input" type="checkbox" id="checkinp4">
                            <button id="buttinp4">чекай</button>
                            <div class="outinp4">out-4</div>
                        </li>
                        <li>
                            <p>Создайте input(checkbox).i-5 и button.b-5. Для checkbox добавьте value="task-5" - при
                                нажатии
                                на
                                кнопку b-5 выводите value checkbox если checkbox выбран и false если не выбран.
                                Вывод везде в задачах, где не указано другое, осуществляется в div.out-номер задачи. В
                                данном
                                случае
                                div.out-5.</p>
                            <input aria-label="checkbox input" type="checkbox" id="checkinp5" value="task-5">
                            <button id="buttinp5">чекай</button>
                            <div class="outinp5">out-5</div>
                        </li>
                        <li>
                            <p>Создайте input(hidden) и button - при нажатии на кнопку выводите value из input в div</p>
                            <input type="hidden" id="checkinp6" value="8987">
                            <button id="buttinp6">чекай</button>
                            <div class="outinp6">out-6</div>
                        </li>
                        <li>
                            <p>Создайте input(password) и button - при нажатии на кнопку выводите в div.outinp71 value
                                прописанное в
                                input.
                                В div.outinp72 выводите 1 если длина пароля больше или равна 6 или 0 если меньше. Для
                                подсчета
                                количества символов в строке используйте length.</p>
                            <input aria-label="password input" type="password" id="checkinp7">
                            <button id="buttinp7">чекай</button>
                            <div class="outinp71">пароль:</div>
                            <div class="outinp72">0/1</div>
                        </li>
                        <li>
                            <p>Создайте div и button. При нажатии кнопки создавайте внутри div элемент input и кнопку
                                (innerHTML).
                                Добавьте на созданную кнопку событие клик и запуск функции. Функция должна в out(2)
                                выводить
                                value
                                созданного input.</p>
                            <button id="buttinp81">создай инпут</button>
                            <div class="outinp81"></div>
                        </li>
                        <li>
                            <p>Создайте один input(radio) и button - при нажатии на button если radio выбран (активен,
                                checked)
                                выводите в div - value прописанное в input, либо 0 если не активен.</p>
                            <input aria-label="radio input" type="radio" id="radioinp9" value="6572">
                            <button id="buttinp9">чекай</button>
                            <div class="outinp9">out-9</div>
                        </li>
                        <li>
                            <p>Создайте input(color) и button - при нажатии на кнопку окрашивайте div выбранным цветом
                                (имеется
                                ввиду .style.background).</p>
                            <input aria-label="color input" type="color" id="colorinp10">
                            <button id="buttinp10">крась</button>
                            <div class="outinp10">красить здесь</div>
                        </li>
                        <li>
                            <p>Создайте input(color).colorinp111 и input(color).colorinp112- два элемента и button - при
                                нажатии
                                на
                                кнопку присвойте цвет из первого input в value второго.</p>
                            <input aria-label="color input" type="color" id="colorinp111">
                            <input aria-label="color input" type="color" id="colorinp112">
                            <button id="buttinp11">крась</button>
                        </li>
                        <li>
                            <p>Создайте input(date) и button - при нажатии на кнопку выводите в div выбранную в input
                                дату.</p>
                            <input aria-label="date input" type="date" id="dateinp12">
                            <button id="buttinp12">внести время</button>
                            <div class="outinp12">время</div>
                        </li>
                        <li>
                            <p>Создайте input(range). При изменении положения ползунка input выводите значение в out.
                                Для
                                события
                                используйте oninput.</p>
                            <input aria-label="range input" type="range" id="rangeinp13">
                            <div class="outinp13">out-13</div>
                        </li>
                        <li>
                            <p>Создайте text-area и button - при нажатии на кнопку выводите в out-14 текст введенный в
                                text-area</p>
                            <textarea aria-label="textarea14" id="textarea14"></textarea>
                            <button id="buttinp14">клац</button>
                            <div class="outinp14">out-14</div>
                        </li>
                        <li>
                            <p>Создайте text-area input и button - при нажатии на кнопку выводите текст из input в
                                textarea
                                и на
                                страницу в out-15.</p>
                            <textarea aria-label="select15" id="textarea15"></textarea>
                            <input aria-label="textinp15" type="text" id="textinp15">
                            <button id="buttinp15">клац</button>
                            <div class="outinp15">out-15</div>
                        </li>
                        <li>
                            <p>Создайте select и button - при нажатии на кнопку выводите в out-16 value выбранного
                                option из
                                select16.</p>
                            <select aria-label="select16" id="select16">
                                <option value="one">1</option>
                                <option value="two">2</option>
                                <option value="five">5</option>
                            </select>
                            <button id="buttinp16">клац</button>
                            <div class="outinp16">out-16</div>
                        </li>
                        <li>
                            <p>Создайте select. Добавьте ему событие onchange, при наступлении которого запускается
                                функция.
                                Функция
                                должна выводить в out-17 value выбранного в select option.</p>
                            <select aria-label="select17" id="select17">
                                <option value="one">1</option>
                                <option value="two">2</option>
                                <option value="five">5</option>
                            </select>
                            <div class="outinp17">out-16</div>
                        </li>
                        <li>
                            <p>Создайте select и input. Добавьте на select событие onchange, при наступлении которого
                                запускается
                                функция. Функция должна выводить в input value выбранного в select option.</p>
                            <select aria-label="select18" id="select18">
                                <option value="one">1</option>
                                <option value="two">2</option>
                                <option value="five">5</option>
                            </select>
                            <input aria-label="textinp18" type="text" id="textinp18">
                        </li>
                        <li>
                            <p>Создайте форму. В ней input(text).textinp191 и input(password).passinp192 - и кнопку
                                button.
                                По
                                нажатию кнопки выводите значение text и password в out-19 через пробел.
                                Обратите внимание на хитрость. Мы, кнопку сейчас повесили за пределами формы. Чуть позже
                                мы
                                рассмотрим почему это делали.</p>
                            <form>
                                <input aria-label="textinp191" type="text" id="textinp191">
                                <input aria-label="passinp192" type="password" id="passinp192">
                            </form>
                            <button id="buttinp19">клац</button>
                            <div class="outinp19">Task-19</div>
                        </li>
                        <li>
                            <p>Создайте форму. В ней input(text) и input(password) - и кнопку button. По нажатию кнопки
                                выводите
                                значение из input text и password в out-20 через пробел. Используйте form.elements.</p>
                            <form id="forminp20">
                                <input aria-label="username" type="text" name="username">
                                <input aria-label="password" type="password" name="password">
                            </form>
                            <button id="buttinp20">клац</button>
                            <div class="outinp20"></div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson5">UNIT 5. ЦИКЛЫ В JAVASCRIPT (ЧАСТЬ 1)</h4>

                    <pre>
let divfor = document.querySelectorAll('.divfor div');
console.log(divfor);
for (let i = 0; i &lt; divfor.length; i = i + 1) {
    console.log(divfor[i]);
    divfor[i].style.background = 'red';
};
    </pre>

                    <div class="divfor">
                        <div class="divfor">1</div>
                        <div class="divfor">2</div>
                        <div class="divfor">3</div>
                        <div class="divfor">4</div>
                        <div class="divfor">5</div>
                    </div>
                    <label class='radiodiv'><input type="radio" name="r" value="1" checked>один</label>
                    <label class='radiodiv'><input type="radio" name="r" value="2">два</label>
                    <label class='radiodiv'><input type="radio" name="r" value="3">три</label>
                    <button id="radiobut">push</button>
                    <br>
                    <div class="divout">вывод цикла</div>

                    <hr>

                    <h4>Задачи:</h4>

                    <ul>
                        <li>Кнопка b-1 запускает функцию t1. Функция должна выводить в out-1 строку вида: 1 2 3 4 5 6 7
                            8 9
                            ...
                            49
                            50. От 1 до 50 включительно. Разделитель - пробел. Задача решается с помощью цикла.
                            <ul>
                                <li>
                                    <div class="showcycle">решение</div>
                                    <button id="cyclebut">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Кнопка b-2 запускает функцию t2. Функция должна выводить в out-2 строку вида: 2 4 6 ... 122.
                            От
                            2 до
                            122
                            c шагом 2. Разделитель - пробел. Задача решается с помощью цикла.
                            <ul>
                                <li>
                                    <div class="showcycle1">решение</div>
                                    <button id="cyclebut1">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Кнопка b-3 запускает функцию t3. Функция должна выводить в out-3 строку вида: 25 24 23 22
                            ... 7.
                            От
                            25
                            до 7 c шагом 1. Разделитель - пробел. Задача решается с помощью цикла.
                            <ul>
                                <li>
                                    <div class="showcycle2">решение</div>
                                    <button id="cyclebut2">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Кнопка b-4 запускает функцию t4. Функция должна выводить в out-4 строку вида:
                            77_74_71_68_65_62_
                            ...
                            _38_35_. От 77 до 35 c шагом 3. Разделитель - знак подчеркивания. Задача решается с помощью
                            цикла.
                            <ul>
                                <li>
                                    <div class="showcycle3">решение</div>
                                    <button id="cyclebut3">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Кнопка b-5 запускает функцию t5. Функция должна выводить в out-5 строку вида: 1_*2_**3_*4_**
                            ...
                            17_* от
                            1 до 17 c шагом 1. Разделитель - знак подчеркивания и звездочка (если число нечетное, и две
                            звездочки
                            если четное). Задача решается с помощью цикла.
                            <ul>
                                <li>
                                    <div class="showcycle4">решение</div>
                                    <button id="cyclebut4">push</button>
                                </li>
                            </ul>
                        </li>
                        <li><p>Кнопка b-6 запускает функцию t6. Функция должна выводить в out-6 строку вида:</p>
                            <p>******</p>
                            <p>******</p>
                            <p>******</p>
                            <p>Задача решается с помощью цикла. В каждой итерации цикл выводит 6 звездочек без пробелов
                                и
                                символ
                                переноса строки br. Количество строк (итераций, повторений) цикла вводит пользователь в
                                i-6.
                            <ul>
                                <li>
                                    <div class="showcycle5">решение</div>
                                    <button id="cyclebut5">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Есть input i-7 куда пользователь может ввести число больше нуля (проверок не делаем,
                            принимаем
                            как
                            факт). По нажатию кнопки b-7 должна запускаться функция t7, которая выводит в out-7 числа от
                            введенного
                            пользователем до нуля включительно. Разделитель пробел. Если пользователь ввел 4 и нажал
                            кнопку,
                            мы
                            получим: 4 3 2 1 0. Задача решается с помощью цикла.
                            <ul>
                                <li><input aria-label="cyclein" type="number" id="cyclein">
                                    <div class="showcycle6">решение</div>
                                    <button id="cyclebut6">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Есть input i-81 и i-82 куда пользователь может ввести числа больше нуля (проверок не делаем,
                            принимаем
                            как факт). Считаем, что второе число всегда больше первого. По нажатию кнопки b-8 должна
                            запускаться
                            функция t8, которая выводит в out-8 числа от первого введенного до второго включительно, с
                            шагом
                            1.
                            Разделитель пробел. Если пользователь ввел 4 и 8 и нажал кнопку, мы получим: 4 5 6 7 8.
                            Задача
                            решается
                            с помощью цикла.
                            <ul>
                                <li>
                                    <input aria-label="fircyclein" type="number" id="fircyclein">
                                    <input aria-label="seccyclein" type="number" id="seccyclein">
                                    <div class="showcycle7">решение</div>
                                    <button id="cyclebut7">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Есть input i-91 и i-92 куда пользователь может ввести числа. По нажатию кнопки b-9 должна
                            запускаться
                            функция t9, которая выводит в out-9 числа от меньшего введенного до большего включительно, с
                            шагом
                            1.
                            Разделитель пробел. Если пользователь ввел 4 и 8 и нажал кнопку, мы получим: 4 5 6 7 8. Eсли
                            ввел 8
                            и 6,
                            то получим 6 7 8. Задача решается с помощью цикла. Подсказка - вначале делаем проверку, а
                            потом
                            запускаем цикл.
                            <ul>
                                <li>
                                    <input aria-label="fircyclein1" type="number" id="fircyclein1">
                                    <input aria-label="seccyclein1" type="number" id="seccyclein1">
                                    <div class="showcycle8">решение</div>
                                    <button id="cyclebut8">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Кнопка b-10 запускает функцию t10. Функция должна выводить в out-10 четные годы от 1950 до
                            2000
                            включительно. Разделитель - пробел. Задача решается через цикл, а четность - через шаг
                            (равный
                            2).
                            <ul>
                                <li>
                                    <div class="showcycle9">решение</div>
                                    <button id="cyclebut9">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Кнопка b-11 запускает функцию t11. Функция должна: получить все div.div-11 перебрать их с
                            помощью
                            цикла.
                            Обращение к div выглядит так elem[i] вывести в out-11 содержимое каждого блока. Разделитель
                            -
                            пробел. В
                            результате должно получиться так: one 3 4 two.
                            <ul>
                                <li>
                                    <div class="div-11">one</div>
                                    <div class="div-11">3</div>
                                    <div class="div-11">4</div>
                                    <div class="div-11">two</div>
                                    <button id="cyclebut10">push</button>
                                    <div class="showcycle10"></div>
                                </li>
                            </ul>
                        </li>
                        <li>Кнопка b-12 запускает функцию t12. Функция должна: получить все div.div-12 перебрать их с
                            помощью
                            цикла.
                            Обращение к div выглядит так elem[i] применить к каждому elem[i].style.background = ‘orange’
                            <ul>
                                <li>
                                    <div class="div-12">Div 12</div>
                                    <div class="div-12">Div 12</div>
                                    <div class="div-12">Div 12</div>
                                    <button id="cyclebut11">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Кнопка b-13 запускает функцию t13. Функция должна: получить все input.i-13 перебрать их с
                            помощью
                            цикла.
                            Обращение к элементу выглядит так elem[i] применить к каждому elem[i].value, причем к value
                            первого
                            должно равняться 1, второго - 2, третьего - 3...
                            <ul>
                                <li>
                                    <div class="form-control">
                                        <label>Input i-13</label>
                                        <input aria-label="Enter some info" type="text" placeholder="Enter some info"
                                               class="i-13">
                                    </div>
                                    <div class="form-control">
                                        <label>Input i-13</label>
                                        <input aria-label="Enter some info" type="text" placeholder="Enter some info"
                                               class="i-13">
                                    </div>
                                    <div class="form-control">
                                        <label>Input i-13</label>
                                        <input aria-label="Enter some info" type="text" placeholder="Enter some info"
                                               class="i-13">
                                    </div>
                                    <button id="cyclebut12">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Кнопка b-14 запускает функцию t14 Функция должна:
                            получить все input.i-14
                            перебрать их с помощью цикла. Обращение к элементу выглядит так elem[i]
                            вывести в out-14 value выбранного. Проверить выбран ли элемент можно с помощью
                            elem[i].checked.
                            <ul>
                                <li>
                                    <fieldset>
                                        <legend>Input i-14</legend>
                                        <div class="form-control">
                                            <label><input type="radio" name="i-14" class="i-14" checked
                                                          value="333">Radio</label>
                                        </div>
                                        <div class="form-control">
                                            <label><input type="radio" name="i-14" class="i-14"
                                                          value="444">Radio</label>
                                        </div>
                                        <div class="form-control">
                                            <label><input type="radio" name="i-14" class="i-14"
                                                          value="555">Radio</label>
                                        </div>
                                    </fieldset>
                                    <div class="showcycle13">решение</div>
                                    <button id="cyclebut13">push</button>
                                </li>
                            </ul>
                        </li>
                        <li>Кнопка b-15 запускает функцию t15 Функция должна выводить следующую последовательность в
                            out-15:
                            10
                            0 9
                            1 8 2 7 3 6 4 5 5 4 6 3 7 2 8 1 9 0 10 Для вывода использовать цикл.
                            <ul>
                                <li>
                                    <div class="showcycle14">решение</div>
                                    <button id="cyclebut14">push</button>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </section>

                <section>
                    <h4 id="JSlesson6">UNIT 6. ВЛОЖЕННЫЕ ЦИКЛЫ В JAVASCRIPT (ЧАСТЬ 2)</h4>

                    <div class="outstars"></div>
                    <div class="outtable"></div>

                    <h4>Задачи:</h4>

                    <ol>
                        <li>
                            <p>С помощью вложенных циклов, нарисуйте строку: ***_***_***_ ,где звездочки рисуются с
                                помощью
                                внутреннего цикла от 0 до 3, а _ с помощью внешнего.</p>
                            <div class="outstars1"></div>
                        </li>
                        <li>
                            <p>С помощью вложенных циклов, нарисуйте строку:</p>
                            <pre>
1
*_*_*_
2
*_*_*_
3
*_*_*_
            </pre>
                            <p>Решить задачу с помощью вложенных циклов. Внешний цикл выводит цифры и перенос строки br,
                                ,
                                второй
                                звездочки, знак подчеркивания и знак переноса.</p>
                            <div class="outstars2"></div>
                        </li>
                        <li>
                            <p>С помощью вложенных циклов, нарисуйте строку:</p>
                            <pre>
*_*_*_
*_*_*_
*_*_*_
*_*_*_
            </pre>
                            <p>Решить задачу с помощью вложенных циклов. Внешний цикл выводит перенос строки br,
                                внутренний
                                -
                                звездочки, знак подчеркивания.</p>
                            <div class="outstars3"></div>
                        </li>
                        <li>
                            <p>С помощью вложенных циклов, нарисуйте строку: 1_1 2 3 4 5 2_1 2 3 4 5 3_1 2 3 4 5</p>
                            <div class="outstars4"></div>
                        </li>
                        <li>
                            <p>С помощью вложенных циклов, нарисуйте строку:</p>
                            <pre>
101010
101010
101010
            </pre>
                            <p>Внешний цикл выводит перенос строки br. Вложенный цикл от 0 до 6 выводит либо 0 либо
                                1.</p>
                            <div class="outstars5"></div>
                        </li>
                        <li>
                            <p>С помощью вложенных циклов, нарисуйте строку:</p>
                            <pre>
10x01x
10x01x
10x01x
            </pre>
                            <p>Внешний цикл выводит перенос строки br. Вложенный цикл от 0 до 6 выводит либо 0 либо 1
                                либо
                                х.</p>
                            <div class="outstars6"></div>
                        </li>
                        <li>
                            <p>Внешний цикл выводит перенос строки br. Вложенный цикл запускается от нуля до i и рисует
                                звездочку.</p>
                            <pre>
*
**
***
****
            </pre>
                            <div class="outstars7"></div>
                        </li>
                        <li>
                            <p>С помощью вложенных циклов, нарисуйте строку:</p>
                            <pre>
*****
****
***
**
*
            </pre>
                            <p>Внешний цикл выводит перенос строки br. Вложенный цикл рисует звездочки.</p>
                            <div class="outstars8"></div>
                        </li>
                        <li>
                            <p>С помощью вложенных циклов, нарисуйте строку:</p>
                            <pre>
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
            </pre>
                            <p>Внешний цикл выводит перенос строки br. Вложенный цикл рисует цифры</p>
                            <div class="outstars9"></div>
                        </li>
                        <li>
                            <p>С помощью вложенных циклов, нарисуйте строку:</p>
                            <pre>
01 02 03 04 05 06 07 08 09 10
11 12 13 14 15 16 17 18 19 20
21 22 23 24 25 26 27 28 29 30
31 32 33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48 49 50
            </pre>
                            <p>Внешний цикл выводит перенос строки br и запускается от 0 до 6. Вложенный цикл рисует
                                цифры
                                от 0
                                до
                                9. Обратите внимание, что первый ряд - есть ведущий нуль. Здесь все просто - проверили,
                                если
                                число
                                меньше 10 - то конкатенируем нуль</p>
                            <div class="outstars10"></div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson7">UNIT 7. ФУНКЦИИ И ВСЕ О НИХ</h4>

                    <ol>
                        <li>
                            <p>Напишите функцию t1, которая при нажатии кнопки выводит в out-1 переменную a1. let a1 =
                                8;</p>
                            <button id="funcbutt">вывести значение</button>
                            <div class="outstars11">1</div>
                        </li>
                        <li>
                            <p>Изменим задачу 1. Сейчас она только выводит переменную в заранее заданный блок. Давайте
                                сделаем
                                так,
                                чтобы функция, была более гибкой. Пусть теперь функция t2 возвращает переменную a2.
                                Поскольку
                                функция возвращает переменную, то имя функции со скобками (вызов функции) можно
                                встраивать в
                                выражения. Обратите внимание, как изменился вызов функции. let a2 = 8;</p>
                            <button id="funcbutt1">вывести значение</button>
                            <div class="outstars12"></div>
                        </li>
                        <li>
                            <p>Наша предыдущая функция, сильно все еще зависима от внешних переменных. Давайте сделаем
                                ее
                                более
                                универсальной. Пусть функция t3 принимает 2 параметра и выводит их произведение.
                                Допишите
                                код
                                функции так, чтобы она возвращала произведение двух чисел, переданных ей в качестве
                                параметра a,
                                b.
                                Протестируем функцию на двух примерах, с помощью кнопок b3-1 и b3-2.</p>
                            <button id="funcbutt2">вывести значение</button>
                            <button id="funcbutt3">вывести значение</button>
                            <div class="outstars13"></div>
                        </li>
                        <li>
                            <p>Напишите функцию t4 которая принимает ваш год рождения и вычисляет ваш возраст.</p>
                            <input aria-label="inputbrthdate" type="number" id="inputbrthdate">
                            <button id="funcbutt14">вывести возраст</button>
                            <div class="outstars14"></div>
                        </li>
                        <li>
                            <p>Напишите функцию t5, которая принимает ваше имя в качестве параметра и возвращает строку
                                Hello
                                name,
                                где name - принятое в качестве параметра имя.</p>
                            <button id="funcbutt15">вывести значение</button>
                            <div class="outstars15"></div>
                        </li>
                        <li>
                            <p>Напишите функцию, которая принимает 2 числа и возвращает случайное целое число от первого
                                до
                                второго
                                принятого параметра.</p>
                            <input aria-label="inputnumb" type="number" id="inputnumb">
                            <input aria-label="inputnumb1" type="number" id="inputnumb1">
                            <button id="funcbutt16">вывести значение</button>
                            <div class="outstars16"></div>
                        </li>
                        <li>
                            <p>Напишите функцию, которая возвращает случайный цвет в формате rgb(x,y,z). Где x,y,z -
                                случайные
                                числа
                                в диапазоне [0, 255].</p>
                            <button id="funcbutt17">вывести значение</button>
                            <div class="outstars17">цвет</div>
                        </li>
                        <li>
                            <p>Напишите функцию t8, которая принимает строку в качестве параметра и возвращает результат
                                с
                                очищенными пробелами в начале и вконце строки. Т.е. принимает _hello_ (где знак _
                                символизирует
                                пробел), а возвращает hello. Для удаления пробелов - используйте trim.</p>
                            <button id="funcbutt18">вывести значение</button>
                            <div class="outstars18"></div>
                        </li>
                        <li>
                            <p>Напишите функцию t9, которая принимает число и возвращает true, если число четное, и
                                false
                                если
                                не
                                четное.</p>
                            <input aria-label="inputnumb2" type="number" id="inputnumb2">
                            <button id="funcbutt19">вывести значение</button>
                            <div class="outstars19"></div>
                        </li>
                        <li>
                            <p>Создайте функцию t10, которая принимает 2 числа и возвращает большее из них. В случае
                                равенства -
                                любое из чисел.</p>
                            <input aria-label="inputnumb3" type="number" id="inputnumb3">
                            <input aria-label="inputnumb4" type="number" id="inputnumb4">
                            <button id="funcbutt20">вывести значение</button>
                            <div class="outstars20"></div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson8">UNIT 8. ЦИКЛ WHILE, DO WHILE</h4>

                    <div class="outstars21"></div>

                    <ol>
                        <li>
                            <p>Кнопка запускает функцию t30. Функция должна выводить в div строку вида: 1 2 3 4 5 6 7 8
                                9
                                ... 49
                                50
                                от 1 до 50 включительно. Разделитель - пробел. Задача решается с помощью цикла
                                while.</p>
                            <button id="funcbutt21">вывести значение</button>
                            <div class="outwhile1"></div>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t31. Функция должна выводить в div строку вида: 2 4 6 ... 122 от
                                2
                                до
                                122 c
                                шагом 2. Разделитель - пробел. Задача решается с помощью цикла while.</p>
                            <button id="funcbutt22">вывести значение</button>
                            <div class="outwhile2"></div>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t32. Функция должна выводить в div строку вида: 25 24 23 22 . .
                                7 от
                                25
                                до 7
                                c шагом 1. Разделитель - пробел. Задача решается с помощью цикла while.</p>
                            <button id="funcbutt23">вывести значение</button>
                            <div class="outwhile3"></div>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t33. Функция должна выводить в div строку вида:
                                77_74_71_68_65_62_
                                ...
                                _38_35_ от 77 до 35 c шагом 3. Разделитель - знак подчеркивания. Задача решается с
                                помощью
                                цикла
                                while.</p>
                            <button id="funcbutt24">вывести значение</button>
                            <div class="outwhile4"></div>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t34. Функция должна выводить в div строку вида: 1_*2_**3_*4_**
                                ...
                                17_*
                                от 1
                                до 17 c шагом 1. Разделитель - знак подчеркивания и звездочка (если число нечетное, и
                                две
                                звездочки
                                если четное). Задача решается с помощью цикла while.</p>
                            <button id="funcbutt25">вывести значение</button>
                            <div class="outwhile5"></div>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t35. Функция должна выводить в div строку вида:</p>
                            <pre>
******

******

******
            </pre>
                            <p>Задача решается с помощью цикла. В каждой итерации цикл выводит 6 звездочек без пробелов
                                и
                                символ
                                переноса строки br. Количество строк (итераций, повторений) цикла while вводит
                                пользователь
                                в
                                input.</p>
                            <input aria-label="inputwhile6" type="number" id="inputwhile6">
                            <button id="funcbutt26">вывести значение</button>
                            <div class="outwhile6"></div>
                        </li>
                        <li>
                            <p>Есть input куда пользователь может ввести число больше нуля (проверок не делаем,
                                принимаем
                                как
                                факт).
                                По нажатию кнопки должна запускаться функция t36, которая выводит в div числа от
                                введенного
                                пользователем до нуля включительно. Разделитель пробел. Если пользователь ввел 4 и нажал
                                кнопку,
                                мы
                                получим: 4 3 2 1 0. Задача решается с помощью цикла while.</p>
                            <input aria-label="inputwhile7" type="number" id="inputwhile7">
                            <button id="funcbutt27">вывести значение</button>
                            <div class="outwhile7"></div>
                        </li>
                        <li>
                            <p>Есть два input куда пользователь может ввести числа больше нуля (проверок не делаем,
                                принимаем
                                как
                                факт). Считаем, что второе число всегда больше первого. По нажатию кнопки должна
                                запускаться
                                функция
                                t37, которая выводит в div числа от первого введенного до второго включительно, с шагом
                                1.
                                Разделитель пробел. Если пользователь ввел 4 и 8 и нажал кнопку, мы получим: 4 5 6 7 8.
                                Задача
                                решается с помощью цикла while.</p>
                            <input aria-label="inputwhile8" type="number" id="inputwhile8">
                            <input aria-label="inputwhile9" type="number" id="inputwhile9">
                            <button id="funcbutt28">вывести значение</button>
                            <div class="outwhile8"></div>
                        </li>
                        <li>
                            <p>Есть два input куда пользователь может ввести числа. По нажатию кнопки должна запускаться
                                функция
                                t38, которая выводит в div числа от меньшего введенного до большего включительно, с
                                шагом 1.
                                Разделитель пробел. Если пользователь ввел 4 и 8 и нажал кнопку, мы получим:4 5 6 7 8
                                если ввел 8 и 6, то получим 6 7 8. Задача решается с помощью цикла. Подсказка - вначале
                                делаем
                                проверку, а потом запускаем цикл while.</p>
                            <input aria-label="inputwhile10" type="number" id="inputwhile10">
                            <input aria-label="inputwhile11" type="number" id="inputwhile11">
                            <button id="funcbutt29">вывести значение</button>
                            <div class="outwhile9"></div>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t39. Функция должна выводить в div четные годы от 1950 до 2000
                                включительно.
                                Разделитель - пробел. Задача решается через цикл while, а четность - через шаг (равный
                                2).</p>
                            <button id="funcbutt30">вывести значение</button>
                            <div class="outwhile10"></div>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t40. Функция должна: получить все div.divt40 перебрать их с
                                помощью
                                цикла
                                while. Обращение к div выглядит так elem[i] вывести в div содержимое каждого блока.
                                Разделитель
                                -
                                пробел. В результате должно получиться так: one 3 4 two</p>
                            <div class="divt40">one</div>
                            <div class="divt40">3</div>
                            <div class="divt40">4</div>
                            <div class="divt40">two</div>
                            <button id="funcbutt31">вывести значение</button>
                            <div class="outwhile11"></div>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t41. Функция должна: получить все divt41 перебрать их с помощью
                                цикла.
                                Обращение к div выглядит так elem[i] применить к каждому elem[i].style.background =
                                ‘orange’</p>
                            <div class="divt41">one</div>
                            <div class="divt41">3</div>
                            <div class="divt41">4</div>
                            <div class="divt41">two</div>
                            <button id="funcbutt32">окрасить</button>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t42. Функция должна: получить все input перебрать их с помощью
                                цикла.
                                Обращение к элементу выглядит так elem[i] применить к каждому elem[i].value, причем к
                                value
                                первого
                                должно равняться 1, второго - 2, третьего - 3...</p>
                            <input aria-label="inputwhile13" type="number" class="inputwhile13">
                            <input aria-label="inputwhile13" type="number" class="inputwhile13">
                            <input aria-label="inputwhile13" type="number" class="inputwhile13">
                            <button id="funcbutt33">вывести значение</button>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t43 Функция должна: получить все input перебрать их с помощью
                                цикла.
                                Обращение к элементу выглядит так elem[i] вывести в div value выбранного. Проверить
                                выбран
                                ли
                                элемент можно с помощью elem[i].checked.</p>
                            <fieldset>
                                <legend>Input i-14</legend>
                                <div class="form-control">
                                    <label><input type="radio" name="i-14" class="radiowhile" checked
                                                  value="333">Radio</label>
                                </div>
                                <div class="form-control">
                                    <label><input type="radio" name="i-14" class="radiowhile" value="444">Radio</label>
                                </div>
                                <div class="form-control">
                                    <label><input type="radio" name="i-14" class="radiowhile" value="555">Radio</label>
                                </div>
                            </fieldset>
                            <button id="funcbutt34">вывести значение</button>
                            <div class="outwhile14"></div>
                        </li>
                        <li>
                            <p>Кнопка запускает функцию t44. Функция должна выводить следующую последовательность в div:
                                10
                                0 9
                                1 8
                                2 7 3 6 4 5 5 4 6 3 7 2 8 1 9 0 10.Для вывода использовать цикл.</p>
                            <button id="funcbutt35">вывести значение</button>
                            <div class="outwhile15"></div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson9">UNIT 9. РАБОТАЕМ С DOM</h4>

                    <button class="toggle">toggle</button>
                    <br>
                    <p class="showstyle" data-showstyle="hello">Test</p>

                    <input aria-label="text input" type="text" class="gallons" placeholder="консоль">
                    <div>
                        <button class="gas" data-gas="1.2">A 92</button>
                        <button class="gas" data-gas="1.6">A 95</button>
                        <button class="gas" data-gas="1.9">A 98</button>
                    </div>
                    <br>

                    <div class="addtext">Text</div>
                    <br>

                    <ol>
                        <li>
                            <p>Добавьте кнопку, которая запускает функцию funct1. Функция присваивает блоку outdom
                                ширину
                                200px,
                                высоту 40px.</p>
                            <button id="dombut1">Task-1</button>
                            <div class="outdom1 bg-red">out-1</div>
                        </li>
                        <li>
                            <p>По нажатию кнопки запускайте функцию funct2, которая присваивает блоку out-2 класс
                                .bg-2.</p>
                            <button id="dombut2">Task-2</button>
                            <div class="outdom2">out-2</div>
                        </li>
                        <li>
                            <p>По нажатию кнопки запускайте функцию funct3, которая удаляет у блока out-3 класс
                                .bg-3.</p>
                            <button id="dombut3">Task-3</button>
                            <div class="outdom3 bg-3">out-3</div>
                        </li>
                        <li>
                            <p>По нажатию кнопки запускайте функцию funct4, которая делает toggle класса bg-4 для блока
                                out-4.</p>
                            <button id="dombut4">Task-4</button>
                            <div class="outdom4">out-4</div>
                        </li>
                        <li>
                            <p>По нажатию кнопки запускайте функцию funct5, которая проверяет наличие класса bg-4 у
                                блока
                                out-4
                                (да,
                                именно bg-4 у out-4 ). Результат - true или false, выводите в out-5.</p>
                            <button id="dombut5">Task-5</button>
                            <div class="outdom5">out-5</div>
                        </li>
                        <li>
                            <p>По нажатию кнопки запускайте функцию funct6, которая выводит в out-6 количество
                                параграфов с
                                классом
                                p-6.</p>
                            <p class="p-6">p-6</p>
                            <p class="p-6">p-6</p>
                            <p class="p-6">p-6</p>
                            <p class="p-6">p-6</p>
                            <p class="p-6">p-6</p>
                            <p class="p-6">p-6</p>
                            <button id="dombut6">Task-6</button>
                            <div class="outdom6">out-6</div>
                        </li>
                        <li>
                            <p>По нажатию кнопки запускайте функцию funct7, которая присваивает блокам out-7 класс
                                .bg-7.
                                Обратите
                                внимание, что данных блоков больше одного, следовательно нужен цикл.</p>
                            <button id="dombut7">Task-7</button>
                            <div class="outdom7">out-7</div>
                            <div class="outdom7">out-7</div>
                            <div class="outdom7">out-7</div>
                        </li>
                        <li>
                            <p>По нажатию кнопки запускайте функцию funct8, которая делает toggle блокам out-8 класс
                                .bg-8.
                                Обратите
                                внимание, что данных блоков больше одного, следовательно нужен цикл.</p>

                            <button id="dombut8">Task-8</button>
                            <div class="outdom8 bg-8">out-8</div>
                            <div class="outdom8">out-8</div>
                            <div class="outdom8 bg-8">out-8</div>
                            <div class="outdom8">out-8</div>
                        </li>
                        <li>
                            <p>Усложним предыдущие задачи. С помощью цикла повесьте на блоки out-9 событие клик. По
                                клику
                                должна
                                выполняться функция funct9. Функция, должна добавлять класс bg-9 тому out-9 на котором
                                кликнули.</p>
                            <div class="outdom9">out-9</div>
                            <br>
                            <div class="outdom9">out-9</div>
                            <br>
                            <div class="outdom9">out-9</div>
                            <br>
                        </li>
                        <li>
                            <p>Усложним предыдущие задачи. С помощью цикла повесьте на блоки out-10 событие клик. По
                                клику
                                должна
                                выполняться функция funct10. Функция, должна делать toggle класса bg-10 тому out-10 на
                                котором
                                кликнули.</p>
                            <div class="outdom10 bg-10">out-10</div>
                            <div class="outdom10">out-10</div>
                            <div class="outdom10 bg-10">out-10</div>
                            <div class="outdom10">out-10</div>
                        </li>
                        <li>
                            <p>Добавьте кнопку, которая запускает функцию funct11. Функция создает через createElement
                                div c
                                текстом
                                25 и добавляет его через append в out-11.</p>
                            <button id="dombut11">Task-11</button>
                            <div class="outdom11">out-11</div>
                        </li>
                        <li>
                            <p>Добавьте кнопку, которая запускает функцию funct12. Функция создает через createElement
                                div c
                                текстом
                                12 и добавляет ему класс bg-12. Созданный div добавляется в out-12.</p>
                            <button id="dombut12">Task-12</button>
                            <div class="outdom12">out-12</div>
                        </li>
                        <li>
                            <p>Добавьте кнопку, которая запускает функцию funct13. Функция создает через createElement
                                div c
                                текстом
                                pushMe и добавляет ему класс bg-13. Также, созданному div добавляется событие onclick,
                                по
                                которому
                                выполняется функция funct13_1. Созданный div добавляется в out-13.</p>
                            <button id="dombut13">Task-13</button>
                            <div class="outdom13"></div>
                            <div class="outdom14"></div>
                        </li>
                        <li>
                            <p>Добавьте кнопку, которая запускает функцию funct14. Функция создает через createElement
                                div c
                                текстом
                                14 и добавляет ему класс bg-14. Созданный div добавляется в out-14 с помощью
                                prepend.</p>
                            <button id="dombut14">Task-14</button>
                            <div class="outdom14-1 bg-13">
                                This is out-14
                            </div>
                        </li>
                        <li>
                            <p>Добавьте кнопку, которая запускает функцию funct15. Функция создает через createElement
                                div c
                                текстом
                                15 и добавляет ему класс bg-15. Созданный div добавляется в out-15 с помощью before.</p>

                            <button id="dombut15">Task-15</button>
                            <div class="outdom15 bg-9">
                                This is out-15
                            </div>
                        </li>
                        <li>
                            <p>Добавьте кнопку .b-16, которая запускает функцию funct16. Функция создает через
                                createElement
                                div
                                c
                                текстом 16 и добавляет ему класс bg-16. Созданный div добавляется в out-16 с помощью
                                after.</p>
                            <button id="dombut16">Task-16</button>
                            <div class="outdom16 bg-4">
                                This is out-16
                            </div>
                        </li>
                        <li>
                            <p>Добавьте кнопку .b-17, которая запускает функцию funct17. Функция создает через
                                createElement
                                div
                                c
                                текстом 17 и добавляет ему класс bg-17. Созданный div заменяет out-17 с помощью
                                replaceWith.</p>
                            <button id="dombut17">Task-17</button>
                            <div class="outdom17 bg-13">
                                This is out-17
                            </div>
                        </li>
                        <li>
                            <p>Добавьте кнопку, которая запускает функцию funct18. Функция с помощью getAttribute
                                получает
                                data-b
                                атрибут с параграфа p-18 и выводит в out-18.</p>
                            <p class="p-18" data-b="hello">This is p-18</p>
                            <button id="dombut18">Task-18</button>
                            <div class="outdom18"></div>
                        </li>
                        <li>
                            <p>Добавьте кнопку, которая запускает функцию funct19. Функция с помощью getAttribute
                                получает
                                data-b
                                атрибут с параграфов p-19 и выводит в out-19 через пробел. Обратите внимание, что
                                элементов
                                p-19
                                больше одного.</p>

                            <p class="p-19" data-b="3">This is p-19</p>
                            <p class="p-19" data-b="14">This is p-19</p>
                            <p class="p-19" data-b="15">This is p-19</p>
                            <p class="p-19" data-b="92">This is p-19</p>

                            <button id="dombut19">Task-19</button>
                            <div class="outdom19"></div>
                        </li>
                        <li>
                            <p>Добавьте кнопку, которая запускает функцию funct20. Функция с помощью setAttribute
                                присваивает
                                атрибут title="go" в out-20.</p>
                            <button id="dombut20">Task-20</button>
                            <div class="outdom20">out-20</div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson10">UNIT 10. МАССИВЫ В JAVASCRIPT</h4>

                    <p>Массив это способ представления данных в связанном виде.</p>
                    <p>Длинна массива это индекс последнего элемента +1.</p>

                    <p>Массив:</p>
                    <div class="outarray"></div>

                    <ol>
                        <li>
                            <p>Создайте массив содержащий строки, числа, булевы значения. Выведите его в out-1. Вывод -
                                по
                                нажатию
                                кнопки.</p>
                            <button id="arraybut1">Task-1</button>
                            <div class="outarray1">out-1</div>
                        </li>
                        <li>
                            <p>Создайте массив содержащий строки, числа, булевы значения. Выведите его в div.out-2.
                                Используйте
                                шаблон вывода из кода в JS. Вывод - по нажатию кнопки.</p>
                            <button id="arraybut2">Task-2</button>
                            <div class="outarray2">out-2</div>
                        </li>
                        <li>
                            <p>Создайте массив "thirdarray = ['five', 6, true, false]", заполните его любыми значениями.
                                Выведите
                                длину массива.</p>
                            <button id="arraybut3">Task-3 (длинна массива)</button>
                            <div class="outarray3">out-3</div>
                        </li>
                        <li>
                            <p>Создайте массив "fourtharray = ['один', 2, 'три', 4, 'пять', 6, 'семь', 8, 'девять',
                                10];".
                                Выведите нулевой, третий, восьмой элемент массива в out-4 через пробел.</p>
                            <button id="arraybut4">Task-4</button>
                            <div class="outarray4">out-4</div>
                        </li>
                        <li>
                            <p>Создайте массив "fiftharray = [10,20,30,40,50,60,70,80,90,100];". Выведите сумму
                                нулевого,
                                второго
                                и третьего элементов массива (нуль, второй - и третий это индексы 0, 2, 3)</p>
                            <button id="arraybut5">Task-5</button>
                            <div class="outarray5">out-5</div>
                        </li>
                        <li>
                            <p>Создайте массив, который содержит ваше имя, знак зодиака, день рождения и месяц рождения.
                                Выведите
                                массив на страницу в out-6. Разделитель - пробел.</p>
                            <button id="arraybut6">Task-6</button>
                            <div class="outarray6">out-6</div>
                        </li>
                        <li>
                            <p>Добавьте в массив значения 'vietnam' с индексом 7 , 'turkey' с индексом 6, 'italy' с
                                индексом
                                5.
                                Добавление элементов сделайте в masfunct7. Выведите массив на страницу в .out-7.
                                Разделитель
                                -
                                пробел. Обращаю ваше внимание! Это программирование. Поэтому - никаких больших букв и
                                тому
                                подобного!!!!</p>
                            <button id="arraybut7">Task-7</button>
                            <div class="outarray7">out-7</div>
                        </li>
                        <li>
                            <p>Добавьте в массив третий (индекс 3) элемент равный 3.14, 4 (индекс 4) элемент равный 17,
                                6
                                элемент
                                (индекс 6) равный 5. Выведите массив в out-8. Разделитель - дефис. В out-8-1 выведите
                                длину
                                массива.</p>
                            <button id="arraybut8">Task-8</button>
                            <div class="outarray8">out-8</div>
                            <div class="outarray8-1">out-8-1</div>
                        </li>
                        <li>
                            <p>Выведите последний элемент массива. Вывод последнего элемента - реализуйте по индексу.
                                Чтобы
                                рассчитать индекс последнего элемента - используйте на длину массива.</p>
                            <button id="arraybut9">Task-9</button>
                            <div class="outarray9">out-9</div>
                        </li>
                        <li>
                            <p>Выведите сумму первого (индекс 1) и последнего массива "tentharray = [100, 200, 300, 400,
                                700,
                                121];" в блок out-10. Индекс последнего элемента массива не указывайте напрямую, а
                                вычисляйте
                                через
                                длину массива.</p>
                            <button id="arraybut10">Task-10</button>
                            <div class="outarray10">out-10</div>
                        </li>
                        <li>
                            <p>Напишите функцию, которая меняет местами второй (индекс 2) и четвертый (индекс 4) элемент
                                массива
                                "eleventharray = [2,3,4,5,6,7];" и выводит его в out-11. Разделитель - пробел.</p>
                            <button id="arraybut11">Task-11</button>
                            <div class="outarray11">out-11</div>
                        </li>
                        <li>
                            <p>Напишите функцию masfunct12, которая меняет местами нулевой и последний элемент массива
                                "twelftharray = ['test', 'west', 'list', 'class', 'best'];" и выводит его в out-12.
                                Разделитель -
                                пробел. Последний элемент вычислять через длину массива.</p>
                            <button id="arraybut12">Task-12</button>
                            <div class="outarray12">out-12</div>
                        </li>
                        <li>
                            <p>Выведите массив "thirteentharray = ['test', 'west', 'list', 'class', 'best'];" в out-13 в
                                формате
                                индекс пробел значение пробел.</p>
                            <button id="arraybut13">Task-13</button>
                            <div class="outarray13">out-13</div>
                        </li>
                        <li>
                            <p>Используя цикл выведите на страницу массив "fourteentharray = [1, 2, 3, 'hello', 66];" в
                                обратном
                                порядке. Разделитель - пробел.</p>
                            <button id="arraybut14">Task-14</button>
                            <div class="outarray14">out-14</div>
                        </li>
                        <li>
                            <p>Используя цикл выведите на страницу элементы массива "fifteentharray = [0, 2, 5, -4, 6,
                                22,
                                -9,
                                -12, 8, 12, 13, 78];", которые больше нуля. Разделитель - пробел.</p>
                            <button id="arraybut15">Task-15</button>
                            <div class="outarray15">out-15</div>
                        </li>
                        <li>
                            <p>Выполните перебор массива sixteenthassive. Четные элементы добавьте в массив
                                sixteenthassive_even,
                                нечетные в sixteenthassive_odd. Добавление в массив - по индексу, а не +=!!!!!.
                                Протестируйте
                                задачу
                                на повторный запуск! Выведите sixteenthassive_odd в out-16-odd, а sixteenthassive_even в
                                out-16-even. Разделитель - пробел.</p>
                            <button id="arraybut16">Task-16</button>
                            <div class="outarray16-odd">out-16-odd</div>
                            <div class="outarray16-even">out-16-even</div>
                        </li>
                        <li>
                            <p>Используя цикл выведите в out-17 количество элементов "seventeentharray = [3, 0, 2, 6, 0,
                                1, 3,
                                1,
                                9, 0, 2, 0];", значение которых больше 3. Для расчета используйте цикл и переменную
                                счетчик.</p>
                            <button id="arraybut17">Task-17</button>
                            <div class="outarray17">out-17</div>
                        </li>
                        <li>
                            <p>Используя цикл выведите в out-18 максимальный элемент массива "eighteentharray =
                                [15,24,13,78,21,4,45,67];".</p>
                            <button id="arraybut18">Task-18</button>
                            <div class="outarray18">out-18</div>
                        </li>
                        <li>
                            <p>Выведите в out-19 индекс минимального элемента в массиве "nineteentharray =
                                [15,424,313,78,241,4,45,67];" </p>
                            <button id="arraybut19">Task-19</button>
                            <div class="outarray19">out-19</div>
                        </li>
                        <li>
                            <p>Выведите в out-20 сумму элементов в массиве "twentietharray = [4,5,6,7,8,9,10];"</p>
                            <button id="arraybut20">Task-20</button>
                            <div class="outarray20">out-20</div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson11">UNIT 11. ДОБАВЛЕНИЕ И УДАЛЕНИЕ ЭЛЕМЕНТОВ В МАССИВЕ, POP, PUSH, SPLICE</h4>

                    <p>Метод "elem.push(значение)" позволяет вконец массива добавить элемент значение которого
                        указывается в
                        скобках </p>
                    <p>Метод "elem.pop(значение)" позволяет в конце массива удалить элемент </p>
                    <p>Оператор "delete массив[индекс]" удаляет элемент массива указанного индекса и оставляет пропуск
                        (empty,
                        тоесть указанный индекс удаляется) на его месте, при этом длинна массива не изменяется.(якобы
                        этим
                        оператором лучше пользоваться как можно меньше)</p>
                    <p>Вырезание элементов вместе со смещением индексов производят с помощью метода
                        "elem.splice(startElem,[,
                        deleteCount[, item1[, item2[, ...]]]])", а так же с его помощью можно добавить новые элементы на
                        месте
                        старых.</p>
                    <p>метод elem.shift()/elem.unshift(element1[, ...[, elementN]]) позволяют удалять или добавлять
                        элементы
                        в
                        начале массива.</p>

                    <ul>
                        <li>
                            <p>Есть массив array1 = [33,'best', 66, 'best'], кнопка b-1, input i-1. Напишите функцию f1,
                                которая
                                при нажатии читает i-1 и добавляем его в массив. После чего выводит массив в .out-1.
                                Поскольку
                                мы
                                будем выводить массив d1 неоднократно, то давайте вывод массива сделаем отдельной
                                функцией,
                                showArr
                                - она подготовлена. Изучите ее - это хороший способ оптимизировать код.</p>
                            <label for="inpmass1" class="form-control">Input i-1</label>
                            <input id="inpmass1" type="text" class="inpmass1">
                            <button id="buttarray1">Task-1</button>
                            <div class="divarray1"></div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass2, которая применяет метод pop к массиву array2 = [33,'best',
                                66,
                                'best'],
                                а затем выводит его (showArr) в out-2</p>
                            <button id="buttarray2">Task-2</button>
                            <div class="divarray2">out-2</div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass3, которая применяет метод shift к массиву array3 = [33,'best',
                                66,
                                'best'], а затем выводит его (showArr) в out-3</p>
                            <button id="buttarray3">Task-3</button>
                            <div class="divarray3">out-3</div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass4, которая применяет метод push к массиву array4 = [33,'best',
                                66,
                                'best'], данные для массива берите из inpmass4, а затем выводит его (showArr) в
                                out-4</p>
                            <label for="inpmass4" class="form-control">Input i-4</label>
                            <input id="inpmass4" type="text" class="inpmass4">
                            <button id="buttarray4">Task-4</button>
                            <div class="divarray4"></div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass5, которая применяет метод unshift к массиву array5 =
                                [33,'best',
                                66,
                                'best'], данные для массива берите из inpmass5, а затем выводит его (showArr) в
                                out-5</p>
                            <label for="inpmass5" class="form-control">Input i-5</label>
                            <input id="inpmass5" type="text" class="inpmass5">
                            <button id="buttarray5">Task-5</button>
                            <div class="divarray5"></div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass6, которая эмулирует работу метода push применительно к массиву
                                array6
                                =
                                ['test', 5, 12]. Т.е. добавляет
                                значение из inpmass6 как последний элемент в массив array6. Эмуляция, значит, что мы
                                получим
                                результат
                                аналогичный методу push без применения его. Эмуляция заключается в присвоение значения
                                как
                                последнего
                                элемента массива. Как вычислить индекс последнего элемента используя длину массива - вы
                                знаете
                                из
                                предыдущего урока. Повторный запуск функции должен также приводить к добавлению
                                элемента.</p>
                            <label for="inpmass6" class="form-control">Эмулируем push</label>
                            <input id="inpmass6" type="text" class="inpmass6">
                            <button id="buttarray6">Task-6</button>
                            <div class="divarray6"></div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass7, которая эмулирует метод pop, т.е. удаляет последний элемент
                                массива
                                array7 = ['china', 'india', 'brazil', 'japan', 'egypt'];. Эмулировать
                                - получать результат аналогичный pop, но без применения pop. Функция может быть вызвана
                                много
                                раз,
                                при
                                этом каждый раз должен удаляться последний элемент d7.</p>
                            <button id="buttarray7">Task-7</button>
                            <div class="divarray7">out-7</div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass8, которая эмулирует работу метода unShift - добавляем значение
                                из
                                inpmass8
                                в начало массива array8 = [2,'4', 12, 67, 'hello'].</p>
                            <label for="inpmass8" class="form-control">Эмулируем unShift</label>
                            <input id="inpmass8" type="text" class="inpmass8">
                            <button id="buttarray8">Task-8</button>
                            <div class="divarray8"></div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass9, которая эмулирует работу метода shift - на примере массива
                                array9 =
                                [100, 200, 300, 400, 700, 121].</p>
                            <button id="buttarray9">Task-9</button>
                            <div class="divarray9">out-9</div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass10, которая применяет к массиву array10 = [3,14,15,92,6] метод
                                reverse
                                и
                                выводит полученный массив в out-10</p>
                            <button id="buttarray10">Task-10</button>
                            <div class="divarray10">out-10</div>
                        </li>
                        <li>
                            <p>Напишите функцию, которая получает число из input inpmass11, переводит в число, и с
                                помощью
                                метода
                                indexOf
                                проверяет наличие в массиве array11 = [2,3,4,5,6,7]. Функция выводит в out-11 -1 если
                                такого
                                числа
                                нет в массиве, либо его
                                индекс в массиве.</p>
                            <label for="inpmass11" class="form-control">indexOf</label>
                            <input id="inpmass11" type="text" class="inpmass11">
                            <button id="buttarray11">Task-11</button>
                            <div class="divarray11"></div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass12, которая эмулирует работу метода indexOf - ищет введенное
                                число в
                                массиве
                                array12 = [6,62,60,70,1,5] (перебором). Если числа нет - выводит -1, если есть - его
                                позицию в
                                массиве.</p>
                            <label for="inpmass12" class="form-control">эмуляция indexOf</label>
                            <input id="inpmass12" type="text" class="inpmass12">
                            <button id="buttarray12">Task-12</button>
                            <div class="divarray12"></div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass13, которая эмулирует работу метода reverse. Т.е. создает новый
                                массив
                                на
                                основе array13 = [6, 0, 22, 1, 4, 76] с обратным порядком элементов и выводит в
                                out-13.</p>
                            <button id="buttarray13">Task-13</button>
                            <div class="divarray13">out-13</div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass14, которая получает inpmass14, переводит в число, а потом
                                заполняет
                                массив
                                array14 так, что
                                количество элементов равно введенному числу, и каждый элемент равен 1. Т.е. пользователь
                                ввел 5,
                                массив
                                будет [1,1,1,1,1]. Выведите массив в out-14.</p>
                            <label for="inpmass14" class="form-control">заполняем массив</label>
                            <input id="inpmass14" type="text" class="inpmass14">
                            <button id="buttarray14">Task-14</button>
                            <div class="divarray14">out-14</div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass15, которая вначале проверяет, есть ли элемент из inpmass15 в
                                массиве
                                array15 = [0, 2, 5, -4, 6, 22, -9, -12, 8, 12, 13, 78]; (переводим в
                                число), а потом - если нет - добавляет его в массив.</p>
                            <label for="inpmass15" class="form-control">заполняем массив</label>
                            <input id="inpmass15" type="text" class="inpmass15">
                            <button id="buttarray15">Task-15</button>
                            <div class="divarray15">out-15</div>
                        </li>
                        <li>
                            <p>Даны два массива array16_1 = [5,6,7,8,9]; и array16_2 = [23,24,56,87]; - используя метод
                                concat -
                                добавьте в массив array16 результат применения concat между массивом array16_1 и
                                array16_2 </p>
                            <button id="buttarray16">Task-16</button>
                            <div class="divarray16">out-16</div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass17, которая эмулирует работу метода concat. Функция должна
                                объединять
                                массивы array17_1 = ['a', 'b', 'c', 'd'] и array17_2 = [1,2,3,4,5] и записывать
                                результат в
                                array17. Для эмуляции используйтe цикл. </p>
                            <button id="buttarray17">Task-17</button>
                            <div class="divarray17">out-17</div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass18, которая получает значение из inpmass18 и проверяет есть ли
                                такое
                                значение в массиве array18 = ['b', 'c', '45', 'e', 'z', 'y'];
                                c использованием метода includes. Результат применения метода - выводится в out-18.</p>
                            <label for="inpmass18" class="form-control">заполняем массив</label>
                            <input id="inpmass18" type="text" class="inpmass18">
                            <button id="buttarray18">Task-18</button>
                            <div class="divarray18">out-18</div>
                        </li>
                        <li>
                            <p>Напишите фукнцию funkmass19, которая выводит самую длинную строку maxString из массива
                                array19 в out-19.</p>
                            <pre>array19 = ['Your','payment','method','will','automatically','be','charged','in','advance','every']</pre>
                            <button id="buttarray19">Task-19</button>
                            <div class="divarray19">out-19</div>
                        </li>
                        <li>
                            <p>Напишите функцию funkmass20, которая применяет к массиву array20 = [4,5,6,7,8,9,10] метод
                                join
                                с
                                параметрами и соединяет элементы
                                массива в одну строку. Результат выводит в out-20. Укажите мето так array20.join('').
                                Обратите
                                внимание - между апострофами нет пробела!!!</p>
                            <button id="buttarray20">Task-20</button>
                            <div class="divarray20">out-20</div>
                        </li>
                    </ul>
                </section>

                <section>
                    <h4 id="JSlesson12">UNIT 12. ДВУМЕРНЫЕ МАССИВЫ</h4>

                    <div class="outarray"></div>
                    <div class="outarrayh"></div>

                    <button id="butarray">push</button>
                    <div class="outdualarray"></div>


                    <ol>
                        <li>
                            <p>При нажатии butarray1 выполняете функцию funcarray1. Функция должна вывести в out-1
                                значение
                                55
                                из
                                массива array1 = [12, [45, 87], [55, 13]]. Возвратите это значение.</p>
                            <button id="butarray1">Task-1</button>
                            <div class="un12divarray1">out-1</div>
                        </li>
                        <li>
                            <p>При нажатии butarray2 выполняете функцию funcarray2. Функция должна вывести в out-2
                                значение
                                hi
                                из
                                массива array2 = [[12, 'hi'], [45, 87], [55, 13]]. Возвратите это значение.</p>
                            <button id="butarray2">Task-2</button>
                            <div class="un12divarray2">out-2</div>
                        </li>
                        <li>
                            <p>При нажатии butarray3 выполняете функцию funcarray3. Функция должна вывести в out-3
                                значение
                                my
                                из
                                массива array3 = [[1, 2, 3], [3, 4, 5], [6, [7, 'my']]]. Возвратите это значение.</p>
                            <button id="butarray3">Task-3</button>
                            <div class="un12divarray3">out-3</div>
                        </li>
                        <li>
                            <p>При нажатии butarray4 выполняете функцию funcarray4. Функция должна вывести в out-4
                                значение
                                go
                                из
                                массива array4 = [[1, 2, 3], 'go', [3, 4, 5], [6, [7, 'my']]]. Возвратите это
                                значение.</p>
                            <button id="butarray4">Task-4</button>
                            <div class="un12divarray4">out-4</div>
                        </li>
                        <li>
                            <p>При нажатии butarray5 выполняете функцию funcarray5. Функция должна вывести в out-5
                                четные
                                значения
                                из массива array5 = [[1, 2], [3, 4], [5, 6], [21, 34], [44, 56]]. Для перебора
                                используем
                                цикл.</p>
                            <button id="butarray5">Task-5</button>
                            <div class="un12divarray5">out-5</div>
                        </li>
                        <li>
                            <p>При нажатии butarray6 выполняете функцию funcarray6. Функция должна вывести в out-6
                                нечетные
                                значения
                                из массива array6 = [[1, 2], [3, 4], [5, 6], [21, 34], [44, 56]]. Для перебора
                                используем
                                цикл.
                                Делаем по образу предыдущей задачи.</p>
                            <button id="butarray6">Task-6</button>
                            <div class="un12divarray6">out-6</div>
                        </li>
                        <li>
                            <p>При нажатии butarray7 выполняете функцию funcarray7. Функция должна вывести в out-7
                                четные
                                значения
                                из массива array7 = [[1, 2, 3, 9],[3, 4, 7],[5, 6, 8, 32],[21, 34, 43],[44, 56]];. Как
                                видите,
                                вложенные массивы имеют разную длину, значит, предыдущий вариант уже не работает.
                                Используем
                                цикл.
                                Вывод - через пробел.</p>
                            <button id="butarray7">Task-7</button>
                            <div class="un12divarray7">out-7</div>
                        </li>
                        <li>
                            <p>При нажатии butarray8 выполняете функцию funcarray8. Функция должна вывести в out-8
                                нечетные
                                значения
                                из массива array8 = [[1, 2, 3, 9],[3, 4, 7],[5, 6, 8, 32],[21, 34, 43],[44, 56]];. Как
                                видите,
                                вложенные массивы имеют разную длину, значит, предыдущий вариант уже не работает.
                                Используем
                                цикл.
                                Вывод - через пробел</p>
                            <button id="butarray8">Task-8</button>
                            <div class="un12divarray8">out-8</div>
                        </li>
                        <li>
                            <p>При нажатии butarray9 выполняете функцию funcarray9. Функция должна вывести в out-9
                                значения
                                из
                                массива array9 = [[-2, 7, -3],[3, 4, -7],[-5, 6, -8, 32],[21, -34, -43],[44, -56]];
                                которые
                                больше
                                нуля. Используем цикл. Вывод - через пробел.</p>
                            <button id="butarray9">Task-9</button>
                            <div class="un12divarray9">out-9</div>
                        </li>
                        <li>
                            <p>При нажатии butarray10 выполняете функцию funcarray10. Функция должна вывести в out-10
                                значения
                                из
                                массива array10 = [[-2, '7', -3],[3, 4, -7],[-5, 6, -8, 32, 'a'],['st', 21, -34,
                                -43],[44,
                                -56,
                                'task']]; которые являются строкой. Используем цикл. Вывод - через пробел.</p>
                            <button id="butarray10">Task-10</button>
                            <div class="un12divarray10">out-10</div>
                        </li>
                        <li>
                            <p>При нажатии butarray11 выполняете функцию funcarray11. Функция должна вывести в out-11
                                значения
                                из
                                массива array11 = [[4, 5, 6],[7, 8],[9, 10, 11, 12, 13]];, причем каждый вложенный
                                массив
                                должен
                                идти в обратном порядке. Вывод через пробел. Т.е. вы должны получить в out-11 строку
                                вида 6
                                5 4
                                8 7
                                13 12 11 10 9. Решаем задачу двумя циклами, без reverse.</p>
                            <button id="butarray11">Task-11</button>
                            <div class="un12divarray11">out-11</div>
                        </li>
                        <li>
                            <p>Дан массив array12 который моделирует шахматную доску. Используя цикл выведите в out-12
                                единицы
                                из
                                этого массива. Все действия в функции funcarray12. Функция запускается при нажатии на
                                butarray12.
                                Вывод через пробел.</p>
                            <pre>
let array12 = [
[0,1,0,1,0,1,0,1],
[1,0,1,0,1,0,1,0],
[0,1,0,1,0,1,0,1],
[1,0,1,0,1,0,1,0],
[0,1,0,1,0,1,0,1],
[1,0,1,0,1,0,1,0],
[0,1,0,1,0,1,0,1],
[1,0,1,0,1,0,1,0],
];
            </pre>
                            <button id="butarray12">Task-12</button>
                            <div class="un12divarray12">out-12</div>
                        </li>
                        <li>
                            <p>При нажатии butarray13 выполняете функцию funcarray13. Функция должна присвоить
                                переменной
                                array13
                                массив эмулирующий шахматную доску. Причем массив должен создаваться с помощью циклов.
                                Для
                                проверки
                                - выведите массив в консоль.</p>
                            <button id="butarray13">Task-13</button>
                            <div class="un12divarray13">out-13</div>
                        </li>
                        <li>
                            <p>При нажатии butarray14 выполняете функцию funcarray14. Функция должна вывести в out-14
                                длины
                                вложенных в array14 массивов. Через пробел.</p>
                            <pre>
let array14 = [
    [],
    1,0],
    [1,0,0,0],
    [3,4,5,6,7,8],
    [1,2]
};
            </pre>
                            <button id="butarray14">Task-14</button>
                            <div class="un12divarray14">out-14</div>
                        </li>
                        <li>
            <pre>
let array15 = [
    [],
    [1,0],
    [1,0,0,0],
    [3,4,5,6,7,8],
    [1,2]
};
            </pre>
                            <p>При нажатии butarray15 выполняете функцию funcarray15. Функция должна вывести в out-15
                                длину
                                самого
                                большого вложенного массива в array15.</p>
                            <button id="butarray15">Task-15</button>
                            <div class="un12divarray15">out-15</div>
                        </li>
                        <li>
                            <p>Впишите в переменную array16 массив, который соответствует всем условиям приведенным ниже
                                (все
                                console.log должны дать true);</p>
                            <pre>
array16 = [
       [0,7,0,6],
       0,
       0,
       8
];

console.group('Task 16 ================');
console.log(a16[3] == 8);
console.log(a16[0][1] == 7);
console.log(a16[0][3] == 6);
console.groupEnd();
            </pre>
                        </li>
                        <li>
                            <p>Впишите в переменную array17 массив, который соответствует всем условиям приведенным ниже
                                (все
                                console.log должны дать true);</p>
                            <pre>
let array17 = [];
console.group('Task 17 ================');
console.log(array17[3][2] == 8);
console.log(array17[1][1] == 7);
console.log(array17[0][2] == 6);
console.groupEnd();
            </pre>
                        </li>
                        <li>
                            <p>Впишите в переменную array18 массив, который соответствует всем условиям приведенным ниже
                                (все
                                console.log должны дать true);</p>
                            <pre>
let array18 = [];
console.group('Task 18 ================');
console.log(array18[0] == 3);
console.log(array18[4][0] == 8);
console.log(array18[2][1] == 12);
console.groupEnd();
            </pre>
                        </li>
                        <li>
                            <p>Впишите в переменную array19 массив, который соответствует всем условиям приведенным ниже
                                (все
                                console.log должны дать true);</p>
                            <pre>
let array19 = [];
console.group('Task 19 ================');
console.log(array19[0][0][1] == 3);
console.log(array19[1][0][2] == 8);
console.log(array19[2][1][0] == 12);
console.groupEnd();
            </pre>
                        </li>
                        <li>
                            <p>Впишите в переменную array20 массив, который соответствует всем условиям приведенным ниже
                                (все
                                console.log должны дать true);</p>
                            <pre>
let array20 = [];
console.group('Task 20 ================');
console.log(array20[1][1][1] == 9);
console.log(array20[2][2] == 18);
console.log(array20[3]== 12);
console.groupEnd();
            </pre>
                        </li>
                    </ol>

                </section>

                <section>
                    <h4 id="JSlesson13">UNIT 13. АССОЦИАТИВНЫЙ МАССИВ (ОБЪЕКТ) В JAVASCRIPT</h4>

                    <p>В отличие от обычного массива, в ассоциативном массиве индексом может быть как число, так и
                        строка.</p>

                    <div class="asoarrayout"></div>

                    <p>Ассоциативные массивы могут быть так же двумерными.</p>

                    <ol>
                        <li>
                            <p>При нажатии asoarraybutt1 выполняете функцию funkasoaray1. Функция должна вывести в out-1
                                значение
                                сохраненное под ключем two из массива asoarray1. Возвратите это значение</p>
                            <pre>
let asoarray1 = {
    "one" : 15,
    "two" : 16,
    "five" : 20
};
            </pre>
                            <button id="asoarraybutt1">Task-1</button>
                            <div class="assoarrayout1">out-1</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt2 выполняете функцию funkasoaray2. Функция должна вывести в out-2
                                значение hi
                                из массива asoarray2. Возвратите это значение.</p>
                            <pre>
let asoarray2 = {
    "one" : "hello",
    "two" : "mahai",
    "five" : "hi"
};
            </pre>
                            <button id="asoarraybutt2">Task-2</button>
                            <div class="assoarrayout2">out-2</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt3 выполняете функцию funkasoaray3. Функция должна вывести в out-3
                                значение hi
                                из массива asoarray3. Возвратите это значение. Вывод - через пробел.</p>
                            <pre>
let asoarray3 = {
    "one": "hello",
    "two": "mahai",
    "five": "hi",
    "test": 21,
    "odd": "hi",
    "mix": "mix"
};
            </pre>
                            <button id="asoarraybutt3">Task-3</button>
                            <div class="assoarrayout3">out-3</div>
                        </li>
                        <li>
                            <p>Давайте напишем функцию funkasoaray4, которая будет выводить массив asoarray4 в out-4 при
                                нажатии
                                кнопки asoarraybutt4. Формат вывода - ключ пробел значение перенос строки +'&#x27;
                                &#x3C;br&#x3E;'.
                                Функция должна возвращать строку в указанном формате вывода.</p>
                            <pre>
let asoarray4 = {
    "one": "hello",
    "two": "mahai",
    "five": "hi",
    "test": 21,
    "odd": "hi",
    "mix": "mix"
};
            </pre>
                            <button id="asoarraybutt4">Task-4</button>
                            <div class="assoarrayout4">out-4</div>
                        </li>
                        <li>
                            <p>Функция funkasoaray4 жестко привязана к массиву asoarray4. Это не удобно. Давайте напишем
                                функцию
                                funkasoaray5, которая принимает массив как параметр и выводит его в формате указанном в
                                функции
                                в
                                указанный блок (как второй параметр).</p>
                            <pre>
let asoarray5 = {
    "one": 1,
    "two": 2
};
            </pre>
                            <button id="asoarraybutt5">Task-5</button>
                            <div class="assoarrayout5">out-5</div>
                        </li>
                        <li>
                            <p> Добавьте input 61 и 62. При нажатии asoarraybutt6 выполняете функцию funkasoaray6.
                                Функция
                                должна
                                получать из input 61 ключ, а из input 62 значение и добавлять его в массив asoarray6.
                                После
                                этого, с
                                помощью функции funkasoaray5 выводите массив a6 в out-6.</p>
                            <pre>
let asoarray6 = {
    "b": 17,
    "e": 22
};
            </pre>
                            <label for="inpasoarray61" class="form-control">Input 61</label>
                            <input id="inpasoarray61" type="text" class="inpasoarray61">

                            <label for="inpasoarray62" class="form-control">Input 62</label>
                            <input id="inpasoarray62" type="text" class="inpasoarray62">

                            <button id="asoarraybutt6">Task-6</button>
                            <div class="assoarrayout6">out-6</div>
                        </li>
                        <li>
                            <p> Добавьте input 71. При нажатии asoarraybutt7 выполняете функцию funkasoaray7. Функция
                                должна
                                получать из input 7 ключ. Если такой ключ есть в asoarray7, то выводить 1 в out-7, если
                                нет
                                -
                                0.</p>
                            <pre>
let asoarray7 = {
    "b": 17,
    "e": 22
};
            </pre>
                            <label for="inpasoarray71" class="form-control">Input 71</label>
                            <input id="inpasoarray71" type="text" class="inpasoarray71">
                            <button id="asoarraybutt7">Task-7</button>
                            <div class="assoarrayout7">out-7</div>
                        </li>
                        <li>
                            <p>Добавьте input 81. При нажатии asoarraybutt8 выполняете функцию funkasoaray8. Функция
                                должна
                                выводить
                                значение в out-8, если ключ введенный в input 8 есть в массиве, если нет - 0.</p>
                            <pre>
let asoarray8 = {
    "b": 17,
    "e": 22
};
            </pre>
                            <label for="inpasoarray81" class="form-control">Input 81</label>
                            <input id="inpasoarray81" type="text" class="inpasoarray81">
                            <button id="asoarraybutt8">Task-8</button>
                            <div class="assoarrayout8">out-8</div>
                        </li>
                        <li>
                            <p>Добавьте input 91. При нажатии asoarraybutt9 выполняете функцию funkasoaray9. Функция
                                должна
                                вывести
                                в out-9 все ключи
                                массива asoarray9, которые содержат значение, равное значению в input 91. Вывод через
                                пробел.
                                Если
                                значений -
                                нет, то выводить пустую строку.</p>
                            <pre>
let asoarray9 = {
    "b": 17,
    "e": 22,
    "j": 17,
    "k": 22,
    "d": 54
};
            </pre>
                            <label for="inpasoarray91" class="form-control">Input 91</label>
                            <input id="inpasoarray91" type="text" class="inpasoarray91">
                            <button id="asoarraybutt9">Task-9</button>
                            <div class="assoarrayout9">out-9</div>
                        </li>
                        <li>
                            <p>Давайте напишем полезную функцию funkasoaray10, которая проверяет есть ли значение в
                                ассоциативном
                                массиве.
                                Фукнция должна возвращать true если есть, и false если нет. Массив и значение передавать
                                функции
                                в
                                качестве
                                параметров.</p>
                            <pre>
let asoarray9 = {
   "k": 22,
   "d": 54,
   "m": 22,
};
            </pre>
                            <button id="asoarraybutt10">Task-10</button>
                            <div class="assoarrayout10">out-10</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt11 выполняете функцию funkasoaray11. Функция должна получить ключ
                                из
                                input
                                11-1 и удалить запись из массива
                                asoarray11 с таким ключем. После этого вывести массив в out-11. Для вывода используйте
                                функцию
                                funkasoaraycommon.</p>
                            <pre>
let asoarray11 = {
    "b": 17,
    "e": 22,
    "j": 17,
    "k": 22,
    "d": 54
};
            </pre>
                            <label for="inpasoarray11-1" class="form-control">Input 11-1</label>
                            <input id="inpasoarray11-1" type="text" class="inpasoarray11-1">
                            <button id="asoarraybutt11">Task-11</button>
                            <div class="assoarrayout11">out-11</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt12 выполняете функцию funkasoaray12. Функция должна получить
                                значение
                                из
                                input 12 и удалить запись из
                                массива asoarray12 с таким значением. После этого вывести массив в out-12. Для вывода
                                используйте
                                функцию funkasoaraycommon.</p>
                            <pre>
let asoarray12 = {
    "b": 17,
    "e": 22,
    "j": 17,
    "k": 22,
    "d": 17,
};
            </pre>
                            <label for="inpasoarray12-1" class="form-control">Input 12-1</label>
                            <input id="inpasoarray12-1" type="text" class="inpasoarray12-1">
                            <button id="asoarraybutt12">Task-12</button>
                            <div class="assoarrayout12">out-12</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt13 выполняете функцию funkasoaray13. Функция должна в out-13
                                выводить
                                сумму
                                значений массива asoarray13
                                (только числа).</p>
                            <pre>
let asoarray13 = {
    'prim': 'hello',
    'one': 4,
    'testt': 'vodoley',
    'ivan': 6
};
            </pre>
                            <button id="asoarraybutt13">Task-13</button>
                            <div class="assoarrayout13">out-13</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt14 выполняете функцию funkasoaray14. Функция должна в out-14
                                выводить
                                нулевые
                                (по индексу) элементы
                                вложенных массивов в asoarray14. Вывод через пробел.</p>
                            <pre>
let asoarray14 = {
    'prim': [1, 2, 23],
    'one': [3, 4, 5],
    'testt': [6, 7, 8],
    'ivan': [9, 10]
};
            </pre>
                            <button id="asoarraybutt14">Task-14</button>
                            <div class="assoarrayout14">out-14</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt15 выполняете функцию funkasoaray15. Функция должна в out-15
                                выводить
                                элементы вложенных массивов в
                                asoarray15. Вывод через пробел.</p>
                            <pre>
let asoarray15 = {
    'prim': [1, 2, 23],
    'one': [3, 5],
    'testt': [6, 7, 8],
    'ivan': [9, 10]
};
            </pre>
                            <button id="asoarraybutt15">Task-15</button>
                            <div class="assoarrayout15">out-15</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt16 выполняете функцию funkasoaray16. Функция должна в out-16
                                выводить
                                элементы name вложенных
                                массивов в asoarray16. Вывод через пробел.</p>
                            <pre>
let asoarray16 = {
    "iis8sj": {
        "name": "Ivan",
        "age": 27,
    },
    "iiss7j": {
        "name": "Petr",
        "age": 26,
    },
    "s3s8sj": {
        "name": "Serg",
        "age": 47,
    },
};
            </pre>
                            <button id="asoarraybutt16">Task-16</button>
                            <div class="assoarrayout16">out-16</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt17 выполняете функцию funkasoaray17. Функция должна в out-17
                                выводить
                                элементы name вложенных
                                массивов в asoarraz17 для которых age > 30. Вывод через пробел.</p>
                            <pre>
let asoarray16 = {
    "iis8sj": {
        "name": "Ivan",
        "age": 27,
    },
    "iiss7j": {
        "name": "Petr",
        "age": 26,
    },
    "s3s8sj": {
        "name": "Serg",
        "age": 47,
    },
};
            </pre>
                            <button id="asoarraybutt17">Task-17</button>
                            <div class="assoarrayout17">out-17</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt18 выполняете функцию funkasoaray18. Функция должна в out-18
                                вывести
                                станции
                                метро из массива
                                asoarray18 той ветки, которую пользователь ввел в input 18. Вывод станций - через
                                пробел.
                                Если
                                ветка
                                не найдена
                                выводите пустую строку.</p>
                            <pre>
let asoarray18 = {
    "red": ['Akademmistechko', 'Nyvky', 'Universytet', 'Lisova'],
    "blue": ['Minska', 'Obolon', 'Pochaina', 'Holosiivska'],
    "green": ['Syrets', 'Zoloti Vorota', 'Klovska', 'Vidubichi']
};
            </pre>
                            <label for="inpasoarray18" class="form-control">Input 18</label>
                            <input id="inpasoarray18" type="text" class="inpasoarray18">
                            <button id="asoarraybutt18">Task-18</button>
                            <div class="assoarrayout18">out-18</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt19 выполняете функцию funkasoaray19. Функция должна в out-19
                                вывести
                                цвет
                                ветки станции которую
                                пользователь ввел в input 19. Пользователь может вводить текст как с большой, так и с
                                маленькой
                                буквы. Если
                                ветка не найдена - выводите пустую строку.</p>
                            <pre>
let asoarray19 = {
    "red": ['Akademmistechko', 'Nyvky', 'Universytet', 'Lisova'],
    "blue": ['Minska', 'Obolon', 'Pochaina', 'Holosiivska'],
    "green": ['Syrets', 'Zoloti Vorota', 'Klovska', 'Vidubichi']
};
            </pre>
                            <label for="inpasoarray19" class="form-control">Input 19</label>
                            <input id="inpasoarray19" type="text" class="inpasoarray19">
                            <button id="asoarraybutt19">Task-19</button>
                            <div class="assoarrayout19">out-19</div>
                        </li>
                        <li>
                            <p>При нажатии asoarraybutt20 выполняете функцию funkasoaray20. Функция должна в out-20
                                вывести
                                название
                                станции которые
                                содержат переход на другую ветку. Такие станции маркируются 2. Вывод через пробел.</p>
                            <pre>
let asoarray20 = {
    "red": [['Akademmistechko', 1], ['Nyvky', 0], ['Universytet', 3], ['Lisova', 1]],
    "blue": [['Minska', 1], ['Obolon', 0], ['Pochaina', 2], ['Holosiivska', 0]],
    "green": [['Syrets', 1], ['Zoloti Vorota', 2], ['Klovska', 0], ['Vidubichi', 1]],
};
            </pre>
                            <button id="asoarraybutt20">Task-20</button>
                            <div class="assoarrayout20">out-20</div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson14">UNIT 14. ПРАКТИКА ПО МАССИВАМ - ПОЛУЧАЕМ ПРОГНОЗ ПОГОДЫ ПО API</h4>

                    <div class="container-api">
                        <div class="pricing-table row">
                            <div class="package featured">
                                <p class="package-name">City</p>
                                <p class="price">Degrees&deg;</p>
                                <p class="disclaimer">Clouds</p>
                                <ul class="features">
                                    <li>Icon</li>
                                </ul>
                                <p class="visibility">Visibility</p>
                                <p class="wind">Wind speed</p>
                                <button id="button-api">Go</button>
                                <input id="inputapitext" type="text" aria-label="City Name" class="inputapitext"
                                       placeholder="City Name">
                                <input id="inputapinumber" aria-label="City id" type="number" class="inputapinumber"
                                       placeholder="City id">
                            </div>
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSlesson15">UNIT 15. SET В JAVASCRIPT</h4>

                    <ol>
                        <li>
                            <p> Создайте set set1. Добавьте в него три элемента 'h', 'b', 'o', 'h'. Добавление делайте
                                через
                                add.
                                Выведите в консоль/(или в out-1 используя конвертацию в массив) получившийся набор (set)
                                s1.</p>
                            <div class="outset1">out-1:</div>
                        </li>
                        <li>
                            <p>При нажатии buttset2 выполняете функцию funcset2. Функция должна добавить в набор s2
                                элементы,
                                которые пользователь вводит в inputset2. Функция должна выводить в консоль set2 после
                                каждого
                                добавления элемента.</p>
                            <label for="inputset2" class="form-control">Input 2</label>
                            <input id="inputset2" type="text" class="inputset2">
                            <button id="buttset2">Task-2</button>
                            <div class="outset2">out-2:</div>
                        </li>
                        <li>
                            <p>При нажатии buttset3 выполняете функцию funcset3. Функция должна удалить из набора
                                set3(['one',
                                'two', 'four']) строку, которую пользователь вводит в inputset3. Функция должна выводить
                                в
                                консоль
                                set3 после каждого удаления элемента.</p>
                            <label for="inputset3" class="form-control">Input 3</label>
                            <input id="inputset3" type="text" class="inputset3">
                            <button id="buttset3">Task-3</button>
                            <div class="outset3">out-3:</div>
                        </li>
                        <li>
                            <p>При нажатии buttset4 выполняете функцию funcset4. Функция должна проверить наличие в
                                наборе
                                set4(['a', 'b', 'c', 'z']) строки введенной пользователем в inputset4. Если строка есть
                                - то
                                вывести
                                в out-4 true. Если нет - false.</p>
                            <label for="inputset4" class="form-control">Input 4</label>
                            <input id="inputset4" type="text" class="inputset4">
                            <button id="buttset4">Task-4</button>
                            <div class="outset4">out-4:</div>
                        </li>
                        <li>
                            <p>При нажатии buttset5 выполняете функцию funcset5. Функция должна вывести в out-5
                                количество
                                элементов
                                в наборе set5(['a', 'b', 'c', 'z', 'a2', 'b2', 'c2', 'z2']).</p>
                            <button id="buttset5">Task-5</button>
                            <div class="outset5">out-5:</div>
                        </li>
                        <li>
                            <p>При нажатии buttset6 выполняете функцию funcset6. Функция должна вывести в out-6 число
                                уникальных
                                элементов в массиве arrayforset6 = [1, 2, 3, 4, 5, 3, 4, 5, 2, 4, 5, 3, 24, 5, 2, 4, 56,
                                4,
                                3,
                                2,
                                335, 2, 23, 41, 3, 4, 1, 1, 4, 2, 2, 4, 5, 24, 5, 3, 22, 56]. Решение должно
                                использовать
                                set.</p>
                            <button id="buttset6">Task-6</button>
                            <div class="outset6">out-6:</div>
                        </li>
                        <li>
                            <p>При нажатии buttset7 выполняете функцию funcset7. Функция должна получать из inputset7
                                значение
                                пароля и проверять, чтобы пользователь в
                                строке пароля использовал не повторяющиеся символы. Если символы уникальны, а длина
                                пароля
                                больше
                                (строго) 6 то
                                выводите в out-7 число 1. Если есть повторяющиеся символы, или длина меньше или равна 6
                                - то
                                выводите 0. Для проверки
                                уникальности символов используйте Set.</p>
                            <label for="inputset7" class="form-control">Input 7</label>
                            <input id="inputset7" type="text" class="inputset7">
                            <button id="buttset7">Task-7</button>
                            <div class="outset7">out-7:</div>
                        </li>
                        <li>
                            <p>При нажатии buttset8 выполняете функцию funcset8. Функция должна перебрать набор set8([1,
                                2,
                                3,
                                4, 5,
                                3, 4, 7, 9, 5, 7, 8, 9, 23, 45, 5, 2, 4, 5, 3, 24, 5, 2, 4, 56, 4, 3, 2, 335, 2, 23, 41,
                                3,
                                4,
                                1, 1,
                                4, 2, 2, 4, 5, 24, 5, 3, 22, 56]) и добавить в массив setarray8 только числа больше 5.
                                Выведите
                                массив в консоль.</p>
                            <button id="buttset8">Task-8</button>
                            <div class="outset8">out-8:</div>
                        </li>
                        <li>
                            <p>При нажатии buttset9 выполняете функцию funcset9. Функция должна принимать набор our_set
                                в
                                качестве
                                параметра, преобразовывать его
                                в строку, причем после каждого символа строки должен быть пробел. Функция должна
                                возвращать
                                результирующую строку. В нашем примере результат должен быть 9 8 7 6 5 </p>
                            <button id="buttset9">Task-9</button>
                            <div class="outset9">out-9:</div>
                        </li>
                        <li>
                            <p>При нажатии buttset10 выполняете функцию funcset10. Функция должна принимать набор set10
                                в
                                качестве
                                параметра и выводить его в
                                указанный элемент. Элемент указывается как второй параметр функции funcset10. Вывод
                                значений
                                -
                                через
                                пробел.</p>
                            <button id="buttset10">Task-10</button>
                            <div class="outset10">out-10:</div>
                        </li>
                        <li>
                            <p>При нажатии buttset11 выполняете функцию funcset11. Функция должна преобразовать массив
                                array11 в
                                набор. И выводить в консоль. Изучите
                                вывод получившегося набора. Разберитесь почему так происходит.</p>
                            <button id="buttset11">Task-11</button>
                        </li>
                        <li>
                            <p>При нажатии buttset12 выполняете функцию funcset12. Функция должна преобразовать строку
                                str12
                                в
                                массив, так, что каждая буква -
                                отдельный элемент массива. Потом создать набор на основе массива и возвратить его.</p>
                            <button id="buttset12">Task-12</button>
                        </li>
                        <li>
                            <p>При нажатии buttset13 выполняете функцию funcset13. Функция должна преобразовать строку
                                str13
                                в
                                массив, причем каждая буква -
                                отдельный элемент массива. Потом создать набор на основе массива. Затем, перебирая набор
                                по
                                элементам, найти сколько раз
                                каждый символ встречается в исходном массиве. Результат - в виде объекта типа { символ :
                                количество,
                                символ : количество } вывести в консоль и возвратить.</p>
                            <p>Пример результата для строки 'Hello ho'</p>
                            <p>{ "H" : 1, 'e' : 1, 'l' : 2, "o" : 2, " ": 1}</p>
                            <button id="buttset13">Task-13</button>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson16">UNIT 16. ПЕРЕБОР МАССИВОВ: FOR, FOR IN, FOR OF</h4>

                    <div>
                        <div class="newelem">1</div>
                        <div class="newelem">2</div>
                        <div class="newelem">3</div>
                    </div>

                    <ol>
                        <li>
                            <p>При нажатии buttfor1 выполняете функцию funcfor1. Функция перебирает массив arrayfor1 =
                                [5,
                                7, 9,
                                11,
                                13, 15]; c помощью цикла for (let i. Выведите на страницу в out-1 формате
                                значение+пробел.</p>
                            <button id="buttfor1">Task-1</button>
                            <div class="outfor1">out-1:</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor2 выполняете функцию funcfor2. Функция перебирает массив arrayfor2 =
                                [5,
                                7, 9,
                                11,
                                13, 15]; c помощью цикла for (let i. Выведите на страницу в .out-2 формате
                                индекс+пробел+значение +
                                &lt;br&gt;.</p>
                            <button id="buttfor2">Task-2</button>
                            <div class="outfor2">out-2:</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor3 выполняете функцию funcfor3. Функция получает div.buttfor3 со
                                страницы с
                                помощью
                                getElementsByClassName и в каждый записывает число 3, перезаписывая содержимое div</p>
                            <button id="buttfor3">Task-3</button>
                            <div class="outfor3">out-3</div>
                            <div class="outfor3">out-3</div>
                            <div class="outfor3">out-3</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor4 выполняете функцию funcfor4. Функция получает div.buttfor4 со
                                страницы с
                                помощью
                                querySelectorAll и в каждый дописывает число 4.</p>
                            <button id="buttfor4">Task-4</button>
                            <div class="outfor4">out-4</div>
                            <div class="outfor4">out-4</div>
                            <div class="outfor4">out-4</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor5 выполняете функцию funcfor5. Функция должна с помощью for of
                                перебрать
                                массив
                                arrayfor5 = [3,4,5,2,1,7,8,2,4,6,8,11,23,17]; и возвратить новый массив куда входят
                                элементы
                                из
                                arrayfor5 большие 7.</p>
                            <button id="buttfor5">Task-5</button>
                            <div class="outfor5">out-5:</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor6 выполняете функцию funcfor6. Функция должна превратить массив
                                arrayfor6
                                =
                                [[1,2], [3,4], [5,6]]; в одномерный. Результат вывести в out-6 через пробел.</p>
                            <button id="buttfor6">Task-6</button>
                            <div class="outfor6">out-6:</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor7 выполняете функцию funcfor7. Функция должна переиндексировать массив
                                arrayfor7 =
                                [{ id : 23, name: 'Ivan'}, {id: 45, name : 'Petr'}];. Что имеется ввиду. Сейчас у нас
                                обычный
                                массив,
                                который содержит вложенные объекты. Вам необходимо сделать из arrayfor7 объект, где
                                ключи -
                                значения
                                id из вложенных массивов, а значения - имя (т.е { 23 : Ivan, 45 : Petr}.
                                Функция должна возвращать результирующий массив.</p>
                            <button id="buttfor7">Task-7</button>
                        </li>
                        <li>
                            <p>При нажатии buttfor8 выполняете функцию funcfor8. Функция должна переиндексировать массив
                                arrayfor8 =
                                [ { id : 23, name: 'Ivan'}, {id: 45, name : 'Petr'}];. Что имеется ввиду. Сейчас у нас
                                обычный
                                массив,
                                который содержит вложенные объекты. Вам необходимо сделать из arrayfor8 массив, который
                                будет
                                содержать только числовые id. Т.е. [23, 45]. Функция должна возвращать результирующий
                                массив.</p>
                            <button id="buttfor8">Task-8</button>
                        </li>
                        <li>
                            <p>При нажатии buttfor9 выполняете функцию funcfor9. Функция должна возвращать в out-9 самый
                                большой
                                индекс из вложенных в arrayfor9 = [ [4,3,2], [2,5], [0,0,0,0,0]]; массивов.
                                В данном случае это 4. Т.е. самый большой вложенный массив это [0,0,0,0,0], а в нем
                                самый
                                большой
                                индекс 4.</p>
                            <button id="buttfor9">Task-9</button>
                            <div class="outfor9">out-9:</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor10 выполняете функцию funcfor10. Функция должна преобразовывать массив
                                arrayfor10
                                в ассоциативный массив вида {4: 4, 6: 6, 9: 9, hello : "hello"} и возвращать полученный
                                массив.</p>
                            <button id="buttfor10">Task-10</button>
                        </li>
                        <li>
                            <p>При нажатии buttfor11 выполняете функцию funcfor11. Функция должна c помощью for in
                                перебрать
                                объект
                                arrayfor11 и вывести в out-11 только те значения, которые больше 10. Вывод - через
                                пробел.</p>
                            <pre>
let arrayfor11 = {
        one : 11,
        two : 7,
        three : 13,
        four: 0
    }
            </pre>
                            <button id="buttfor11">Task-11</button>
                            <div class="outfor11">out-11:</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor12 выполняете функцию funcfor12. Функция должна c помощью for of
                                перебрать
                                arrayfor12 = [4,5,6,7]; и вывести в out-12 через пробел.</p>
                            <button id="buttfor12">Task-12</button>
                            <div class="outfor12">out-12:</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor13 выполняете функцию funcfor13. Функция должна c помощью for of
                                перебрать
                                arrayfor13 = 'testone' и вывести по символу в out-13 через пробел.</p>
                            <button id="buttfor13">Task-13</button>
                            <div class="outfor13">out-13:</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor14 выполняете функцию funcfor14. Функция должна c помощью for of
                                перебрать
                                arrayfor14([4,5,6]) и вывести по элементам в out-14 через пробел.</p>
                            <button id="buttfor14">Task-14</button>
                            <div class="outfor14">out-14:</div>
                        </li>
                        <li>
                            <p>При нажатии buttfor15 выполняете функцию funcfor15. Функция должна получить NodeList
                                элементов
                                out-15
                                c помощью document.querySelectorAll,
                                затем c помощью for of перебрать полученную коллекцию элементов .out-15 записать внутрь
                                них
                                число 15
                                (затерев содержимое).</p>
                            <button id="buttfor15">Task-15</button>
                            <div class="outfor15">out-15:</div>
                            <div class="outfor15">out-15:</div>
                            <div class="outfor15">out-15:</div>
                            <div class="outfor15">out-15:</div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson17">UNIT 17. МЕТОДЫ МАССИВОВ: MAP, FILTER ( ЧАСТЬ 1)</h4>

                    <ol>
                        <li>
                            <p>Дан массив array1 = [4, 5, 6, 7, 12, 34, 56, 78, 90, 11] - с помощью map переберите
                                массив и
                                создайте
                                новый массив array1_res куда добавьте элементы данного массива умноженные на 2.
                                Возвратите
                                массив
                                array1_res.</p>
                            <button id="buttmap1">task 1</button>
                            <div class="outmap1">out-1:</div>
                        </li>
                        <li>
                            <p>Дан массив array2 = [2,3,4,5,10,11,12] - с помощью map переберите массив и создайте
                                массив
                                array2_res
                                куда добавьте элементы данного массива возведенные во вторую степень. Возвратите массив
                                array2_res.
                                Действия должны запускаться при вызове функции t2.</p>
                            <button id="buttmap2">task 2</button>
                            <div class="outmap2">out-2:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayfilter3 = [4,"3",6,7,"12",34,"56",78,90,11] - с помощью map переберите
                                массив
                                и
                                создайте массив array3_res куда добавьте все элементы приведенные к числу. Возвратите
                                array3_res.
                                Действия должны запускаться при вызове функции funcfilter3.</p>
                            <button id="buttmap3">task 3</button>
                            <div class="outmap3">out-3:</div>
                        </li>
                        <li>
                            <p>Следующая задача проще будет решаться через метод forEach, который мы изучим во второй
                                части
                                урока!
                                Сейчас мы делаем костыль, для отработки навыков работы с map. Дан массив a4 =
                                [4,"3",6,7,"12",34,"56",78,90,11] - с помощью map переберите массив и создайте массив
                                a4_res
                                куда
                                добавьте ТОЛЬКО числа из массива a4. Возвратите a4_res. Действия должны запускаться при
                                вызове
                                функции funcfilter4.</p>
                            <button id="buttmap4">task 4</button>
                            <div class="outmap4">out-4:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayfilter5 = [3, 14, 15, 92]. C помощью filter переберите массив и создайте
                                arrayfilter5_res, который содержит только четные числа из arrayfilter5. Возвратите
                                arrayfilter5_res.
                                Действия должны запускаться при вызове функции funcfilter5.</p>
                            <button id="buttmap5">task 5</button>
                            <div class="outmap5">out-5:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayfilter6 = [3, 14, 15, 92, "6", "5", "hello", 32]. C помощью filter
                                переберите
                                массив
                                b6 и создайте массив arrayfilter6_res, который содержит только числа из arrayfilter6.
                                Возвратите
                                arrayfilter6_res. Действия должны запускаться при вызове функции funcfilter6.</p>
                            <button id="buttmap6">task 6</button>
                            <div class="outmap6">out-6:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayfilter7 = ["php-7", "html", "css", 92, "6", "5", "hello", 32]. C помощью
                                filter
                                переберите массив arrayfilter7 и создайте arrayfilter7_res, который содержит только
                                строки
                                из
                                arrayfilter7, длина которых больше 3. Возвратите arrayfilter7_res. Действия должны
                                запускаться
                                при
                                вызове функции funcfilter7.</p>
                            <button id="buttmap7">task 7</button>
                            <div class="outmap7">out-7:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayfilter8 = [3, 14, 15, 92, "6", "5", "hello", 32]. С помощью filter,
                                переберите
                                массив
                                arrayfilter8 и создайте массив arrayfilter8_res, который содержит индексы четных
                                элементов.
                                Возвратите arrayfilter8_res. Действия должны запускаться при вызове функции
                                funcfilter8.</p>
                            <button id="buttmap8">task 8</button>
                            <div class="outmap8">out-8:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayfilter9 = [3, "hello", 4, "world", 5, "hi"]. С помощью filter, переберите
                                массив
                                arrayfilter9 и создайте массив arrayfilter9_num и arrayfilter9_string, которые содержат
                                первый -
                                числа из arrayfilter9, второй - строки. Задачу решите с помощью filter. Действия должны
                                запускаться
                                при вызове функции funcfilter9.</p>
                            <button id="buttmap9">task 9</button>
                            <div class="outmap91">числа:</div>
                            <div class="outmap92">строки:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayfilter10 = [[1,2,3],[3,4,6],[4,5,7],[8,9,3]]. С помощью filter переберите
                                массив
                                и
                                создайте arrayfilter10_res, в который входят вложенные массивы содержащие цифру 3.
                                Возвратите
                                arrayfilter10_res. Действия должны запускаться при вызове функции funcfilter10.</p>
                            <button id="buttmap10">task 10</button>
                            <div class="outmap10">out-10:</div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson18">UNIT 18. МЕТОДЫ МАССИВОВ: JOIN, SPLIT, FOREACH ( ЧАСТЬ 2)</h4>

                    <ol>
                        <li>
                            <p>Дан массив arrayforeach1 = [4,5,6,7,12,34,56,78,90,11] - с помощью forEach переберите
                                массив
                                и
                                создайте новый массив arrayforeach1_res куда добавьте элементы данного массива
                                умноженные на
                                2.
                                Действия должны запускаться при вызове функции funcforeach1.</p>
                            <button id="buttforeach1">task 1</button>
                            <div class="outforeach1">out-1:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayforeach2 = [2,3,4,5,10,11,12] - с помощью forEach переберите массив и
                                создайте
                                новый
                                массив arrayforeach2_res куда добавьте элементы данного массива деленные на 2.
                                Действия должны запускаться при вызове функции funcforeach2.</p>
                            <button id="buttforeach2">task 2</button>
                            <div class="outforeach2">out-2:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayforeach3 = [2, "hello", 3, "hi", 4, "Mazai"] - с помощью forEach
                                переберите
                                массив и
                                создайте новый массив arrayforeach3_res куда добавьте элементы данного массива
                                являющиеся
                                числом.
                                Запускаться решение должно при вызове функции funcforeach3.</p>
                            <button id="buttforeach3">task 3</button>
                            <div class="outforeach3">out-3:</div>
                        </li>
                        <li>
                            <p>На странице созданы 3 span.taskforeach-4 c атрибутом data. С помощью forEach переберите
                                их и
                                добавьте
                                атрибуты в массив arrayforeach4_res. Запускаться решение должно при вызове функции
                                funcforeach4.</p>
                            <button id="buttforeach4">task 4</button>
                            <div>
                                <span class="taskforeach-4" data-taskforeach4="1">One span with data</span>
                                <span class="taskforeach-4" data-taskforeach4="34">Two span with data</span>
                                <span class="taskforeach-4" data-taskforeach4="66">Thre span with data</span>
                            </div>
                            <div class="outforeach4">out-4:</div>
                        </li>
                        <li>
                            <p>На странице созданы 3 p.task-5 c атрибутом data. С помощью forEach переберите их и
                                добавьте
                                событие
                                клик.
                                Напишите функцию funcforeach5, которая будет запускаться при клике и добавлять атрибут
                                data
                                элемента, по которому кликнули в массив arrayforeach5_res.</p>
                            <div>
                                <p class="taskforeach-5" data-taskforeach5="1">One p with data</p>
                                <p class="taskforeach-5" data-taskforeach5="34">Two p with data</p>
                                <p class="taskforeach-5" data-taskforeach5="66">Three p with data</p>
                            </div>
                        </li>
                        <li>
                            <p>Дана строка str6="helloworld" - преобразуйте ее в массив и присвойте arrayforeach6_res.
                                Выведите
                                на
                                страницу. Запускаться решение должно при вызове функции funcforeach6.</p>
                            <button id="buttforeach6">task 6</button>
                            <div class="outforeach6">out-6:</div>
                        </li>
                        <li>
                            <p>Дана строка str7="hello world hi mazai" - преобразуйте ее в массив и разбейте по словам.
                                Причем
                                слова
                                не должны содержать пробелов и присвойте arrayforeach7_res.
                                Выведите на страницу. Запускаться решение должно при вызове функции funcforeach7.</p>
                            <button id="buttforeach7">task 7</button>
                            <div class="outforeach7">out-7:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayjoin8 = [1,2,66,77,15] - преобразуйте ее в строку. Разделитель - дефис.
                                Результат
                                присвойте arrayjoin8_res. Запускаться решение должно при вызове функции
                                funcforeach8.</p>
                            <button id="buttforeach8">task 8</button>
                            <div class="outforeach8">out-8:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayforeach9 = [[hi, mahai], [test, best]] - преобразуйте его в строку.
                                Разделитель -
                                дефис. Результат присвойте arrayforeach9_res. Запускаться решение должно при вызове
                                функции
                                funcforeach9.
                                Допускается лишний дефис в конце строки!!!</p>
                            <button id="buttforeach9">task 9</button>
                            <div class="outforeach9">out-9:</div>
                        </li>
                        <li>
                            <p>Дан массив arrayforeach10 = {name: ivan, age: 15, sex: 1, id: 45} - преобразуйте его в
                                GET
                                строку
                                (GET параметры). Найдите описание, что такое GET строка самостоятельно.
                                Разделитель - амперсанд. Результат присвойте arrayforeach10_res. Запускаться решение
                                должно
                                при
                                вызове функции funcforeach10. Допускается лишний амперсанд в конце строки!!!</p>
                            <button id="buttforeach10">task 10</button>
                            <div class="outforeach10">out-10:</div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson19">UNIT 19. СОБЫТИЯ МЫШИ В JAVASCRIPT</h4>

                    <p>В javascript существуют следующие события:</p>
                    <ol>
                        <li>
                            oncklick - клик левой кнопки мыши
                        </li>
                        <li>
                            ondblclick - двойной клик левой кнопки мыши
                        </li>
                        <li>
                            oncontextmenu - клик правой кнопки мыши(который инициирует вызов контекстного меню), "return
                            false"
                            в
                            функции которая вызывается данным событием отменяет контекстное меню.
                        </li>
                        <li>
                            onmousemove - при движении курсора мыши.
                        </li>
                        <li>
                            onmouseenter - при вхождении курсора мыши в область елемента.
                        </li>
                        <li>
                            onmouseleave - при покидании курсора мыши области елемента.
                        </li>
                        <li>onmousedown/onmouseup - комбинация событий работающая на зажатии и отжатии левой кнопки
                            мыши.
                        </li>
                    </ol>

                    <div class="unit19container">
                        <div class="blockone">one</div>
                        <div class="blocktwo">two</div>
                        <hr>
                        <div class="blockthree">three</div>
                        <hr>
                        <progress id="progressbar" value="10" max="100"></progress>
                        <button id="buttprogress">progress</button>
                    </div>

                    <hr>


                    <ol>
                        <li>
                            <p>Добавьте на блок .blockevent1 событие клик и по клику запуск функции funcevent1. Функция
                                должна
                                возвращать и выводить
                                на экран содержимое блока (только текст). Вывод осуществляется в out-1. </p>
                            <div class="blockevent event1">task-1</div>
                            <div class="outevent1">out-1:</div>
                        </li>
                        <li>
                            <p>Добавьте на блок .blockevent2 событие клик и по клику запуск функции funcevent2. Функция
                                должна
                                возвращать true или false в зависимости от того,
                                нажата ли клавиша alt или нет в момент клика. Также, выводите на экран результат. Вывод
                                осуществляется в out-2.</p>
                            <div class="blockevent event2">task-2</div>
                            <div class="outevent2">out-2:</div>
                        </li>
                        <li>
                            <p>Добавьте на блок .event3 событие клик. При клике - увеличивайте ширину блока на 5px.
                                Каждый
                                клик
                                -
                                увеличение ширины на 5px. 10 кликов - на 50px. Ширину выводите в out-3.</p>
                            <div class="blockevent event3">task-3</div>
                            <div class="outevent3">out-3:</div>
                        </li>
                        <li>
                            <p>Добавьте на блок .blockevent4 событие двойной клик и по двойному клику запуск функции
                                funcevent4.
                                Функция должна возвращать и выводить на экран содержимое блока (только текст). Вывод
                                осуществляется
                                в out-4.</p>
                            <div class="blockevent event4">task-4</div>
                            <div class="outevent4">out-4:</div>
                        </li>
                        <li>
                            <p>Дан блок .blockevent5.active. Добавьте на него событие двойной клик, по которому удалется
                                класс
                                active если он есть и добавляется если такого класса нет.</p>
                            <div class="blockevent event5 active">task-5</div>
                        </li>
                        <li>
                            <p>Дан блок .event6 и список .ulevent6. При двойном клике на блоке скрывайте .ulevent6 если
                                он
                                показан и
                                показывайте если скрыт. Скрытие и показ делайте через добавление - удаление класса
                                .hideevent6.</p>
                            <div class="blockevent event6">task-6</div>
                            <ul class="ulevent6">
                                <li>one</li>
                                <li>two</li>
                                <li>three</li>
                            </ul>
                            <div class="outevent6">
                            </div>
                        </li>
                        <li>
                            <p>Дан блок .event7. При клике правой кнопкой мыши на блоке добавляйте ему класс .active.
                                При
                                повторном
                                клике - удаляйте.</p>
                            <div class="blockevent event7">task-7</div>
                        </li>
                        <li>
                            <p>Дано .checkboxevent8. Повесьте на него событие onchange при котором на документе
                                отключается
                                клик
                                правой кнопкой мыши если checkbox выбран и отключает если не выбран.</p>
                            <div class="form-control">
                                <label>
                                    <input type="checkbox" class="checkboxevent8"> включить / выключить
                                    контекстное меню
                                </label>
                            </div>
                        </li>
                        <li>
                            <p>Дан блок .event9. Внутри блока - изображение 1.png. При клике правой кнопкой мыши -
                                меняйте
                                изображение на 2.png. Надеюсь вы догадаетесь изменить только src изображения?</p>
                            <div class="blockeventimage event9">task-9
                                <img src="./assets/jojo1.png" width="150" alt="jojo1">
                            </div>
                        </li>
                        <li>
                            <p>Дан блок .event10. Внутри блока - изображение 1.png. При наведении мыши (mouseenter) -
                                меняйте
                                изображение на 2.png.</p>
                            <div class="blockeventimage event10">task-10
                                <img src="./assets/jojo1.png" width="150" alt="jojo1">
                            </div>
                        </li>
                        <li>
                            <p>Дан блок .event11. Внутри блока - изображение 1.png. При наведении мыши (mouseenter) -
                                меняйте
                                изображение на 2.png. При уведении мыши - mouseleave - возвращайте исходное
                                изображение.</p>
                            <div class="blockeventimage event11">task-11
                                <img src="./assets/jojo1.png" alt="jojo1" width="150">
                            </div>
                        </li>
                        <li>
                            <p>Дан блок .event12. Добавьте на него событие mousedown - при нажатии кнопки мыши -
                                добавляйте
                                ему
                                класс active.</p>
                            <div class="blockevent event12">task-12</div>
                        </li>
                        <li>
                            <p>Дан блок .event13. Добавьте на него событие mousedown - при нажатии кнопки мыши -
                                добавляйте
                                ему
                                класс active. Добавьте ему событие mouseup - при отпускании мыши - удаляйте класс
                                active.</p>
                            <div class="blockevent event13">task-13</div>
                        </li>
                        <li>
                            <p>Дан блок .event14. При нажатии кнопки buttevent14 добавляйте к нему событие onclick -
                                которое,
                                при
                                клике добавляем блоку event14 класс active.</p>
                            <div class="blockevent event14">task-14</div>
                            <button id="buttevent14">press</button>
                        </li>
                        <li>
                            <p>Дан блок .event15. Добавьте на него событие onmousemove. При каждом движении мыши
                                увеличивайте
                                число
                                внутри на 1.</p>
                            <div class="blockevent event15">0</div>
                        </li>
                        <li>
                            <p>Дан блок .event16. Добавьте на него событие onmousemove. При каждом движении мыши
                                увеличивайте
                                ширину
                                блока на 1px.</p>
                            <div class="blockevent event16">task-16</div>
                        </li>
                        <li>
                            <p>Дано 2 кнопки - butteven17_on и butteven17_off. Напишите фукнции funcevent17On и
                                funcevent17Off
                                которые включают и отключают событие move в задании 16.</p>
                            <button id="buttevent17_on">ON</button>
                            <button id="buttevent17_off">OFF</button>
                        </li>
                        <li>
                            <p>Дан блок .event18. Напишите фукнцию funcevent18 которая выводит в данный блок его ширину
                                при
                                событии
                                onmouseenter.</p>
                            <div class="blockevent event18">task-18</div>
                        </li>
                        <li>
                            <p>Дан блок .event19. Напишите фукнцию funcevent19 которая выводит в данный блок его классы
                                при
                                событии
                                onmouseout.</p>
                            <div class="blockevent event19 active">task-19</div>
                        </li>
                        <li>
                            <p>Дан элемент progress. Напишите фукнцию funcevent20 которая увеличивает его value на 1 при
                                каждом
                                событии mousemove внутри progress.</p>
                            <progress id="progressbar20" value="10" max="100"></progress>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson20">UNIT 20. СОБЫТИЯ КЛАВИАТУРЫ В JAVASCRIPT</h4>

                    <p>Срабатывание input: onchange(срабатывает когда инпут теряет фокус); oninput(срабатывает при любом
                        изменении);</p>
                    <p>onkeypress - срабатывает только на цифрах и буквах ентере пробеле и некоторых вспомогательных
                        клавишах</p>
                    <div>
                        <input aria-label="inputkb" type="text" class="inputkb">
                    </div>
                    <div>
                        <label for="checkboxkb">CapsLock</label>
                        <input id="checkboxkb" type="checkbox" class="checkboxkb">
                    </div>
                    <br>
                    <div>
                        <input aria-label="inputkbfalse" type="text" class="inputkbfalse">
                    </div>


                    <ol>
                        <li>
                            <p>Дан input .inputkb1. Напишите функцию funckb1, которая выводит в .outkb1 символ и
                                возвращает
                                его.
                                Во
                                всех
                                последующих задачах - работаем с латиницей и цифрами. </p>
                            <input aria-label="inputkb1" type="text" class="inputkb1">
                            <div class="outkb1"></div>
                        </li>
                        <li>
                            <p>Дан input .inputkb2. Напишите функцию funckb2, которая выводит в .outkb2 код символа и
                                возвращает
                                его. </p>
                            <input aria-label="inputkb2" type="text" class="inputkb2">
                            <div class="outkb2"></div>
                        </li>
                        <li>
                            <p>Дан input .inputkb3. Напишите функцию funckb3, которая выводит на страницу true если
                                введен
                                символ и
                                false если
                                цифра. Для определения - используйте код клавиши. </p>
                            <input aria-label="inputkb3" type="text" class="inputkb3">
                            <div class="outkb3"></div>
                        </li>
                        <li>
                            <p>Дан input .inputkb4. Напишите функцию funckb4, которая выводит в .outkb4 только символы в
                                нижнем
                                регистре. Т.е.
                                ввели ab4Bci в out получаем ab4bci. </p>
                            <input aria-label="inputkb4" type="text" class="inputkb4">
                            <div class="outkb4">
                            </div>
                        </li>
                        <li>
                            <p>Дан input .inputkb5. Напишите функцию funckb5, которая выводит в .outkb5 все вводимые
                                символы
                                в
                                верхнем регистре.
                                Т.е. пользователь ввел AbCd и функция выведет ABCD. </p>
                            <input aria-label="inputkb5" type="text" class="inputkb5">
                            <div class="outkb5"></div>
                        </li>
                        <li>
                            <p>Дан input .inputkb6. Напишите функцию funckb6, которая выводит в .inputkb6 только символы
                                в
                                нижнем
                                регистре. </p>
                            <input aria-label="inputkb6" type="text" class="inputkb6">
                            <div class="outkb6"></div>
                        </li>
                        <li>
                            <p>Дан input .inputkb7. Напишите функцию funckb7, которая выводит в .outkb7 случаный символ
                                из
                                массива
                                arraykb7 при каждом
                                вводе символа.</p>
                            <input aria-label="inputkb7" type="text" class="inputkb7">
                            <div class="outkb7"></div>
                        </li>
                        <li>
                            <p>Дан input .inputkb8. Напишите функцию funckb8, которая выводит в .outkb8 вводимый в input
                                текст,
                                но
                                заменяет i на 1,
                                o на 0, l на 7.</p>
                            <input aria-label="inputkb8" type="text" class="inputkb8">
                            <div class="outkb8"></div>
                        </li>
                        <li>
                            <p>Дан input .inputkb9. Напишите функцию funckb8, выводит в .outkb9 количество нажатых
                                клавиш
                                стрелка
                                вниз.</p>
                            <input aria-label="inputkb9" type="text" class="inputkb9">
                            <div class="outkb9"></div>
                        </li>
                        <li>
                            <p>Дан input .inputkb10 и изображение 1.png. Добавьте событие на input, при нажатии клавиш
                                стрелка
                                вправо и
                                стрелка влево увеличивать ширину изображения. Клавиши стрелка вверх и вниз - увеличивать
                                высоту
                                изображения. Одно нажатие клавиши - 1px.</p>
                            <input aria-label="inputkb10" type="text" class="inputkb10">
                            <div class="blockeventimage divkb10">
                                <img src="./assets/jojo1.png" width="150" height="80" alt="" id="jojoimg10">
                            </div>
                            <div class="outkb10"></div>
                        </li>
                        <li>
                            <p>1. Выполните в html верстку клавиш клавиатуры. Сверстайте – блок цифровых клавиш от 1 до
                                0. И
                                ряд
                                клавиш q – p. Добавьте
                                клавишу левый shift, левый alt, левый ctrl, пробел, enter.</p>
                            <p>2. Добавьте на input .inputkb11 событие onkeypress или onkeyup или onkeydown ( по вашему
                                выбору).
                                Когда событие происходит (
                                ввод символа в input) необходимо подсветить ( добавить класс active) клавише с таким
                                символом.
                                Со
                                всех остальных клавиш
                                – удалить класс active.</p>
                            <p>3. Если вводится следующий символ – повторить удаление active и подсветить клавишу с
                                введенным
                                символом.</p>
                            <p>4. Ограничения проекта – тестируются только указанные клавиши в латинской раскладке.
                                Комбинации
                                клавиш не тестируются.
                                Т.е. нажиматься shift+A, ctrl+shift – не будут. Все символы вводятся в нижнем
                                регистре.</p>
                            <a href="./public/keyboard.html" target="_blank">Верстка клавиш клавиатуры</a>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson21">UNIT 21. КРАТКИЙ ОБЗОР TOUCH СОБЫТИЙ</h4>

                    <div class="touchevent"></div>
                    <div class="outtouchevent"></div>
                    <div class="outtouchevent-1"></div>
                    <div class="outtouchevent-2"></div>
                    <br>
                    <div class="touchevent-1"></div>
                    <div class="outtouchevent-3"></div>


                    <ol>
                        <li>
                            <p>Создайте блок diveventmove1. Добавьте на него событие touchstart. Выведите в
                                outeventmove1
                                слово
                                touch
                                если событие сработает. </p>
                            <div class="diveventmove1 blockevent"></div>
                            <div class="outeventmove1"></div>
                        </li>
                        <li>
                            <p>Создайте блок diveventmove2. Добавьте на него событие touchstart. Выведите в
                                outeventmove2
                                число
                                срабатываний события.</p>
                            <div class="diveventmove2 blockevent"></div>
                            <div class="outeventmove2"></div>
                        </li>
                        <li>
                            <p>Создайте блок diveventmove3_1 и diveventmove3_2. Добавьте на них событие touchstart.
                                Выведите
                                в
                                outeventmove3 номер блока 1 или 2
                                на котором сработало событие.</p>
                            <div class="diveventmove3_1 blockevent">1</div>
                            <div class="diveventmove3_2 blockevent">2</div>
                            <div class="outeventmove3"></div>
                        </li>
                        <li>
                            <p>Создайте блок diveventmove4. И кнопку butteventmove4. При нажатии кнопки - добавляйте
                                событие
                                ontouchstart на блок diveventmove4.
                                При событии происходит вывод текста touch в outeventmove4. </p>
                            <button id="butteventmove4">Task-4</button>
                            <div class="diveventmove4 blockevent"></div>
                            <div class="outeventmove4"></div>
                        </li>
                        <li>
                            <p> Дана кнопка butteventmove5. При ее нажатии очищайте событие ontouchstart на блоке
                                diveventmove4.</p>
                            <button id="butteventmove5">Task-5</button>

                        </li>
                        <li>
                            <p> Добавьте событие ontouchend на diveventmove4. При его срабатывании выведите в
                                outeventmove6
                                слово
                                touchend.</p>
                            <div class="outeventmove6"></div>
                        </li>
                        <li>
                            <p> Дан блок diveventmove7. Добавьте событие touch, при срабатывании которого окрашивайте
                                блок в
                                красный
                                цвет.</p>
                            <div class="diveventmove7 blockevent">7</div>
                        </li>
                        <li>
                            <p>Дан блок diveventmove8. Добавьте на него событие touch, которое при срабатывании
                                окрашивает
                                блок
                                случаным цветом
                                из массива arrayeventmove8=[red, green, blue, orange, pink, yellow] </p>
                            <div class="diveventmove8 blockevent"></div>
                            <div class="outeventmove8"></div>
                        </li>
                        <li>
                            <p>Дан блок diveventmove9. Добавьте событие ontouch. Выводите количество одновременных
                                касаний в
                                outeventmove9.</p>
                            <div class="diveventmove9 blockevent"></div>
                            <div class="outeventmove9">
                            </div>
                        </li>
                        <li>
                            <p>Дан блок diveventmove10. Добавьте на него событие touchmove. При срабатывании события -
                                увеличивайте
                                его ширину
                                на 1.</p>
                            <div class="diveventmove10 blockevent">10</div>
                            <div class="outeventmove10"></div>
                        </li>
                        <li>
                            <p> Дан блок diveventmove11. Добавьте на него событие touch. При срабатывании выводите
                                радиус
                                события
                                radiusX,
                                radiusY.</p>
                            <div class="diveventmove11 blockevent">11</div>
                            <div class="outeventmove11">
                            </div>
                        </li>
                        <li>
                            <p>Изучите html код внутри diveventmove12-wrapper.</p>
                            <p>1. Добавьте на кнопку next событие click, touch так, чтобы при событии запускалась
                                функция
                                nextFunction и
                                активным становилось изображение следующее за выделенным классом active-img (рамкой).
                                Соответственно, на
                                активном изображении появляется рамка, а остальные - лишаются рамки.</p>
                            <p>2. Добавьте на кнопку prev событие click, touch так, чтобы при событии запускалась
                                функция
                                prevFunction и
                                активным становилось изображение до выделенного классом active-img (рамкой).
                                Соответственно,
                                на
                                активном
                                изображении появляется рамка, а остальные - лишаются рамки.</p>
                            <p>3. Учтите краевые эффекты - когда мы доходим до конца или начала, то нажатие кнопки
                                должно
                                приводить
                                к
                                перемещению рамки в начало или конец изображений.</p>
                            <p>4. Добавьте кнопку reset (функция resetFunction), нажатие которой сбрасывает активное
                                изображение
                                на
                                нулевое. </p>
                            <p>5. Добавьте во все действия следующее - в изображении img-12-max заменяется src на
                                активную.
                                Т.е.
                                произошло событие - заменилась главная картинка.</p>

                            <div class="diveventmove12-wrapper">
                                <img src="./assets/1.png" alt="1" class="img-12-min active-img">
                                <img src="./assets/2.png" alt="2" class="img-12-min">
                                <img src="./assets/3.png" alt="3" class="img-12-min">
                                <img src="./assets/4.png" alt="4" class="img-12-min">
                                <img src="./assets/5.png" alt="5" class="img-12-min">
                                <img src="./assets/6.png" alt="6" class="img-12-min">
                            </div>
                            <div class="diveventmove12-max">
                                <img src="./assets/1.png" alt="1" class="img-12-max"></div>
                            <p class="img-12-text"></p>
                            <button class="prev12">Prev</button>
                            <button class="next12">Next</button>
                            <button class="reset12">Reset</button>
                            <div class="outeventmove12"></div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson22">UNIT 22. ОБРАБАТЫВАЕМ ОШИБКИ С ПОМОЩЬЮ TRY CATCH</h4>

                    <div class="divtry"></div>

                    <ol>
                        <li>
                            <p>Добавьте в код функции try catch так, чтобы вместо ошибки выводилось в tryout1 цифра
                                1.</p>
                            <button id="trybutt1">Task-1</button>
                            <div class="tryout1"></div>
                        </li>
                        <li>
                            <p>Добавьте в код функции try catch так, чтобы вместо ошибки был вывод результата в
                                tryout2.</p>
                            <button id="trybutt2">Task-2</button>
                            <div class="tryout2"></div>
                        </li>
                        <li>
                            <p>Добавьте в код функции try catch так, чтобы вместо ошибки был вывод результата в tryout3.
                                Если
                                его
                                нет - создавайте в коде.
                                т.е. вы не знаете будет или нет он в html.</p>
                            <button id="trybutt3">Task-3</button>
                        </li>
                        <li>
                            <p>Дана переменная atry4. В переменную делается push. Используя try catch отловите ошибки
                                если
                                они
                                есть.
                                Если ошибка вывести в tryout4 число 0. Если не ошибка - то результирующий массив через
                                пробел.</p>
                            <button id="trybutt4">Task-4</button>
                            <div class="tryout4"></div>
                        </li>
                        <li>
                            <p>Добавьте try, catch, finnaly так, чтобы в tryout5 выводился 0 при ошибки. А в tryout5-1
                                всегда
                                выводилось слово 'finnaly';</p>
                            <button id="trybutt5">Task-5</button>
                            <div class="tryout5"></div>
                            <div class="tryout5-1"></div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson23">UNIT 23. LOCALSTORAGE. СОХРАНЯЕМ ВСЕ</h4>

                    <p>При сохранении массива в localStorage, он преобразуется в строку!!!</p>
                    <p>Чтобы сохранить массив в LS не переводя его в строку, используют JSON.stringify; чтобы заданная
                        переменная
                        или константа так же не переводила массив в строку используют JSON.parse;</p>
                    <p>Метод JSON.stringify() преобразует значение JavaScript в строку JSON, возможно с заменой
                        значений,
                        если
                        указана функция замены, или с включением только определённых свойств, если указан массив
                        замены.</p>
                    <p>Метод JSON.parse() разбирает строку JSON, возможно с преобразованием получаемого в процессе
                        разбора
                        значения.</p>
                    <a href="./public/testlocalStorage.html" target="_blank">страница для тестирования LS</a>
                    <div class="testLS"></div>

                    <ol>
                        <li>
                            <p>Создайте функцию funcLS1 которая записывает в LS ключ 5 со значением 11. Проверьте что
                                происходит
                                при
                                повторном вызове функции. Запускается ф-я по кнопкуе buttLS1. </p>
                            <button id="buttLS1">Task-1</button>
                        </li>
                        <li>
                            <p> Создайте функцию funcLS2 которая записывает в LS массив arrayLS2 = [7,6,5]. Ключ
                                arrayLS2.
                                Проверьте
                                что происходит при
                                повторном вызове функции. Запускается ф-я по кнопкуе buttLS2.</p>
                            <button id="buttLS2">Task-2</button>
                        </li>
                        <li>
                            <p> При нажатии кнопки funcLS3 выведите из LS сохранненный массив arrayLS2. Выведите в
                                divLS3 в
                                формате
                                ключ пробел
                                значение перенос строки. </p>
                            <button id="buttLS3">Task-3</button>
                            <div class="divLS3"></div>
                        </li>
                        <li>
                            <p>Создайте функцию funcLS4 которая записывает в LS массив arrayLS4 = {hello: world,
                                hi:mahai}.
                                Ключ
                                arrayLS4. Проверьте что
                                происходит при повторном вызове функции. Запускается ф-я по кнопкуе buttLS4.</p>
                            <button id="buttLS4">Task-4</button>
                            <div class="divLS4"></div>
                        </li>
                        <li>
                            <p> При нажатии кнопки buttLS5 выведите из LS сохранненный массив arrayLS4. Выведите в
                                divLS5 в
                                формате
                                ключ пробел
                                значение перенос строки. </p>
                            <button id="buttLS5">Task-5</button>
                            <div class="divLS5"></div>
                        </li>
                        <li>
                            <p>Создайте функцию funcLS6 которая очищает весь LS. Запуск по кнопке buttLS6.</p>
                            <button id="buttLS6">Task-6</button>
                            <div class="divLS6"></div>
                        </li>
                        <li>
                            <p> Создайте input inputLS7 куда пользователь может вводить числа и строки. Создайте массив
                                arrayLS7.
                                Когда
                                пользователь нажимает кнопку buttLS7 число должно добавляться в массив. Массив должен
                                сохраняться в
                                LS с
                                ключем arrayls7.</p>
                            <div class="form-control">
                                <label>Введите значение</label>
                                <input aria-label="Enter some info" type="text" placeholder="Enter some info"
                                       id="inputLS7">
                            </div>
                            <button id="buttLS7">Task-7</button>
                        </li>
                        <li>
                            <p>Создайте функцию funcLS8 при запуске которой из arrayLS7 удаляется последний элемент.
                                После
                                чего
                                массив сохраняется
                                в LS с ключем arrayLS7. Использовать массив из предыдущего задания.</p>
                            <button id="buttLS8">Task-8</button>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson24">UNIT 24. НЕМНОГО ТЕОРИИ - РАБОТА С POST, GET ЗАПРОСАМИ</h4>

                    <p>данный сервер более не доступен</p>

                    <p>Метод GET это способ обращения к серверу, в котором информация запрашивается и передается через
                        адресную
                        строку</p>
                    <p>Помимо URL адреса также содержит параметры. Знаком вопроса адрес отделяется от параметров, далее
                        идет
                        параметр равно значение который в свою очередь отделяется от других параметров амперсандом:</p>
                    <p> Пример гет строки: <code>https//.....?action=edit&amp;section=1</code></p>
                    <p>Метод POST не дублирует информацию в адресной строке.</p>

                    <p>GET запрос</p>
                    <form action="t1.dat">
                        <input aria-label="first param" type="text" name="one" placeholder="переход по ссылке...">
                        <input aria-label="second param" type="number" name="two" placeholder="...с параметрами">
                        <input type="submit" value="GO">
                    </form>
                    <p>POST запрос</p>
                    <form action="t1.dat" method="post">
                        <input aria-label="first param" type="text" name="one" placeholder="переход по ссылке...">
                        <input aria-label="second param" type="number" name="two" placeholder="...с параметрами">
                        <input type="submit" value="GO">
                    </form>

                    <ol>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                1.
                                Если
                                все сделано верно, сервер пришлет строку hello.
                                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на
                                проверку не
                                присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                2.
                                Добавьте параметр name с вашим именем на латинице.
                                Если все сделано верно, сервер пришлет строку hello ваше имя. Не забывайте указывать
                                параметр
                                auth
                                (ключ в чате).
                                Используем POSTMAN. Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                3.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет сумму чисел. Не забывайте указывать параметр auth
                                (ключ в
                                чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                4.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте
                                указывать
                                параметр auth (ключ в чате). Используем POSTMAN.
                                Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                5.
                                Если
                                все сделано верно, сервер вернет текущее время и дату.
                                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на
                                проверку не
                                присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                6.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр
                                auth
                                (ключ
                                в
                                чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                7.
                                Если
                                все сделано верно, сервер случайную ссылку на изображение.
                                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на
                                проверку не
                                присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                8. В
                                качестве параметра по очереди укажите year равный году вашего рождения.
                                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ
                                в
                                чате).
                                Используем POSTMAN. Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                9. В
                                качестве параметра по очереди укажите m = 1, d=1, y=1.
                                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать
                                параметр
                                auth (ключ в чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                1.
                                Если
                                все сделано верно, сервер пришлет строку hello.
                                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на
                                проверку не
                                присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                2.
                                Добавьте параметр name с вашим именем на латинице.
                                Если все сделано верно, сервер пришлет строку hello ваше имя. Не забывайте указывать
                                параметр
                                auth
                                (ключ в чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                3.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет сумму чисел. Не забывайте указывать параметр auth
                                (ключ в
                                чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                4.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте
                                указывать
                                параметр auth (ключ в чате). Используем POSTMAN.
                                Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                5.
                                Если
                                все сделано верно, сервер вернет текущее время и дату.
                                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на
                                проверку не
                                присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                6.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр
                                auth
                                (ключ
                                в
                                чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                7.
                                Если
                                все сделано верно, сервер случайную ссылку на изображение.
                                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на
                                проверку не
                                присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                8.
                                В
                                качестве параметра по очереди укажите year равный году вашего рождения.
                                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ
                                в
                                чате).
                                Используем POSTMAN. Данную работу на проверку не присылаем.</p>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                9.
                                В
                                качестве параметра по очереди укажите m = 1, d=1, y=1.
                                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать
                                параметр
                                auth (ключ в чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson25">UNIT 25. AJAX - АСИНХРОННЫЙ JAVASCRIPT</h4>

                    <p>данный сервер более не доступен</p>

                    <ol>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                1.
                                Выведите в outAJAX1 результат. Запускаться функция должна по нажатию buttAJAX1.</p>
                            <button id="buttAJAX1">Сделать запрос</button>
                            <div class="outAJAX1"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                2.
                                Добавьте параметр name с вашим именем на латинице.
                                Если все сделано верно, сервер пришлет строку hello ваше имя. Выведите в outAJAX2
                                результат.
                                Запускаться функция должна по нажатию buttAJAX2.</p>
                            <button id="buttAJAX2">Сделать запрос</button>
                            <div class="outAJAX2"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                3.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет сумму чисел. Выведите в outAJAX3 результат.
                                Запускаться
                                функция должна по нажатию buttAJAX3.</p>
                            <button id="buttAJAX3">Сделать запрос</button>
                            <div class="outAJAX3"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                4.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте
                                указывать
                                параметр auth (ключ в чате). Выведите в outAJAX4 результат.
                                Запускаться функция должна по нажатию buttAJAX4.</p>
                            <button id="buttAJAX4">Сделать запрос</button>
                            <div class="outAJAX4"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                5.
                                Если
                                все сделано верно, сервер вернет текущее время и дату.
                                Не забывайте указывать параметр auth (ключ в чате). Выведите в outAJAX5 результат.
                                Запускаться
                                функция должна по нажатию buttAJAX5.</p>
                            <button id="buttAJAX5">Сделать запрос</button>
                            <div class="outAJAX5"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                6.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр
                                auth
                                (ключ
                                в
                                чате). Выведите в outAJAX6 результат.
                                Запускаться функция должна по нажатию buttAJAX6.</p>
                            <button id="buttAJAX6">Сделать запрос</button>
                            <div class="outAJAX6"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                7.
                                Если
                                все сделано верно, сервер случайную ссылку на изображение.
                                Не забывайте указывать параметр auth (ключ в чате). Выведите в outAJAX7 результат.
                                Запускаться
                                функция должна по нажатию buttAJAX7.</p>
                            <button id="buttAJAX7">Сделать запрос</button>
                            <div class="outAJAX7"></div>
                            <div class="containerAJAX7"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                8. В
                                качестве параметра по очереди укажите year равный году вашего рождения.
                                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ
                                в
                                чате).
                                Выведите в outAJAX8 результат. Запускаться функция должна по нажатию buttAJAX8.</p>
                            <button id="buttAJAX8">Сделать запрос</button>
                            <div class="outAJAX8"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                9. В
                                качестве параметра по очереди укажите m = 1, d=1, y=1.
                                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать
                                параметр
                                auth (ключ в чате). Выведите в outAJAX9 результат.
                                Запускаться функция должна по нажатию buttAJAX9.</p>
                            <button id="buttAJAX9">Сделать запрос</button>
                            <div class="outAJAX9"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                1.
                                Выведите в outAJAX10 результат. Запускаться функция должна по нажатию buttAJAX10.</p>
                            <button id="buttAJAX10">Сделать запрос</button>
                            <div class="outAJAX10"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                2.
                                Добавьте параметр name с вашим именем на латинице.
                                Если все сделано верно, сервер пришлет строку hello ваше имя. Не забывайте указывать
                                параметр
                                auth
                                (ключ в чате).
                                Выведите в outAJAX11 результат. Запускаться функция должна по нажатию buttAJAX11.</p>
                            <button id="buttAJAX11">Сделать запрос</button>
                            <div class="outAJAX11"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                3.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет сумму чисел. Не забывайте указывать параметр auth
                                (ключ в
                                чате). Выведите в outAJAX12 результат.
                                Запускаться функция должна по нажатию buttAJAX12.</p>
                            <button id="buttAJAX12">Сделать запрос</button>
                            <div class="outAJAX12"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                4.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте
                                указывать
                                параметр auth (ключ в чате).
                                Выведите в outAJAX13 результат. Запускаться функция должна по нажатию buttAJAX13.</p>
                            <button id="buttAJAX13">Сделать запрос</button>
                            <div class="outAJAX13"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                5.
                                Если
                                все сделано верно, сервер вернет текущее время и дату.
                                Не забывайте указывать параметр auth (ключ в чате). Выведите в outAJAX14 результат.
                                Запускаться
                                функция должна по нажатию buttAJAX14.</p>
                            <button id="buttAJAX14">Сделать запрос</button>
                            <div class="outAJAX14"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                6.
                                Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр
                                auth
                                (ключ
                                в
                                чате). Выведите в outAJAX15 результат.
                                Запускаться функция должна по нажатию buttAJAX15.</p>
                            <button id="buttAJAX15">Сделать запрос</button>
                            <div class="outAJAX15"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                7.
                                Если
                                все сделано верно, сервер случайную ссылку на изображение.
                                Не забывайте указывать параметр auth (ключ в чате). Выведите в outAJAX16 результат.
                                Запускаться
                                функция должна по нажатию buttAJAX16.</p>
                            <button id="buttAJAX16">Сделать запрос</button>
                            <div class="outAJAX16"></div>
                            <div class="containerAJAX16"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                8.
                                В
                                качестве параметра по очереди укажите year равный году вашего рождения.
                                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ
                                в
                                чате). Выведите в outAJAX17 результат. Запускаться функция должна по нажатию
                                buttAJAX17.</p>
                            <button id="buttAJAX17">Сделать запрос</button>
                            <div class="outAJAX17"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                9.
                                В
                                качестве параметра по очереди укажите m = 1, d=1, y=1.
                                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать
                                параметр
                                auth (ключ в чате). Выведите в outAJAX18 результат.
                                Запускаться функция должна по нажатию buttAJAX18.</p>
                            <button id="buttAJAX18">Сделать запрос</button>
                            <div class="outAJAX18"></div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson26">UNIT 26. УЧИМ FETCH НА ПРАКТИКЕ</h4>

                    <p>Fetch имеет следующие параметры:</p>
                    <ol>
                        <li>
                            <p>'input' - параметр куда записываем адрес к которому хотим обратиться, в нашем примере
                                'https://getpost.itgid.info/index2.php'.</p>
                        </li>
                        <li>
                            <p>promise - обработчик результата ответа</p>
                        </li>
                    </ol>

                    <h4>Tasks:</h4>

                    <ol>
                        <li>
                            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                1. Выведите в outfetch1 результат. Запускаться функция должна по нажатию buttfetch1.</p>
                            <button id="buttfetch1">Сделать запрос</button>
                            <div class="outfetch1"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                2. Добавьте параметр name с вашим именем на латинице.
                                Если все сделано верно, сервер пришлет строку hello ваше имя. Выведите в outfetch2
                                результат.
                                Запускаться функция должна по нажатию buttfetch2.</p>
                            <button id="buttfetch2">Сделать запрос</button>
                            <div class="outfetch2"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                3. Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет сумму чисел. Выведите в outfetch3 результат.
                                Запускаться
                                функция должна по нажатию buttfetch3.</p>
                            <button id="buttfetch3">Сделать запрос</button>
                            <div class="outfetch3"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                4. Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте
                                указывать
                                параметр auth (ключ в чате). Выведите в outfetch4 результат.
                                Запускаться функция должна по нажатию buttfetch4.</p>
                            <button id="buttfetch4">Сделать запрос</button>
                            <div class="outfetch4"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                5. Если все сделано верно, сервер вернет текущее время и дату.
                                Не забывайте указывать параметр auth (ключ в чате). Выведите в outfetch5 результат.
                                Запускаться
                                функция должна по нажатию buttfetch5.</p>
                            <button id="buttfetch5">Сделать запрос</button>
                            <div class="outfetch5"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                6. Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр
                                auth
                                (ключ
                                в
                                чате). Выведите в outfetch6 результат. Запускаться функция должна по нажатию
                                buttfetch6.</p>
                            <button id="buttfetch6">Сделать запрос</button>
                            <div class="outfetch6"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                7. Если все сделано верно, сервер случайную ссылку на изображение.
                                Не забывайте указывать параметр auth (ключ в чате). Выведите в outfetch7 результат.
                                Запускаться
                                функция должна по нажатию buttfetch7.</p>
                            <button id="buttfetch7">Сделать запрос</button>
                            <div class="outfetch7"></div>
                            <div class="containerfetch7"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                8. В качестве параметра по очереди укажите year равный году вашего рождения.
                                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ
                                в
                                чате).
                                Выведите в outfetch8 результат. Запускаться функция должна по нажатию buttfetch8.</p>
                            <button id="buttfetch8">Сделать запрос</button>
                            <div class="outfetch8"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                9. В качестве параметра по очереди укажите m = 1, d=1, y=1.
                                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать
                                параметр
                                auth (ключ в чате). Выведите в outfetch9 результат. Запускаться функция должна по
                                нажатию
                                buttfetch9.</p>
                            <button id="buttfetch9">Сделать запрос</button>
                            <div class="outfetch9"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                1. Выведите в outfetch10 результат. Запускаться функция должна по нажатию
                                buttfetch10.</p>
                            <button id="buttfetch10">Сделать запрос</button>
                            <div class="outfetch10"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                2. Добавьте параметр name с вашим именем на латинице.
                                Если все сделано верно, сервер пришлет строку hello ваше имя. Не забывайте указывать
                                параметр
                                auth
                                (ключ в чате). Выведите в outfetch11 результат. Запускаться функция должна по нажатию
                                buttfetch11.</p>
                            <button id="buttfetch11">Сделать запрос</button>
                            <div class="outfetch11"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                3. Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет сумму чисел. Не забывайте указывать параметр auth
                                (ключ в
                                чате). Выведите в outfetch12 результат. Запускаться функция должна по нажатию
                                buttfetch12.</p>
                            <button id="buttfetch12">Сделать запрос</button>
                            <div class="outfetch12"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                4. Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте
                                указывать
                                параметр auth (ключ в чате). Выведите в outfetch13 результат.
                                Запускаться функция должна по нажатию buttfetch13.</p>
                            <button id="buttfetch13">Сделать запрос</button>
                            <div class="outfetch13"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                5. Если все сделано верно, сервер вернет текущее время и дату.
                                Не забывайте указывать параметр auth (ключ в чате). Выведите в outfetch14 результат.
                                Запускаться
                                функция должна по нажатию buttfetch14.</p>
                            <button id="buttfetch14">Сделать запрос</button>
                            <div class="outfetch14"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                6. Добавьте параметр num1 и num2 содержащие числа.
                                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр
                                auth
                                (ключ
                                в
                                чате). Выведите в outfetch15 результат. Запускаться функция должна по нажатию
                                buttfetch15.</p>
                            <button id="buttfetch15">Сделать запрос</button>
                            <div class="outfetch15"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                7. Если все сделано верно, сервер случайную ссылку на изображение.
                                Не забывайте указывать параметр auth (ключ в чате). Выведите в outfetch16 результат.
                                Запускаться
                                функция должна по нажатию buttfetch16.</p>
                            <button id="buttfetch16">Сделать запрос</button>
                            <div class="outfetch16"></div>
                            <div class="containerfetch16"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                8. В качестве параметра по очереди укажите year равный году вашего рождения.
                                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ
                                в
                                чате).Выведите в outfetch17 результат. Запускаться функция должна по нажатию
                                buttfetch17.</p>
                            <button id="buttfetch17">Сделать запрос</button>
                            <div class="outfetch17"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве
                                action
                                укажите
                                9. В качестве параметра по очереди укажите m = 1, d=1, y=1.
                                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать
                                параметр
                                auth (ключ в чате). Выведите в outfetch18 результат.
                                Запускаться функция должна по нажатию buttfetch18.</p>
                            <button id="buttfetch18">Сделать запрос</button>
                            <div class="outfetch18"></div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson27">UNIT 27. РАБОТАЕМ С ПРОМИСАМИ (PROMISE)</h4>

                    <p>Объект Promise используется для отложенных и асинхронных вычислений.</p>
                    <h4>Синтаксис:</h4>
                    <p>new Promise(function(resolve, reject) { ... });</p>
                    <p>Где resolve вызывает успешное исполнение промиса, а reject отклоняет его</p>
                    <h4>Promise может находиться в трёх состояниях:</h4>
                    <ol>
                        <li>ожидание (pending): начальное состояние, не исполнен и не отклонён.</li>
                        <li>исполнено (fulfilled): операция завершена успешно.</li>
                        <li>отклонено (rejected): операция завершена с ошибкой.</li>
                    </ol>

                    <h4>Методы промиса:</h4>
                    <ul>
                        <li>
                            <p>Promise.all(iterable)</p>
                            <p>Ожидает исполнения всех промисов или отклонения любого из них. Возвращает промис, который
                                исполнится
                                после исполнения всех промисов в iterable.
                                В случае, если любой из промисов будет отклонён, Promise.all будет также отклонён.</p>
                        </li>
                        <li>
                            <p>Promise.allSettled(iterable)</p>
                            <p>Ожидает завершения всех полученных промисов (как исполнения так и отклонения). Возвращает
                                промис,
                                который исполняется когда все полученные промисы завершены (исполнены или отклонены),
                                содержащий массив результатов исполнения полученных промисов.</p>
                        </li>
                        <li>
                            <p>Promise.race(iterable)</p>
                            <p>Ожидает исполнения или отклонения любого из полученных промисов. Возвращает промис,
                                который
                                будет
                                исполнен или отклонён с результатом исполнения первого исполненного или отклонённого
                                промиса
                                из
                                iterable.</p>
                        </li>
                        <li>
                            <p>Promise.reject(reason)</p>
                            <p>Возвращает промис, отклонённый из-за reason.</p>
                        </li>
                        <li>
                            <p>Promise.resolve(value)</p>
                            <p>Возвращает промис, исполненный с результатом value.</p>
                        </li>
                    </ul>

                    <h4>Tasks:</h4>
                    <ol>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                1.</p>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                2.</p>
                            <p>Два запроса объедините с помощью promiseAll. Результат выведите в outpromise1 результат.
                                Запускаться
                                функция должна по нажатию buttpromise1.</p>
                            <button id="buttpromise1">Сделать запрос</button>
                            <div class="outpromise1"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                3.
                                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет
                                сумму
                                чисел.</p>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                4.
                                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет
                                случайное
                                число в заданном диапазоне.</p>
                            <p>Два запроса объедините с помощью promiseAll. Выведите в outpromise2 результат.
                                Запускаться
                                функция
                                должна по нажатию buttpromise2.</p>
                            <button id="buttpromise2">Сделать запрос</button>
                            <div class="outpromise2"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                5.
                                Если
                                все сделано верно, сервер вернет текущее время и дату. Не забывайте указывать параметр
                                auth
                                (ключ в
                                чате).</p>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                6.
                                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет
                                большее
                                число.</p>
                            <p>Два запроса объедините с помощью promiseAll. Выведите в outpromise3 результат.
                                Запускаться
                                функция
                                должна по нажатию buttpromise3.</p>
                            <button id="buttpromise3">Сделать запрос</button>
                            <div class="outpromise3"></div>
                        </li>
                        <li>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                7.
                                Если
                                все сделано верно, сервер случайную ссылку на изображение. Не забывайте указывать
                                параметр
                                auth
                                (ключ в чате).</p>
                            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                8. В
                                качестве параметра по очереди укажите year равный году вашего рождения. Если все
                                правильно
                                сервер
                                вернет ваш возраст.</p>
                            <p>Выведите в outpromise4 результат. Запускаться функция должна по нажатию buttpromise4.</p>
                            <button id="buttpromise4">Сделать запрос</button>
                            <div class="outpromise4"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите 1.</p>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите 2.</p>
                            <p>Два запроса объедините с помощью promiseAll. Результат выведите в outpromise5 результат.
                                Запускаться
                                функция должна по нажатию buttpromise5.</p>
                            <button id="buttpromise5">Сделать запрос</button>
                            <div class="outpromise5"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                3.
                                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет
                                сумму
                                чисел.</p>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                4.
                                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет
                                случайное
                                число в заданном диапазоне.</p>
                            <p>Два запроса объедините с помощью promiseAll. Выведите в outpromise6 результат.
                                Запускаться
                                функция
                                должна по нажатию buttpromise6.</p>
                            <button id="buttpromise6">Сделать запрос</button>
                            <div class="outpromise6"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                5.
                                Если
                                все сделано верно, сервер вернет текущее время и дату. Не забывайте указывать параметр
                                auth
                                (ключ в
                                чате).</p>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                6.
                                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет
                                большее
                                число.</p>
                            <p>Два запроса объедините с помощью promiseAll. Выведите в outpromise7 результат.
                                Запускаться
                                функция
                                должна по нажатию buttpromise7.</p>
                            <button id="buttpromise7">Сделать запрос</button>
                            <div class="outpromise7"></div>
                        </li>
                        <li>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                7.
                                Если
                                все сделано верно, сервер случайную ссылку на изображение. Не забывайте указывать
                                параметр
                                auth
                                (ключ в чате).</p>
                            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action
                                укажите
                                8.
                                В
                                качестве параметра по очереди укажите year равный году вашего рождения. Если все
                                правильно
                                сервер
                                вернет ваш возраст.</p>
                            <p>Два запроса объедините с помощью promiseAll. Выведите в outpromise8 результат.
                                Запускаться
                                функция
                                должна по нажатию buttpromise8.</p>
                            <button id="buttpromise8">Сделать запрос</button>
                            <div class="outpromise8"></div>
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson28">UNIT 28. ООП В ES6</h4>

                    <div class="testOOP"></div>
                    <div class="testOOP1"></div>

                    <p>Классы в JavaScript представляют собой синтаксический сахар над существующим в JavaScript
                        механизмом
                        прототипного наследования.
                        Синтаксис классов не вводит новую объектно-ориентированную модель, а предоставляет более простой
                        и
                        понятный
                        способ создания объектов и организации наследования.</p>
                    <p>p.s. На самом деле классы — это "специальные функции", поэтому точно также, как вы определяете
                        функции
                        (function expressions и function declarations),
                        вы можете определять и классы с помощью: class declarations и class expressions.</p>
                    <p>Первый способ определения класса — class declaration (объявление класса). Для этого необходимо
                        воспользоваться ключевым словом class и указать имя класса.</p>
                    <pre>
class Rectangle {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
}
    </pre>
                    <p>Второй способ определения класса — class expression (выражение класса). Можно создавать
                        именованные и
                        безымянные выражения.
                        В первом случае имя выражения класса находится в локальной области видимости класса и может быть
                        получено
                        через свойства самого класса, а не его экземпляра.</p>
                    <pre>
// безымянный
var Rectangle = class {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
};
console.log(Rectangle.name);
// отобразится: "Rectangle"

// именованный
var Rectangle = class Rectangle2 {
    constructor(height, width) {
        this.height = height;
        this.width = width;
    }
};
console.log(Rectangle.name);
// отобразится: "Rectangle2"
    </pre>

                    <h4>Tasks:</h4>
                    <ol>
                        <li>Создайте класс Goods. Класс должен содержать свойства name, amount. Создайте на его основе
                            объект
                            goods.
                            Выведите в консоль созданный объект. Помните, все классы - в отдельных файлах. Имена классов
                            с
                            большой
                            буквы.
                        </li>
                        <li>Добавьте в класс Goods свойства image и count - картинка и количество на складе.</li>
                        <li> Добавьте в класс Goods метод draw, который будет выводить div с изображением, названием
                            товара,
                            ценой -
                            в указанный элемент (дозапись).
                        </li>
                        <li>Создайте на основе класса Goods объект goods2, заполните свойства, примените метод draw для
                            вывода
                            товара на страницу в блок out-4.
                            <div class="outOOP4"></div>
                        </li>
                        <li>Создайте класс Goods2, который наследуется от Goods. Добавьте ему свойство sale равное true
                            или
                            false. Перезапишите метод draw так, чтобы он выводил информацию о распродажах.
                        </li>
                        <li>Создайте на основе класса Goods2 объект goods3. Заполните все поля. Выведите товар на
                            страницу с
                            помощью метода draw. Вывод осуществить в out-6.
                            <div class="outOOP6"></div>
                        </li>
                        <li>Создайте класс Valid, который содержит свойства email, password, isValid. И метод validate.
                            Метод
                            validate должен проверять длину пароля и писать false в isValid если длина меньше 6 и true
                            если
                            больше. Изначально свойство isValid равно false.
                        </li>
                        <li>Создайте объект на основе класса Valid и задайте ему имя и пароль длиной 5 символов.
                            Запустите
                            метод
                            validate() и выведите в консоль свойство isValid.
                        </li>
                        <li>Создайте объект на основе класса Valid и задайте ему имя и пароль длиной 7 символов.
                            Запустите
                            метод
                            validate() и выведите в консоль свойство isValid.
                        </li>
                        <li>Унаследуйтесь от класса Valid и создайте класс Valid2. Расширьте его свойствами emaiError,
                            passwordError. По умолчанию, они равны пустой строке. Перезапишите метод validate(), помимо
                            проверки
                            пароля,
                            он должен содержать еще проверку свойства email на пустоту. Если поле email пустое - то
                            isValid
                            -
                            false.
                            Также, в случае ошибки валидации в поле emailError пишется сообщение ‘email empty’, в поле
                            passwordError - ‘min length 6’.
                        </li>
                        <li>Создайте на основе класса Valid2 объект valid2 и задайте пустой емейл и длину пароля меньше
                            7.
                            Запустите метод validate(). Выведите объект в консоль.
                        </li>
                        <li>Создайте на основе класса Valid2 объект valid3 и задайте не пустой емейл и длину пароля
                            больше
                            7.
                            Запустите метод validate(). Выведите объект в консоль.
                        </li>
                    </ol>
                </section>

                <section>
                    <h4 id="JSlesson29">UNIT 29. ЗАМЫКАНИЯ</h4>
                    <p>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была
                        определена.
                        Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней
                        функции.
                        В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.</p>

                    <p>Вы можете вложить одну функцию в другую. Вложенная функция (nested function; inner) приватная
                        (private) и она помещена
                        в другую функцию (outer). Так образуется замыкание (closure). Closure — это выражение (обычно
                        функция), которое может
                        иметь свободные переменные вместе со средой, которая связывает эти переменные (что "закрывает"
                        ("close") выражение).</p>
                    <p>Замыкания это следствие работы функции в javascript</p>

                    <button id="buttclosure1">первый счетчик</button>
                    <div class="outclosure1"></div>
                    <button id="buttclosure2">второй счетчик</button>
                    <div class="outclosure2"></div>
                </section>

                <section>
                    <h4 id="JSlesson30">UNIT 30. РЕКУРСИЯ</h4>

                    <p>Рекурсия это возможность функции вызвать саму себя</p>
                    <p>Функция, которая вызывает саму себя, называется рекурсивной функцией (recursive function).
                        Получается,
                        что рекурсия аналогична циклу (loop). Оба вызывают некоторый код несколько раз, и оба требуют
                        условия
                        (чтобы избежать бесконечного цикла, вернее бесконечной рекурсии). </p>

                    <div class="tableWrapper">
                        <div class="boxforbox">
                            <div class="moovingblock"></div>
                        </div>
                    </div>
                    <br>
                    <button id="moovingbutt">двигай</button>
                    <button id="stopMoving">стоп</button>

                    <p>задание для unit24</p>

                    <form action="http://getpost.itgid.info/index2.php">
                        <input aria-label="auth" type="text" name="auth" placeholder="auth"><br>
                        <input aria-label="action" type="text" name="action" placeholder="action"><br>
                        <input aria-label="name" type="text" name="name" placeholder="name"><br>
                        <input aria-label="num1" type="text" name="num1" placeholder="num1"><br>
                        <input aria-label="num2" type="text" name="num2" placeholder="num2"><br>
                        <input aria-label="year" type="text" name="year" placeholder="year"><br>
                        <input aria-label="m" type="text" name="m" placeholder="m"><br>
                        <input aria-label="d" type="text" name="d" placeholder="d"><br>
                        <input aria-label="y" type="text" name="y" placeholder="y"><br>
                        <input aria-label="go" type="submit" value="go"><br>
                    </form>
                </section>

            </section>
        </section>

        <section id="ReactFullCoursesNav">
            <h2 id="ReactBase">Основы React</h2>

            <section id="ReactNav">
                <h3 id="BaseReact">Базовый React</h3>

                <section>
                    <h4 id="commonReactInfo">Общая информация о React</h4>

                    <div>
                        <p>React - JavaScript библиотека для создания пользовательских интерфейсов(UI)</p>
                        <p>React позволяет избежать императивный метод программирования когда логика программы
                            указывается
                            шаг за шагом выполняя одни и те же действия</p>
                        <p>React разбивает приложение на компоненты и каждый компонент имеет небольшую задачу, упрощая
                            поддержку приложения, использующийся же подход называется декларативным</p>
                        <p>Альтернативами React являются:</p>
                        <ul>
                            <li>Angular-более объемная библиотека</li>
                            <li>Vue- что-то среднее между React и Angilar</li>
                        </ul>

                        <p>Все шаги по работе с create-react-app прописаны на <a
                                href="https://github.com/facebook/create-react-app" target="_blank">Гитхабе</a></p>
                        <p>А по работе с самим React на<a href="https://react.dev/learn">React.dev</a></p>
                    </div>
                </section>

                <section>
                    <h4 id="Components">Компоненты</h4>

                    <div>
                        <p>Компоненты - фундаментальные блоки приложений React</p>
                        <p>Подобный подход позволяет их использовать повторно(Dont Repeat Yourself) и разделять
                            ответсвенность(Не делать слишком много и в одном и том же месте)</p>
                    </div>
                    <div>
                        <p>Создание веб приложений при помощи React опирается на компоненты.
                            Компонент это часть JSX кода, который помещен в отдельный файл и обернут
                            функцией(возвращающая
                            функция, т.е. с return()),
                            которая потом импортируется как тэг в другой компонент или в корневой компонент</p>
                        <p>Пример:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/component.png" alt="component" style="max-height: 449px">
                        </div>
                        <div class="smallScreenContainer">
                            <img src="./assets/componentImport.png" alt="componentImport">
                        </div>
                        <p>"App" является корневым компонентом тк собирает в себе все остальные компоненты и потом в
                            итоге
                            рендерится на страницу.</p>
                    </div>
                </section>

                <section>
                    <h4 id="DeclatationMethod">Декларативный подход</h4>

                    <div>
                        <p>При помощи React мы определяем конечное целевое состояние и позволяем React самому определить
                            нужные
                            JavaScript DOM инструкции.
                            Данный подход называется декларативным</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSX">JSX код</h4>

                    <div>
                        <p>Львиная доля кода в приложениях React написана на JSX коде, в среде JavaScript это не
                            валидный
                            код.
                            Благодаря преобразованию React он перерабатывается в обычный JS код</p>
                        <p>пример:</p>
                        <pre>
function functionName (){
    return (
        &lt;div&gt;
            &lt;h1&gt;Content&lt;/h1&gt;
        &lt;/div&gt;);
}
            </pre>
                    </div>
                </section>

                <section>
                    <h4 id="CSSstyling">Стилизация CSS</h4>

                    <div>
                        <p>Для стилизации компонентов используются все те же CSS стили.</p>
                        <p>CSS файл импортируется в файл компонента(import './File.css') и потом с помощью атрибута
                            className='...' подключается к стилизируемому элементу</p>
                        <p>Общепринято называть CSS файл так же как компонент.</p>
                    </div>
                </section>

                <section>
                    <h4 id="JSXrender">Отображение динамических данных в JSX</h4>

                    <div>
                        <p>Для отображения динамических данных используются одинарные фигурные скобки {expresion}</p>
                        <p>пример:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/динамическое_отображение_данных.png" alt="dinamicData">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="Props">Передача данных при помощи props</h4>

                    <div>
                        <p>Если данные, которые нужно использовать в текущем файле находятся вне его, то используют
                            концепцию
                            props:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/props.png" alt="props">
                        </div>
                        <p>Т.е. мы задаем некие атрибуты внутри тега компонента, и в файле где мы его настраиваем,
                            подключаем их
                            в скобках функции параметром "props" и потом в коде с помощью props.atribute :</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/props1.png" style="max-width: 400px" alt="props1">
                        </div>
                        <div class="smallScreenContainer">
                            <img src="./assets/props2.png" style="max-width: 400px" alt="props2">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="dividingComponents">Разделение компонента на несколько компонентов</h4>

                    <div>
                        <p>Когда некий компонент чрезмерно разрастается, его принято разбивать на несколько
                            компонентов</p>
                        <p>При разбитии компонента на несколько компонентов иногда требуется "протаскивать" параметры к
                            отделенным компонентам,
                            делается это дублированием параметров в новом компоненте с параметром props:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/newComponent1.png" style="max-width: 400px" alt="newComponent">
                        </div>
                        <div class="smallScreenContainer">
                            <img src="./assets/newComponent2.png" style="max-width: 400px" alt="newComponent">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="propsChildren">Композиция {props.children}</h4>

                    <div>
                        <p>Для создания компонента который служит оболочкой контента используют {props.children}, т.е.
                            настраивают отдельный файл компонент,
                            применяют к нему CSS стили, ставят в функции между закрытым тэгом {props.children} и
                            импортируют
                            его
                            в нужный файл, и используют
                            его тэг в качестве стилизирующей обертки, таким образом сокращая повторяющийся CSS код.
                            Далее к
                            этому тэгу стили нельзя применить
                            на прямую и нужно добавлять переменную в которую через конкатенацию нужного стиля и
                            props.className
                            указывают все требуемые стили:</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/childrenCard.png" style="max-width: 500px" alt="childrenCard">
                        </div>
                        <br>
                        <div class="smallScreenContainer">
                            <img src="./assets/cardImport1.png" style="max-width: 500px" alt="cardImport1">
                        </div>
                        <br>
                        <div class="smallScreenContainer">
                            <img src="./assets/cardImport2.png" style="max-width: 500px" alt="cardImport2">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="oldReactMethod">Старый метод программирования React</h4>

                    <div>
                        <p>Ранее нужно было импортировать "import React from "react"", и вместо обычного JSX кода
                            возвращался
                            объект с методом React.createElement():</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/oldReactMethod.png" style="max-width: 500px" alt="oldReactMethod">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="folderOrganization">Организация файлов компонентов</h4>

                    <div>
                        <p>При разрастании файлов компонентов их следует разместить в поддерикториях:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/fileOrganisation.png" style="max-width: 250px" alt="fileOrganisation">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="onHandlers">Прослушивание событий и работа с обработчиками событий</h4>

                    <div>
                        <p>Мы можем добавить атрибут "on" для любого события которое поддерживает этот элемент. Список
                            событий
                            можно посмотреть на

                            <a href="https://developer.mozilla.org/ru/docs/Web/API/Element" target="_blank">MDN</a> в
                            списке
                            событий.</p>
                        <p>Все события в React начинаются на "on..."(onClick={function} f.e.) и имеют следующий вид
                            записи:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/eventListener.png" style="max-width: 500px" alt="eventListener">
                        </div>
                        <p>В конце названий функций обработчиков событий принято писать "Handler"</p>
                    </div>
                </section>

                <section>
                    <h4 id="workWithState">Работа с состоянием</h4>

                    <div>
                        <p>Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие
                            возможности
                            React
                            без написания классов.</p>
                        <p>Хук useState возвращает значение с состоянием и функцию для его обновления. Используется если
                            пользователь нажатием кнопки изменяет контент.</p>
                        <p>Во время первоначального рендеринга возвращаемое состояние (state) совпадает со значением,
                            переданным
                            в качестве первого аргумента (initialState).</p>
                        <pre>const [state, setState] = useState(initialState);</pre>
                        <p>Функция setState используется для обновления состояния. Она принимает новое значение
                            состояния и
                            ставит в очередь повторный рендер компонента.</p>
                        <pre>setState(newState);</pre>
                        <p>useState можно использовать в пределах одного компонента к разным элементом неограниченное
                            количество
                            раз:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/multipleUseStateUsage1.png" style="max-width: 500px"
                                 alt="multipleUseStateUsage">
                        </div>
                        <p>Так же в useState можно передать объект и управлять несколькими состояниями одновременно, при
                            этом
                            обязательно нужно
                            учитывать все объекты при многократном вызове функции и считается не очень хорошей практикой
                            обновления состояния:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/multipleUseStateUsage2.png" style="max-width: 500px"
                                 alt="multipleUseStateUsage">
                        </div>
                        <p>Лучше всего будет при втором способе в качестве параметра задать функцию с prevState в
                            скобках и
                            возвратить prevState вместе с изменяемым значением:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/multipleUseStateUsage3.png" style="max-width: 500px"
                                 alt="multipleUseStateUsage">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="twoWayBinding">Добавление двустороннего связывания</h4>

                    <div>
                        <p>Для того чтобы очистить форму, в случае если к применен метод event.preventDefault(),
                            применяют
                            двухстороннее
                            связывание, где в хэндлере обработчике формы вконце кода вставляют функции обновляющие
                            состояния
                            инпутов с
                            пустым содержимым между ковычками( setInputName(''); ),а в самих инпутах добавляют атрибут
                            value={inputName}:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/twoWayBinding.png" alt="twoWayBinding">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="componentCommunication">Коммуникация компонентов наследник-родитель (Снизу Вверх)</h4>

                    <div>
                        <p>Чтобы передавать какую-то информацию от наследника к родителю, нужно в родительском
                            компоненте
                            создать атрибут значением которой будет функция, задать функции параметр, и через props
                            вызвать
                            эту
                            функцию в компоненте-наследнике, передав параметром в скобках этой функции нужную
                            информацию,
                            в итоге в параметр функции родительского компонента будет записана информация:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/relativComponentData.png" alt="relativComponentData"
                                 style="max-width: 350px">
                        </div>
                        <div class="smallScreenContainer">
                            <img src="./assets/childComponentData.png" alt="childComponentData"
                                 style="max-width: 350px">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="liftingStateUp">Подъем состояния вверх</h4>

                    <div>
                        <p>В случае если нужно передать информацию от одного компонента к другому, но они не имеют
                            прямой
                            иерархии(родитель-наследник или наоборот) используют подъем состояния вверх, когда
                            информацию
                            поднимают до общего родителя и потом уже опускают ее дальше по иерархии к нужному
                            компоненту</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/liftingStateUp.png" alt="liftingStateUp">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="dummyComponentsVsComponentsWithState">Компоненты - контролируемые vs неконтролируемые, с
                        состоянием vs без состояния</h4>

                    <div>
                        <p>Каждый раз когда мы используем двухстороннее связывание мы контролируем компонент</p>
                        <p>Если в компоненте не используется обработчик состояния, то данный компонент называется
                            "глупым"
                            или
                            компонентом без состояния.</p>
                    </div>
                </section>

                <section>
                    <h4 id="dynamicContent">Отображение списков данных(Работа с динамическим контентом)</h4>

                    <div>
                        <p>В случае, если нам требуется отобразить некий контент, который меняется динамично, нам
                            следует
                            создать выражение{expression},
                            где внутри фигурных скобок, мы будем применять нужный нам метод к JSX коду, тоесть в скобках
                            этого
                            метода мы спокойно можем
                            применять компоненты:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/dinamicData.png" alt="dinamicData">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="useState">Использование cписков с cостоянием</h4>

                    <div>
                        <p>Чтобы вносить какие-то данные в массив нужно использовать useState и далее уже с помощью
                            обновляющей
                            функции set() добавляем новые данные в массив сохраняя при этом старые данные:</p>
                        <pre>
const [arrName, setArrName] = useState(oldArrName);

setArrNAme(prevArr =&gt; {
     return [newArrElem, ...prevArr]
});
            </pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/addingNewArrElem.png" alt="addingNewArrElem">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="keysConcept">концепция Keys</h4>

                    <div>
                        <p>В случае если мы используем объекты или массивы, для того чтобы React мог различать элементы
                            внутри
                            массивов или объектов, обязателшьно нужно их нумеровать добавляя атрибут "key" и задать ему
                            уникальный
                            идентификационный номер(id). Данная концепция позволяет избежать багов и "перерендера"
                            списка:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/conceptKey.png" alt="conceptkey">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="ternaryOperator">Отображение контента по условию</h4>

                    <div>
                        <p>В React при задании условия нужно использовать тернарный(условный) оператор {условие ?
                            выражение1
                            :
                            выражение2}:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/ternaryOperator1.png" style="max-width: 430px" alt="ternaryOperator1">
                        </div>
                        <p>или {условие && выражение1}+{условие && выражение2} возвращается то, что соответствует
                            условию:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/ternaryOperator2.png" alt="ternaryOperator2" style="max-width: 430px">
                        </div>
                        <p>или задать переменную с базовым контентом вне "return", через оператор if(){} задать условие
                            с
                            альтернативным контентом
                            и уже через expression{} вывести эту переменную в return:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/ifExpression3.png" alt="ifExpression3">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="returnValueByCondition">Возвращение значения по условию</h4>

                    <div>
                        <p>Так же мы можем с помощью оператора if возвращать два return, первый из которых будет
                            возвращаться по
                            какому-то условию,
                            отменяя тем самым второй, а второй будет возвращать контент дефолтно если не срабатывает
                            условие
                            первого:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/DBLreturn.png" alt="DBLreturn">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="dynamicStyles">Динамические cтили</h4>

                    <div>
                        <p>Чтобы добавить стиль, который будет меняться в зависимости от какого-то события/условия или
                            переменной,
                            к требуемому компоненту используют следующий синтаксис:</p>
                        <pre>
const barFillHeigth = Math.round(props.value / props.maxValue * 100) + '%';

&lt;div style={{
        bacgroundColor: "yellow",
        height: barFillheight
}}&gt;&lt;div/&gt;
            </pre>
                        <p>Т.е. в expression мы задаем объект, который содержит в себе как постоянные стили так и стили
                            с
                            заданными переменными(динамические стили):</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/dynamicStyles.png" alt="dynamicStyles">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="title">Title</h4>

                    <p>Чтобы сменить название вкладки в бауезере нужно зайти в папку "public">"index.html" и в теге
                        title поменять на нужное название</p>
                </section>

                <section>
                    <h4 id="CssReact">CSS в React</h4>

                    <p>В React стили делятся на условные и динамические</p>
                </section>

                <section>
                    <h4 id="dynamicCss">Динамическое добавление стилей</h4>

                    <div>
                        <p>Для того чтобы стиль менялся в зависимости от будевых значений, можно пользоваться
                            синтаксисом
                            тернарного оператора:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/inlineStyles.png" alt="inlineStyles">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="dynamicClasses">Динамическое добавление классов</h4>

                    <div>
                        <p>Так же как и для стилей к классам можно применять синтаксис тернарного оператора и задавать
                            при
                            каких
                            условиях применяется один класс,
                            а при каких другой и так же нужно использовать синтаксис обратных кавычек и знак - className
                            ={`...
                            ${ifStatement ? ...: ...}`} :</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/dynamicClasses.png" alt="dynamicClasses">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="StyledComponents">Знакомство со <a href="https://styled-components.com" target="_blank">Styled
                        Components</a></h4>

                    <div>
                        <p>Пакет Styled Components позволяет создавать стилизованные компоненты, таким образом,
                            что стили соданные для определенных компонентов применяются ТОЛЬКО к ним.</p>
                        <p>В директории с проектом в командной строке нужно ввести:</p>
                        <pre>npm install --save styled-components</pre>

                        <p>Имеет следующий синтаксис:</p>
                        <pre>
const Button = styled.button`

    width: 100%;
    font: inherit;
    padding: 0.5rem 1.5rem;
    color: white;
    background: #00358b;
    border-radius: 4px;
    box-shadow: 0 0 4px rgba(50, 50, 50, 0.25);
    cursor: pointer;

    media (min-width: 700px) {
        width: auto;


        &:focus {
            outline: none;
        }

        &:hover,
        &:active {
            background: #245fbd;
            box-shadow: 0 0 8px rgba(50, 50, 50, 0.25);
        }
    }
`;
            </pre>
                        <p>Где после метода button открываются обратные кавычки, так же вместо этого метода может
                            использоваться
                            h1,h2... p и тд, т.е. любой тэг.</p>
                        <p>Для псевдо селекторов используется &:, для вложенных элементов просто & с пробелом</p>
                    </div>
                </section>

                <section>
                    <h4 id="DynamicProps">Styled Components и Динамические Props</h4>

                    <div>
                        <p>В случае если мы создаем компонент, который будет использоваться только одним другим
                            компонентом,
                            то
                            можно его создать в этом же файле:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/innerStyledComponent.png" alt="innerStyledComponent">
                        </div>
                        <p>Так же для этого компонента можно устанавливать классы, которые будут добавляться при
                            каких-то
                            условиях:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/dynamicPropsStyledComponents.png" alt="dynamicPropsStyledComponents">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="StyledCopmponentsMediaQueries">Styled Components и Media Queries</h4>

                    <div>
                        <p>Так же как и в обычном CSS в Styled Components можно использовать Media Queries:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/styledComponentsMediaQueries.png" alt="styledComponentsMediaQueries">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="CssModules">Использование CSS Модулей</h4>

                    <div>
                        <p>При данном методе нужно изменить название CSS файла и добавить '.module' перед '.css':</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/CSSModulesReact.png" alt="CSSModulesReact">
                        </div>
                        <p>Далее нужно импортировать созданный файл с полным названием, но импортируется уже объект
                            "styles"(название любое,
                            в данном объекте содержатся все классы, определенные в CSS), и применить его к требуемому
                            компоненту
                            с одноименным
                            свойством (относительно классов находящимся в CSS файле через точку):</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/importCSSModulesReact.png" alt="importCSSModulesReact">
                        </div>
                        <p>Обращаться к свойству объекта можно как через точку, так и через скобки, содержимое которых
                            закрываем
                            кавычками:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/syntCSSModulesReact.png" alt="syntCSSModulesReact">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="dynamicModules">Динамические Стили и CSS Модули</h4>

                    <div>
                        <p>В случае если нам нужен стиль меняющийся в зависимости от каких то условий то, через
                            синтаксис
                            обратных кавычек можно добавить следующее:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/dynamicCSSModulesReact.png" alt="dynamicCSSModulesReact">
                        </div>
                        <p>Для Media Queries мы используем обычный синтаксис CSS:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/mediaQueriesModulesReact.png" alt="mediaQueriesModulesReact">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="Debugging">Отладка (Debugging) приложений React. Работа с Breakpoints.</h4>

                    <div>
                        <p>Для того чтобы работать с Breakpoints нужно открыть инструмент разработчика, зайти во вкладку
                            "Sources",
                            далее в "src" папке найти исполняемые JS файлы, и в предпологаемом месте в нумерации строк
                            поставить
                            синий флажок Breakpoint'a,
                            после чего с помощью кнопок перемещения по функциям вызова двигаться по исполняемому коду,
                            анализируя его на предмет ошибок:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/breakpointDebugg.png" alt="BreakpointDebugg">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="ReactDevTools">Использование React DevTools</h4>

                    <div>
                        <p>Расширение для Google Chrome браузера, позволяет увидеть древо компонентов так, как оно
                            расположено в
                            React,
                            отображает информацию о функциях и хуках:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/reactDeveloperTools.png" alt="reactDeveloperTools">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="JSXrestrictions">Ограничения JSX</h4>

                    <div>
                        <p>Из компонентаневозможно вернуть два находящихся на одном уровне JSX елемента(нельзя
                            возвращать
                            более
                            одного "root" элемента)</p>
                        <p>Решение- просто обернуть в один "root" элемент(div), минусом будет являться множество лишних
                            элементов</p>
                        <p>Алтернативное решение - вернуть массивом, отделяя смежные элементы запятыми:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/returnRootElements.png" alt="returnRootElements">
                        </div>
                        <p>Данный метод же имеет следующий минус - нужно к каждому элементу добавлять ключи(key).</p>
                        <p>Еще одна альтернатива - создание кастомного элемента обертку "Wrapper", который импортируется
                            в
                            нужный файл
                            и оборачивает элементы находящиеся на одном уровне, таким образом он позволяет избегать
                            лишних
                            div в
                            DOM структуре:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/wrapper.png" style="max-width: 350px" alt="wrapper">
                        </div>
                        <div class="smallScreenContainer">
                            <img src="./assets/wrapperUsage.png" alt="wrapperUsage">
                        </div>
                        <p>Есть дефолтный метод обхода ограничения JSX - React.Fragment:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/ReactFragment.png" alt="ReactFragment">
                        </div>
                        <p>В основном используются "Fragment".</p>
                    </div>
                </section>

                <section>
                    <h4 id="Portals">Порталы</h4>

                    <div>
                        <p>Чтобы написать качественную структуру DOM в случае если используются оверлеи, можно
                            использовать
                            "порталы"</p>
                        <p>С помощью порталов можно структурировать DOM по нашему усмотрению:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/addPortal.png" alt="addPortal">
                        </div>
                        <br>
                        <div class="smallScreenContainer">
                            <img src="./assets/ReactDOMcreatePortal.png" alt="ReactDOMcreatePortal">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="useRef">Работа с хуком useRef</h4>

                    <div>
                        <p>При помощи хука useRef мы можем установить соединение между HTML элементом(f.e. input) и JS
                            кодом.</p>
                        <p>данный хук требует импорта import React,{useRef} from 'react', и присваивание некоей
                            переменной
                            через
                            useRef,
                            далее к зарезервированному атрибуту "ref" мы присваиваем эту переменную:</p>
                        <pre>
const a = useRef();

&lt;input ref={A} /&gt;
            </pre>
                        <p>После привязки Refs к HTML элементу нам нужно объявить новую переменную, которой мы уже
                            присвоим
                            следующее:</p>
                        <pre>
const submitHandler = (event) => {
    event.preventDefault();
    const ARefs = a.current.value;
}
            </pre>
                        <p>В случае если нам требуется очистить поля input то мы можем присвоить A.current.value пустую
                            строку </p>
                        <pre>a.current.value = '';</pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/RefsExample.png" alt="RefsExample">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="useEffect">Побочные эффекты</h4>

                    <div>
                        <p>К побочным эффектам относятся:</p>
                        <ul>
                            <li>Сохранение данных в Storage браузера</li>
                            <li>Отправка HTTP запросов к серверу</li>
                            <li>Установка и управление таймерами</li>
                            <li>Ect.</li>
                        </ul>
                        <p>Все эти задачи должны происходить вне нормальной оценки компонентов и циклов отображения,
                            особенно если они могут задерживать/блокировать отображение.</p>
                        <p>Для управления побочными эффектами существует хук "useEffect()", со следующим
                            синтаксисом:</p>
                        <pre>useEffect( () => {...}, [dependencies] )</pre>
                        <p>Где, первый аргумент это функция, которая должна выполняться после каждой оценки компонента,
                            ЕСЛИ
                            указанные dependencies изменились.
                            В эту функцию помещается код побочного эффекта.</p>
                        <p>Второй же аргумент [dependencies] - это зависимости этого эффекта(если меняются, то функция
                            выполняется).</p>
                        <p>Как правило, во втором аргументе используют те же переменные, что и в первом.</p>
                    </div>
                </section>

                <section>
                    <h4 id="Debouncing">Функция очистки</h4>

                    <div>
                        <p>Функция очистки (debouncing) позволяет превратить несколько вызовов функции в течение
                            определенного
                            времени в один вызов, причем задержка начинает заново отсчитываться с каждой новой попыткой
                            вызова.
                            Возможно два варианта:</p>
                        <ol>
                            <li>
                                Реальный вызов происходит только в случае, если с момента последней попытки прошло
                                время,
                                большее или равное задержке.
                            </li>
                            <li>
                                Реальный вызов происходит сразу, а все остальные попытки вызова игнорируются, пока не
                                пройдет
                                время, большее или равное задержке,
                                отсчитанной от времени последней попытки.
                            </li>
                        </ol>
                        <div class="smallScreenContainer">
                            <img src="./assets/debouncing.png" alt="debouncing" id="useEffectExamp">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="useReducer">хук useReducer</h4>

                    <div>
                        <p>хук useReducer помогает работать с состоянием так же как и хук useState, но используется для
                            более
                            сложных состояний.</p>
                        <p>Иногда нужно работать с более сложными состояниями - например, с несколькими состояниями, с
                            несколькими способами изменения состояния
                            или с состоянием, зависящим от других состояний. В таком случае useState становится трудным
                            в
                            использовании, высока вероятность багов.</p>
                    </div>
                </section>

                <section>
                    <h4 id="useReducerUsage">Использование useReducer</h4>

                    <div>
                        <p>Так же как и useState, useReducer возвращает массив, и так же можно провести его
                            деструктуризацию:</p>
                        <pre>const [state, dispatchFunction] = useReducer(reducerFunction, initialState, initialFunction)</pre>
                        <p>Где:</p>
                        <ul>
                            <li><strong>state</strong> - состояние, используемое в цикле переоценки/ перерисовки
                                компонента.
                            </li>
                            <li><strong>dispatchFunction</strong> - функция, которая может быть использована для
                                отправки
                                нового действия(action) (то есть включающая обновление состояния)
                            </li>
                            <li><strong>reducerFunction</strong> - функция, которая вызывается автоматически, когда
                                действие(action) отправлено(при помощи функции dispatchFunction).<br>
                                Она получает в качестве аргумента последнее состояние и должна возвращать обновленное
                                состояние.
                            </li>
                            <li><strong>initialState</strong> - первоначальное состояние.</li>
                            <li><strong>initialFunction</strong> - функция для установки первоначального состояния
                                программно.
                            </li>
                        </ul>
                        <p>Пример использования useReducer при управлении формой:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/useReducer.png" alt="useReducer">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="useStateVSuseReducer">useState VS useReducer</h4>

                    <div>
                        <table class="jsTheoryTable">
                            <caption>Когда использовать:</caption>
                            <thead>
                            <tr>
                                <th>useState</th>
                                <th>useReducer</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td>Основной инструмент для работы с состоянием</td>
                                <td>Удобен когда нужна большая гибкость</td>
                            </tr>
                            <tr>
                                <td>Удобен для независимых друг от друга состояний</td>
                                <td>Использовать, когда есть состояния тесно связанные друг с другом</td>
                            </tr>
                            <tr>
                                <td>Удобен в случаях, когда обновление состояния несложное и есть немного видов
                                    обновлений
                                </td>
                                <td>Удобен в случаях, когда обновление состояния сложное</td>
                            </tr>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="Context">Context</h4>

                    <div>
                        <p>В случае когда дерево компонентов слишком большое и требуется передать какую-то информацию от
                            одного
                            компонента
                            к другому на большом удалении друг от друга, вместо подъема информации вверх можно
                            использовать
                            context.</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/context.png" alt="context">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="contextApiUsage">Использование Context API</h4>

                    <div>
                        <p>Для использования context нужно создать файл с переменной, в которую помещают "const Context
                            =
                            React.createContext()" где метод createContext() возвращает требуемый нам код.</p>
                        <p>Далее мы импортируем созданный файл в нужный нам компонент, где мы оборачиваем нужные нам
                            компоненты
                            названием переменной и чтобы управлять информацией,
                            задаем value={}:</p>
                        <pre>
&lt;Context.Provider value={}&gt;
     Компоненты
&lt;Context.Provider/&gt;
            </pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/contextComponent.png" style="max-width: 500px" alt="contextComponent">
                        </div>
                        <p>и так же через точку нужно предоставить доступ компонентам через Provider в родительском
                            компоненте:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/ContextProvider.png" style="max-width: 500px" alt="ContextProvider">
                        </div>
                        <p>Далее в компоненте, где требуются данные, мы оборачиваем JSX код следующим:</p>
                        <pre>
&lt;Context.Consumer&gt;
    {(context) => {
        return (
           context.JSXcode
        )
    }
&lt;Context.Provider/&gt;
            </pre>
                        <p>Где мы создаем функцию с аргументом "context" с помощью которого мы уже передаем какую-то
                            информацию
                            в конечном итоге, и возвращаем весь обернутый код:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/ContextConsumer.png" alt="ContextConsumer">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="useContext">Хук useContext</h4>

                    <div>
                        <p>При использовании хука useContext, нужно объявить переменную, которой присваивают данный хук,
                            параметром которого, является импортированный context файл:</p>
                        <pre>
import React, {useContext} from "react";
-------------------------------------------
const context = useContext(ContextFile);

context.a = ...
            </pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/useContext.png" alt="useContext">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="dynamicContext">Динамический Context</h4>

                    <div>
                        <p>Чтобы использовать дополнительные параметры в context, в value нужно дополнительно объявить
                            то,
                            что
                            мы хотим передать:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/dynamicContext.png" alt="dynamicContext">
                        </div>
                        <p>А в том месте где нам требуется данные так же нужно применить ранее заданную переменную
                            context:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/applyingDynamicContext.png" alt="applyingDynamicContext">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="customProviderComponent">Кастомный компонент Context Provider</h4>

                    <div>
                        <p>Данный компонент подразумевает, что мы в context файл пишем всю логику, и с помощью
                            useContext
                            потом
                            импортируем ее, а сами компоненты используем для отображения или обработки информации:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/customComponentContext.png" alt="customComponentContext">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="contextRestriction">Ограничения context</h4>

                    <div>
                        <p>React Context НЕ оптимизирован для частых изменений!(например если сотояние меняется с
                            какой-то
                            переодичностью)</p>
                        <p>React Context НЕ СЛЕДУЕТ использовать, как полную замену всех взаимодействий компонентов и
                            props!(короткие цепочки props лучше не заменять)</p>
                    </div>
                </section>

                <section>
                    <h4 id="hookRooles">Правила использования хуков</h4>

                    <div>
                        <ol>
                            <li>Вызывать хуки можно только в функциях React:
                                <ul>
                                    <li>В функциях-Компонентах</li>
                                    <li>В кастомных хуках</li>
                                </ul>
                            </li>
                            <li>Вызывать хуки можно только на верхнем уровне:
                                <ul>
                                    <li>Нельзя вызывать хуки во вложенных функциях</li>
                                    <li>Нельзя вызывать хуки в блоках кода</li>
                                </ul>
                            </li>
                            <li>ВСЕГДА добавляйте все на что вы ссылаетесь внутри useEffect() в зависимости.
                                <a href="#useEffectExamp" class="hrefExampStyle">Пример</a></li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="forwardRefUseImperativeHandle">forwardRef и useImperativeHandle</h4>

                    <div>
                        <p>useImperativeHandle() хук позволяет взаимодействовать с компонентами императивно, не
                            передавая
                            состояния внутрь этих компонентов, меняя что-то в них, при помощи вызова функций внутри</p>
                        <p>useImperativeHandle внутри скобок имеет два аргумента, первый - ref(этот ref используют, если
                            ref
                            этого компонента должны использоваться в другом компоненте),
                            второй - функция, которая возвращает объект с данными, которые мы хотим задействовать в
                            другом
                            компоненте:</p>
                        <p>Для того чтобы сделать ref аргумент доступным в другом компоненте, нам нужно экспортировать
                            этот
                            компонент особенным образом с помощью React.forwardRef((props, ref) => {return (JSX)})</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/useImperativeHandle.png" style="max-width: 500px"
                                 alt="useImperativeHandle">
                        </div>
                        <div class="smallScreenContainer">
                            <img src="./assets/importRef.png" style="max-width: 500px" alt="importedRef">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="howReactWorks">Как работает React</h4>

                    <div>
                        <p>React отвечает за компоненты, за props(данные которые передаются в компоненты), за
                            состояния(state),
                            за контекст(context).</p>
                        <p>ReactDOM же отвечает за отображение HTML элементов на экране(является интерфейсом для
                            WEB)</p>
                        <p>Каждый раз когда меняются props, state или context, происходит переоценка компонента(функция
                            компонент запускаются по новой), в случае если между оценками компонента есть различия,
                            в реальном DOM происходит перерендеринг, НО перерисовка происходит только там, где
                            есть отличия, то что в оценках совпадает - не перерисовывается!</p>
                    </div>
                </section>

                <section>
                    <h4 id="childComponentsEvaluation">Переоценка дочернего компонента</h4>

                    <div>
                        <p>В случае, если происходит переоценка компонента, автоматически будут переоценены все его
                            дочерние
                            компоненты, даже если них ничего не меняется.</p>
                    </div>
                </section>

                <section>
                    <h4 id="ReactMemo">Предотвращение Ненужных Переоценок при Помощи React.memo()</h4>

                    <div>
                        <p>Для функциональных компонентов, для предотвращения ненужных переоценок можно использовать
                            React.memo() при экспорте компонента:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/ReactMemo.png" alt="ReactMemo">
                        </div>
                        <p>Данный метод позволяет исполнять переоценку компонента только в том случае, если были
                            изменения
                            ЕГО
                            props.</p>
                        <p>Использовать React.memo() везде нельзя, тк он заставляет React сравнивать props компонента,
                            тратя
                            на
                            это производительность.</p>
                        <p>Так же, из-за того что, memo сравнивает при помощи "===", то данный метод на прямую работает
                            только к
                            примитивным значениям
                            (числа строки булинг null и тд), в случае с массивами, объектами(ссылочными данными), он не
                            сработает, тк при очередной оценке
                            компонента происходит их пересоздание и пересозданные объекты не ===.</p>
                    </div>
                </section>

                <section>
                    <h4 id="useCallback">Предотвращение Пересоздания Функций при Помощи useCallback()</h4>

                    <div>
                        <p>Хук UseCallback сохраняет указанную функцию в каком-то внутреннем хранилище React и далее
                            будет
                            постоянно использовать одну и ту же функцию при перезапуске функции-компоненте</p>
                        <p>Внутри useCallback помещают нужный к React.memo() код первым аргументом, вторым же аргументом
                            указывают массив с зависимостями(dependencies):</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/useCallback.png" alt="useCallback">
                        </div>
                        <p>Зависимости(deps) служат для того, чтобы в случае изменения какой-то переменной(записанной в
                            зависимостях) хук useCallback сделал перезапись функции и поменял требуемые значения</p>
                        <p>Для useState хука создается переменная при первой инициализации компонента, и может быть
                            пересоздана
                            по новой только в случае удаления компонента из DOM и очереного его добавления. Внутри
                            переменной
                            меняется только значение.</p>
                    </div>
                </section>

                <section>
                    <h4 id="planningState">Обновление состояний и Планирование</h4>

                    <div>
                        <p>В случае, если у нас есть какое-то состояние, и мы меняем его с помощью обновляющей
                            функции(setFunction),
                            то обновление состояния происходит не сразу, сначала происходит планирование обновления
                            состояния!
                            В большинстве случаев запланированное изменение состояния происходит быстро, но React
                            оставляет
                            за
                            собой
                            право отложить изменение состояния, в случае если параллельно идут более приоритетные
                            задачи:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/planningState.png" alt="planningState">
                        </div>
                        <p> React гарантирует, что для одного и того же состояния порядок изменения состояния будет
                            сохранен:</p>
                        <p>Рекомендуется использовать форму обновления состояния при помощи функций, если новое
                            состояние
                            зависит от предыдущего состояния.</p>
                    </div>
                </section>

                <section>
                    <h4 id="classBasedComponents">Компоненты на основе классов</h4>

                    <div>
                        <p>Компоненты на основе классов - устаревший способ создания компонентов. До версии React 16.8
                            компоненты должны были создаваться на основе классов для управления состоянием.</p>
                        <p>При создании компонентов на основе классов, компоненты определяются при помощи классов JS,
                            метод
                            render() определяет то, что отображается на веб странице.</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/classBasedComponents.png" alt="classBasedComponents">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="classBasedComponentStructure">Структура Компонента на Основе Класса</h4>

                    <div>
                        <p>Компоненты на основе класса имеют следующую стандартную структуру:</p>
                        <pre>
import {Component} from "react";

class ComponentName extends Component{

    render () {
        return &lt; JSX /&gt;
    }
}

export default ComponentName;
            </pre>
                        <p>extends Component служит для добавления свойства props, далее это свойство употребляется так:
                            this.props.argument</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/classBasedComponent.png" alt="classBasedComponent">
                        </div>
                        <p>Компоненты на основе классов могут работать в связке с функциональными компонентами в любой
                            наследственной последовательности.</p>

                    </div>
                </section>

                <section>
                    <h4 id="workWithStateInClassBasedComponent">Работа с Состояниями и Событиями в Компонентах на Основе
                        Класса</h4>

                    <div>
                        <p>Для определения состояния в классовых компонентах используют constructor(){}. Внутри
                            конструктора
                            инициализируется состояние this.state = {}.</p>
                        <p>В компонентом на основе классов состояние ВСЕГДА является объектом!!!(В функциональных
                            компонентах
                            состояние может быть чем угодно)</p>
                        <p>Чтобы изменить состояние в неком созданном методе используют this.setState({параметр ВСЕГДА
                            объект!!!}). При использовании setState происходит не изменение
                            состояния, а слияние двух объектов(двух состояний).</p>
                        <pre>
...
constructor() {
    super();
    this.state = {
        someState: value
    }
}

someMethod() {
   this.setState ({
       someState: newValue
   })
}
...
            </pre>
                        <p>Там где нужно получить доступ к состоянию нужно использовать this.state.someState</p>
                        <p>чтобы вызвать нужный метод, нужно использовать this.someMethod.bind(this)</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/classBasedComponentState.png" alt="classBasedComponentState">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="lifeCycleMethods">Жизненный Цикл Компонентов на Основе Классов</h4>

                    <div>
                        <p>Существуют три метода жизненного цикла компонентов, которые выполняли функцию useEffect:</p>
                        <ol>
                            <li>componentDidMount() - вызывается когда компонент был установлен(оценен и отображен).
                                Эквивалент
                                useEffect(... , [пустой])
                            </li>
                            <li>componentDidUpdate() - вызывается когда компонент обновлен(переоценен и переотображен).
                                Эквивалент useEffect(... , [someValue])
                            </li>
                            <li>componentWillUnmount() - вызывается перед тем, как компонент будет удален из DOM.
                                Эквивалент
                                функции очистки в useEffect(() => {return()=>{...}}, [])
                            </li>
                        </ol>
                        <div class="smallScreenContainer">
                            <img src="./assets/lifeCycleMethods.png" alt="lifeCycleMethods">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="classBasedComponentContext">Компоненты на Основе Классов и Контекст</h4>

                    <div>
                        <p>В компонентах на основе классов можно так же определять контекст и далее предоставлять этот
                            контекст
                            при помощи Provider</p>
                        <p>Чтобы использовать контекст есть два метода - оборачивание JSX кода &lt;someContextComponent.Consumer&gt;
                            JSX &lt;someContextComponent.Consumer/&gt;
                            и static contextType = someContextComponent (использовать два контекста нельзя)</p>
                        <p>Использование компонента в компоненте в качестве аргумента - this.context.someContext</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/classBasedComponentContext.png" alt="classBasedComponentContext">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="errorBoundaries">Error Boundaries</h4>

                    <div>
                        <p>В случае если происходит какая-то ошибка, и нужно чтобы приложение не крашилось и ошибку
                            нужно
                            поймать в другом компоненте - используют ErrorBoundary.</p>
                        <p>При использовании конецепции ErrorBoundary, сначала создается компонент на основе класса с
                            соответствующим названием, в котором вызывают
                            метод componentDidCatch(error) {} и метод render(){return this.props.children}</p>
                        <p>Life-Cycle метод componentDidCatch() будет вызываться когда дочерний элемент генерирует
                            ошибку,
                            отлавливать ее и обеспечивая работу приложения.</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/errorBoundaries.png" alt="errorBoundaries">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="connectinWithBD">Соединение с базой данных</h4>

                    <div>
                        <p>React приложение НЕЛЬЗЯ соединять на прямую с базой данных! Т.к. реквизиты для доступа к БД
                            будут
                            не
                            защищенными и доступными в браузере.</p>
                        <p>Доступ к базе данных получается из Back-End приложения:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/BDconnection.png" alt="BDconnection">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="getFetching">Отправка GET запроса</h4>

                    <div>
                        <p>Отправка get запроса осуществляется как с помощью стандартного fetch запроса, так и с помощью
                            других
                            пакетов(например axios).</p>
                        <p>Так же можно пользоваться async/await синтаксисом:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/fetchAsyncAwait.png" alt="fetchAsyncAwait">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="fetchState">Управление загрузкой и состояниями данных</h4>

                    <div>
                        <p>Чтобы управлять загрузкой и состоянием данных дабы пользователь понимал, что приложение не
                            зависло, а
                            ждет ответ от сервера, можно пользоваться переменными с булевыми значениями, которые
                            помещаются
                            до
                            получения запроса и после, и далее используются где-то в UI в качестве индикаторов
                            загрузки:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/fetchState.png" alt="fetchState">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="reactRouteTryCatch">Обработка HTTP Ошибок</h4>

                    <div>
                        <p>Для того чтобы выводить ошибки запросов в UI, необходимо обернуть код в try/catch блок, при
                            помощи
                            значения response.ok(true/false), в случае если response.ok = false генерировать ошибку,
                            которая
                            далеее
                            будет обрабатываться в catch блоке, обновляя дополнительное состояние параметром
                            error.message:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/reactTryCatch.png" alt="reactTryCatch">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="reactRouteUseEffectForFetch">Использование useEffect для Запросов</h4>

                    <div>
                        <p>Для того чтобы загружать данные с сервера каждый раз когда загружается компонент, нужно
                            использовать
                            useEffect и в зависимостях указать саму функцию, дабы не происходило зацикливание загрузки,
                            useEffect
                            используется всегда, если загрузка данных
                            происходит не по клику пользователя. Так же функцию с fetch запросом оборачивают в
                            useCallback
                            дабы
                            не
                            происходило изменение этой функции при обновлении компонента, в deps же указывают внешние
                            зависимости в случае если таковые существуют.</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/fetchUseEffectUseCallback.png" alt="fetchUseEffectUseCallback">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="postFetching">Отправка Запроса POST</h4>

                    <div>
                        <p>Для того чтобы в React приложении делать POST запросы/отправку данных - используется
                            стандартный
                            синтаксис JavaScript:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/reactPOSTfetch.png" alt="reactPOSTfetch">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="customReactRouteHook">Создание Функции Custom React Hook</h4>

                    <div>
                        <p>Как и обычные компоненты, кастомные хуки помещаются в отдельную папку. Имя кастомной функции
                            обязательно
                            должно начинаться со слова "use". В каждом компоненте в котором будет вызываться кастомный
                            хук,
                            будет
                            создаваться собственное состояние. В кастомных хуках можно возвращать что угодно и далее
                            использовать
                            это присваивая переменной при вызове кастомного хука:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/creationCustomHooks.png" alt="creationCustomHooks">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="customHooksParams">Конфигурация Custom Hooks</h4>

                    <div>
                        <p>Функции можно сделать конфигурируемыми при помощи передачи функциям параметров:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/customHooksParams.png" alt="customHooksParams">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="workingWithReactRouteForm">Работа с вводом данных из форм</h4>

                    <div>
                        <p>Валидацию формы можно проводить:</p>
                        <ol>
                            <li>Когда форма отправлена.
                                <ul>
                                    <li>Позволяет пользователю ввести валидное значение перед тем, как выводить в
                                        интерфейс
                                        предупреждение для него.
                                    </li>
                                    <li>Позволяет избежать показа лишних предупреждений, но предоставляет пользователю
                                        фидбэк
                                        слишком поздно.
                                    </li>
                                </ul>
                            </li>
                            <li>Когда инпут теряет фокус
                                <ul>
                                    <li>Позволяет пользователю ввести валидное значение перед тем, как выводить в
                                        интерфейс
                                        предупреждение для него.
                                    </li>
                                    <li>Полезно использовать для формы, которой не коснулись</li>
                                </ul>
                            </li>
                            <li>При каждом нажатии клавиши
                                <ul>
                                    <li>Предупреждает пользователя не давая возможности ввести валидное значение.</li>
                                    <li>Предоставляет пользователю конкретный фидбэк, если использовать для невалидного
                                        ввода.
                                    </li>
                                </ul>
                            </li>
                        </ol>
                        <p>Если значение из форм нужно однажды, когда форма отправлена, то, тогда как правило используют
                            useRef
                            хук.</p>
                        <p>Если нужно значение инпута обновленное после каждого ввода для мгновенной валидации, тогда
                            используют
                            хук
                            useState. Так же useState используют, когда хотят очистить инпут после нажатия кнопки
                            отправки
                            формы.</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/formUseRefState.png" alt="formUseRefState">
                        </div>
                    </div>
                </section>
            </section>

            <section id="reactReduxNav">
                <h3 id="reduxAPI">Библиотека Redux</h3>

                <section>
                    <h4 id="commonInfoReactRedux">Общая информация о React Redux</h4>

                    <div>
                        <p>Redux это система управления состояниями: состояниями для нескольких компонентов и состоянием
                            уровня
                            приложения.</p>
                        <p>Состояния бывают трех видов:</p>
                        <ol>
                            <li>Локальные состояния</li>
                            <li>Состояние для нескольких компонентов</li>
                            <li>Состояние уровня приложения</li>
                        </ol>
                        <p>Локальные состояния это состояния которые принадлежат одному компоненту(например состояние
                            ввода
                            данных
                            пользователем). Такие состояния должны управляться внутри компонента при помощи useState или
                            useReducer</p>
                        <p>Состояние для нескольких компонентов(кросс компонентное состояние) это состояние влияющее на
                            несколько
                            компонентов(например состояние видимости модального окна). Такое состояние так же может
                            управляться
                            при
                            помощи useState и useReducer, но уже требуются цепочки props(props drilling)</p>
                        <p>Состояние уровня приложения это состояние влияющее на все(или почти все) компоненты(например
                            статус
                            аутентификации пользователя). Так же может управляться при помощи useState и useReducer и
                            так же
                            требуются цепочки props</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/reactAppState.png" alt="reactAppState">
                        </div>
                        <p>Redux решает проблему длинных цепочек props(так же как и useContext)</p>
                    </div>
                </section>

                <section>
                    <h4 id="reduxVSReactContext">Redux VS React Context</h4>

                    <div>
                        <p>React Context имеет потенциальные проблемы в использовании, и в таком случае нужно
                            использовать
                            Redux
                            библиотеку, если же таких проблем не возникает можно использовать как и React Context так и
                            Redux, и
                            даже оба этих подхода в разных местах одного приложения.</p>
                        <p>Недостатки React Context:</p>
                        <ul>
                            <li>Сложность создания/управления состояниями. В больших приложениях использование React
                                Context
                                может
                                привести к глубокой вложенности JSX кода или к "раздуванию" компонентов Context
                                Provider.
                            </li>
                            <li>Потеря производительности приложения. React Context не оптимизирован для часто
                                меняющихся
                                состояний
                            </li>
                        </ul>
                    </div>
                </section>

                <section>
                    <h4 id="reduxBasics">Как работает Redux</h4>

                    <div>
                        <p>Концепция Redux состоит в том, чтобы использовать одно центральное хранилище
                            данных(состояний) в
                            приложении. Все состояния со всех компонентов приложения сохраняются в этом хранилище. Чтобы
                            компонент
                            имел доступ к состоянию в хранилище, создается т.н. подписка на центральное хранилище
                            данных.</p>
                        <p>Компоненты НИКОГДА не манипулируют данными в хранилище! Для этого используется функция
                            Reducer(Функция
                            Reducer - это общая концепция, не путать с useReducer хуком!). Компоненты отправляют
                            actions(простые
                            JS
                            объекты, которые описывают тип операций), далее Redux переадреcсовывает эти actions в
                            функцию
                            Reducer,
                            считываются желаемые операции описанные в actions, после чего они выполняются в функции
                            Reducer,
                            создается новое состояние, которое заменяет старое состояние хранимое в центральном
                            хранилище
                            данных
                            и
                            далее хранилище уведомляет подписанные компоненты об изменении состояния.</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/reduxBasics.png" alt="reduxBasics">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="reduxStoreCreation">Создание хранилища</h4>

                    <div>
                        <p>Для того чтобы работать с Redux, требуется установить с помощью npm install в командной
                            строке
                            "redux" и "react-redux".</p>
                        <p>Далее создается файл в котором создают хранилище с помощью "redux.legacy_createStore()" и
                            функцию
                            Reducer, функции redux.legacy_createStore() в качестве параметра передают функцию
                            Reducer:</p>
                        <p>Так же через action можно передать дополнительные свойства, которые далее будут вызываться в
                            функции
                            диспетчере</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/reduxStoreCreation.png" alt="reduxStoreCreation">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="reduxStoreProviding">Предоставление хранилище всему React приложению</h4>

                    <div>
                        <p>Для того чтобы предоставить хранилище всему React приложению, в index.js файле (где
                            отображается
                            корневой
                            компонент приложения) нужно импортировать {Provider} из "react-redux" и обернуть им корневой
                            "App"
                            компонент, так же в Provider в атрибуте "store" нужно указать созданное хранилище.</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/reduxStoreProviding.png" alt="reduxStoreProviding">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="useSelector">Использование Данных Redux в React Компонентах</h4>

                    <div>
                        <p>Для того чтобы получать данные о состоянии из хранилища, в React компоненте нужно
                            импортировать
                            либо
                            кастомный хук useSelector, который подписывает компонент на определенное состояние, либо хук
                            useStore,
                            который дает непосредственный доступ ко всему хранилищу.</p>
                        <p>При вызове кастомного хука в параметрах нужно передать функцию, которая будет определять
                            какую
                            часть
                            данных нужно извлечь из хранилища.</p>
                        <pre>
import {useSelector} from "react-redux";

const someComponent = () => {
   const someVar = useSelector((state) => state.stateName)
   ......................................................
}
            </pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/useSelector.png" alt="useSelector">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="useDispatch">Отправка actions</h4>

                    <div>
                        <p>Для отправки actions используется хук useDispatch. При вызове хука useDispatch, его нужно
                            присвоить
                            переменной и так же не требуется передача параметров. Созданной переменной присваевается
                            функция
                            диспетчер, которой в параметрах нужно передать объект {type: 'actionName'} и допольнительные
                            свойства actions если такие были определены в хранилище(как number в примере):</p>
                        <pre>
import {useDispatch} from "react-redux";

const someComponent = () => {
   const someDispatchFunction = useDispatch();
}

someDispatchFunction({
   type: 'actionName'
})
                        </pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/useDispatch.png" alt="useDispatch">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="reactReduxInClassBasedComponents">Redux в Классовых Компонентах</h4>

                    <div>
                        <p>Для того чтобы в классовых компонентах использовать хранилище состояний, нужно импортировать
                            функцию
                            {connect} из "react-redux". При экспорте классового компонента, нужно перед классом дописать
                            "connect()"
                            а сам классовый компонент передать в качестве параметра во вторую функцию, которую
                            возвращает
                            connect, в
                            первую же функцию нужно передать в качестве параметров две функции - mapStateToProps и
                            mapDispatchToProps, первая из которых, возвращает объект содержащий ссылку на состояния, а
                            второй
                            объект
                            содержащий типы actions</p>
                        <pre>
import {connect} from "react-redux";

class someClassComponent extends Component {
   someHandler() {
      this.props.someFunction();
   }

   render() {
      return (
         &lt;div&gt;
            &lt;div&gt;{this.props.someStateName}&lt;/div&gt;
            &lt;button onClick={this.someHandler.bind(this)}&gt;press&lt;/button&gt;)
         &lt;/div&gt;
   }
}

const mapStateToProps = (state) => {
   return {
      someState: state.someStateName
   }
}

const mapDispatchToProps = (dispatch) => {
   return {
      someFunction: () => dispatch({type: 'increment'}),
   }
}

export default connect(mapStateToProps, mapDispatchToProps)(someClassComponent);
            </pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/classBasedComponentWithRedux.png" alt="classBasedComponentWithRedux">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="workingWithSeveralStates">Работа с Несколькими Свойствами Состояний</h4>

                    <div>
                        <p>Чтобы управлять несколькими состояниями в одном хранилище, в качестве параметра функции
                            Reducer
                            нужно
                            передать в объекте через запятую другие состояния, и так же if блоком определять для них тип
                            action,
                            тк
                            объект переданный в параметр функции Reducer становится больше, его лучше вынести в
                            переменную.
                            Так
                            же
                            эти состояния нужно дублировать с дефолтными значениями в каждый action. Чтобы изменять
                            дополнительное
                            состояние, к нему применяется тот же подход:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/workingWithSeveralStates.png" alt="workingWithSeveralStates">
                        </div>
                        <div class="smallScreenContainer">
                            <img src="./assets/changingAdditionalState.png" alt="changingAdditionalState">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="reduxRules">Правилa Работы с Redux Состоянием</h4>

                    <div>
                        <p>Всегда нужно возвращать новый объект состояния, насколько бы сложен объект ни был, так же
                            нужно
                            возвращать
                            все состояния объекта даже если их значения не меняются, просто нужно сделать отссылку к
                            старому
                            состоянию!</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/reduxRules.png" alt="reduxRules">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="reduxToolkit">Redux Toolkit</h4>

                    <div>
                        <p>В случае если функция Reducer сильно раздувается состояниями и action, упростить работу с
                            состояниями
                            поможет библиотека Redux Toolkit</p>
                        <p>Установив Redux Toolkit в командной строке в папку с проектом с помощью команды "npm install
                            @reduxjs/toolkit", открывается доступ к функции createSlice. Импортировав ее в файл можно
                            комфортно
                            конфигурировать состояния следующим синтаксисом:</p>
                        <pre>
import {createSlice} from "@reduxjs/toolkit";

const someStateVar = createSlice({
    name: "someStateName",
    initialState: someInitialState,
    reducers:{
        someFunctionName(state, action){
            state.someInitialState +-/* action.payload
        }
   }
})
            </pre>
                        <p>Далее нужно импортировать configureStore в файл для того, чтобы произвести экспорт reducers
                            функций:</p>

                        <pre>
import {createSlice, configureStore} from "@reduxjs/toolkit";

const store = configureStore({
    reducer: {
        someReducerName: someStateVar.reducer
    }
})

export default store;
            </pre>
                        <p>Так же нужно произвести экспорт actions следующим синтаксисом:</p>
                        <pre>export const someStateActions = someStateVar.actions;</pre>
                        <p>Чтобы воспользоваться состояниями созданными createSlice, импортируем старым способом store и
                            переменную
                            с actions в нужный файл и в dispatch функции вызываем функции редьюсеры через созданную
                            переменную с
                            actions,
                            если же ранее в функции редьюсере была указана actions то в качестве параметра можно указать
                            требуемое значение:</p>

                        <pre>dispatchFunction(someStateActions.someFunctionName(any))</pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/createSlice.png" alt="createSlice">
                        </div>

                        <div class="smallScreenContainer">
                            <img src="./assets/createdSliceReducerUsage.png" alt="createdSliceReducerUsage">
                        </div>
                        <p>Пример использования нескольких слайсов:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/severalSlicesUsage1.png" alt="severalSlicesUsage1">
                        </div>
                        <div class="smallScreenContainer">
                            <img src="./assets/severalSlicesUsage2.png" alt="severalSlicesUsage2">
                        </div>
                        <p>В случае если слайсов много, их можно вынести в отдельные файлы и импортировать в
                            хранилище:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/dividinSlices.png" alt="dividinSlices">
                        </div>
                        <div class="smallScreenContainer">
                            <img src="./assets/optimisedStore.png" alt="optimisedStore">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="reduxUseEffect">Работа с Побочными Эффектами в Redux</h4>

                    <div>
                        <p><strong>Reducers должны быть чистыми синхронными функциями без побочных эффектов!!!</strong>
                        </p>
                        <div class="smallScreenContainer">
                            <img src="./assets/reduxUseEffect.png" alt="reduxUseEffect">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="frontendvsBackend">Frontend vs Backend</h4>

                    <div>
                        <p>Существует два варианта взаимодействия frontEnd и backEnd:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/frontendvsBackend.png" alt="frontendvsBackend">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="logicPlace">Где размещать логику?</h4>

                    <div>
                        <p>Размещение логики приложения зависит от следующих факторов:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/logicPlace.png" alt="logicPlace">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="actionCreatorSlice">Запись и извлечение данных с сервера</h4>

                    <div>
                        <p>Для записи данных на сервер используют useEffect внутри которого помещают fetch запрос. В
                            случае
                            если
                            нужно постоянно перезаписывать данные на сервере, при каких-то манипуляциях данными
                            пользователем -
                            используют PUT метод:</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/fetchInRedux.png" alt="fetchInRedux">
                        </div>
                        <p>Так же возможно использование action creator thunk. Thunk - это функция откладывающая action.
                            Action
                            creator возвращает не action, а функцию которая уже возвратит функцию. Данный метод имеет
                            следующий
                            синтаксис - в слайс файле создается кастомный action который возвращает асинхронную функцию
                            с
                            параметром
                            "dispatchAction", далее вызывают dispatchAction и в ее параметры указывают нужный(ые)
                            action,
                            создают через константу
                            асинхронную функцию в которую вкладывают fetch запрос и в try/catch блоке вызывают эту
                            функцию,
                            далее всю эту
                            конструкцию вызывают в useEffect при помощи useDispatch:</p>
                        <p>Пример отправки данных на сервер:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/actionCreatorSlice.png" alt="actionCreatorSlice">
                        </div>
                        <p>Пример запроса данных с сервера:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/reduxGetFetch.png" alt="reduxGetFetch">
                        </div>
                        <p>Вызов функций с помощью useEffect:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/useEffectInRedux.png" alt="useEffectInRedux">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="createAsyncThunk">createAsyncThunk в Redux Toolkit</h4>

                    <div>
                        <p>По своей сути createAsyncThunk это тот же action creator thunk только в оболочке Redux
                            Toolkit,
                            его
                            синтаксис выглядит следующим образом:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/createAsyncThunk.png" alt="createAsyncThunk">
                        </div>
                        <p>С помощью createAsyncThunk (перед createSlice) мы конфигурируем запрос на сервер, далее в
                            слайсе
                            после
                            Reducers мы конфигурируем extraReducers с аргументом (bilder) и метода addCase мы
                            обрабатываем
                            наш
                            запрос в трех
                            состояниях- pending, fulfilled, rejected, показывая начало загрузки данных, получения и
                            обработки
                            данных
                            и вывод сообщения об ошибке соответственно:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/extraReducer.png" alt="extraReducer">
                        </div>
                        <p>В первом аргументе (типе) "typePrefix" мы указываем имя слайса, и через слеш наше
                            название-индикатор
                            при помощи которого, в DevTools мы будем проводить дебаг приложения.</p>
                    </div>
                </section>

                <section>
                    <h4 id="thunkApi">ThunkApi в Redux Toolkit</h4>

                    <div>
                        <p>В блоке аргументов createAsyncThunk мы можем использовать ThunkApi для дополнительной
                            конфигурации
                            запроса, данный аргумент обладает следующими методами:</p>
                        <ul>
                            <li>dispatch: the Redux store dispatch method(Позволяет вызвать метод из Reducers)</li>
                            <li>getState: the Redux store getState method(Позволяет получить состояние нужной
                                переменной)
                            </li>
                            <li>extra: the "extra argument" given to the thunk middleware on setup, if available</li>
                            <li>requestId: a unique string ID value that was automatically generated to identify this
                                request
                                sequence(Позволяет получить айди запроса)
                            </li>
                            <li>signal: an AbortController.signal object that may be used to see if another part of the
                                app
                                logic has marked this request as needing cancelation(Позволяет отменить запрос, например
                                в
                                случае
                                долгого выполнения).
                            </li>
                            <li>rejectWithValue(value, [meta]): rejectWithValue is a utility function that you can
                                return
                                (or
                                throw) in your action creator to return a rejected response with a defined payload and
                                meta.
                                It
                                will
                                pass whatever value you give it and return it in the payload of the rejected action. If
                                you
                                also
                                pass
                                in a meta, it will be merged with the existing rejectedAction.meta(Позволяет сделать
                                реджект
                                в
                                случае
                                если полученные данные нас не устраивают, например пришел пустой массив значит мы делаем
                                реджект).
                            </li>
                            <li>fulfillWithValue(value, meta): fulfillWithValue is a utility function that you can
                                return in
                                your action creator to fulfill with a value while having the ability of adding to
                                fulfilledAction.meta.(Можно использовать в случае если к полученной информации нужно
                                добавить
                                какую-то другую информацию)
                            </li>
                        </ul>

                        <p>Пример конфигурации параметров запроса при помощи getState:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/getState.png" alt="getState">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="reduxDevTools">Redux DevTools</h4>

                    <div>
                        <p>При помощи Redux DevTools производится отладка приложения использующего Redux.</p>
                        <p><a href="https://github.com/reduxjs/redux-devtools" target="_blank">Гайд по использованию
                            Redux
                            DevTools</a></p>
                    </div>
                </section>
            </section>

            <section id="reactRouterBNav">
                <h3 id="reactRouterBasics">React Router</h3>

                <section>
                    <h4 id="commonInfoReactRouter">Что такое маршрутизация?(Routing)</h4>

                    <div>
                        <p>Особенностью React приложения является единый url который всегда направляет пользователя на
                            домашнюю/стартовую страницу.</p>
                        <p>Для создания различных эндпоинтов с разным отображаемым контентом url обрабатывается React на
                            стороне
                            клиента, таким образом происходит получение другого контента без загрузки нового HTML
                            файла</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/basicsReactRouter.png" alt="basicsReactRouter">
                        </div>
                        <p>Подробную информацию можно найти на <a href="https://reactrouter.com/en/main"
                                                                  target="_blank">официальном
                            сайте разработчиков React Router</a></p>
                        <p>Чтобы работать с React Router в консоли в папку с проектом нужно ввести "npm install
                            react-router-dom(@5 если нужна 5тая версия)"</p>
                    </div>
                </section>

                <section>
                    <h4 id="urlInfo">Что такое URL?</h4>

                    <div>
                        <div class="smallScreenContainer">
                            <img src="./assets/urlIno.png" alt="urlIno">
                        </div>
                        <p>В случае если в троке запросов несколько параметров, они разделяются знаком амперсанда
                            (&).</p>
                        <p>У корневого домена могут быть под домены</p>
                    </div>
                </section>

                <section class="httpMethodsSection">
                    <h4 id="httpMethods">Методы HTTP запросов</h4>

                    <div>
                        <p><a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/GET" target="_blank">GET</a>
                            —
                            запрашивает контент из сервера. Поэтому у запросов с методом GET нет тела сообщения. Но при
                            необходимости можно отправить параметры через path.</p>
                        <p><a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/POST"
                              target="_blank">POST</a> —
                            публикует информацию на
                            сервере. POST-запрос может передавать разную информацию: параметры в формате ключ=значение,
                            JSON,
                            HTML-код или даже файлы. Вся информация передается в теле сообщения.</p>
                        <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD"
                              target="_blank">HEAD</a>
                            —
                            запрашивает ресурс так же, как и метод GET, но без тела ответа.</p>
                        <p><a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/PUT" target="_blank">PUT</a>
                            —
                            заменяет
                            все текущие представления ресурса данными запроса.</p>
                        <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE"
                              target="_blank">DELETE</a>
                            —
                            удаляет указанный ресурс.</p>
                        <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT"
                              target="_blank">CONNECT</a> —
                            устанавливает "туннель" к серверу, определённому по ресурсу.</p>
                        <p><a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/OPTIONS"
                              target="_blank">OPTIONS</a>
                            —
                            используется для описания параметров соединения с ресурсом.</p>
                        <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE"
                              target="_blank">TRACE</a> —
                            выполняет вызов возвращаемого тестового сообщения с ресурса.</p>
                        <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH"
                              target="_blank">PATCH</a> —
                            используется для частичного изменения ресурса.</p>
                    </div>
                </section>

                <section>
                    <h4 id="reactRouter">Работа с React Router v5</h4>

                    <div>
                        <p>Компоненты учавствующие в маршрутизации по конвенции лучше помешать не в components папку, а
                            другую,
                            например pages.</p>
                        <p>Для того чтобы установить маршрутизацию, в корневой файл (например App.js) импортируют
                            компонент
                            {Router} из "react-router-dom", далее в return блоке помещают Router компонент с props
                            "/someUrlName"
                            где "someUrlName" это предполагаемый энд-поинт который будет выводить пользователя на
                            компонент
                            который разработчик поместит между: </p>>
                        <pre>&lt;Router&gt;&lt;Some Component/&gt;&lt;/Router&gt;</pre>
                        <p>Далее требуется в index.js импортировать компонент {BrowserRouter} из "react-router-dom" и
                            обернуть им App
                            компонент:</p>
                        <pre>
import {Router} from "react-router-dom";

function App() {
    return &lt;div&gt;
       &lt;Route path="/linkToSomeComponent1"&gt;
           &lt;someComponent1/&gt;
       &lt;/Route&gt;
       &lt;s path="/linkToSomeComponent2"&gt;
           &lt;someComponent2/&gt;
       &lt;/Route&gt;
    &lt;/div&gt;

----------------------------------------
import {BrowserRouter} from "react-router-dom";
...
root.render(&lt;BrowserRouter&gt;&lt;App/&gt;&lt;/BrowserRouter&gt;);
            </pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/reactRouterBasics.png" alt="reactRouterBasics">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="linkInRouterApp">Работа со Ссылками</h4>

                    <div>
                        <p>Для того чтобы создать иллюзию перехода по ссылкам в файл, где будет имитация ссылок нужно
                            импортировать
                            компонент Link и создать "ссылку" в нужном месте указав в props "to" ту ссылку, которая
                            ведет на
                            компонент в
                            Router:</p>
                        <pre>
import {Link} from "react-router-dom";
...
&lt;Link to="/linkToSomeComponent1(2)"&gt;someComponent1(2)&lt;/Link&gt;
                        </pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/linkInRouterApp.png" alt="linkInRouterApp">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="navLinkComponent">Компонент NavLink</h4>

                    <div>
                        <p>Для того чтобы в панели навигации выделять ту "ссылку" на странице которой находится
                            пользователь
                            в
                            текущий момент, вместо Link компонента используют NavLink компонент, в props activeClassName
                            указывают
                            нужный стиль для смены стиля:</p>
                        <pre>
import {NavLink} from "react-router-dom";
...
&lt;NavLink activeClassName={styles.active} to="/linkToSomeComponent1(2)"&gt;someComponent1(2)&lt;/NavLink&gt;
            </pre>
                        <div class="smallScreenContainer">
                            <img src="./assets/navLinkInReactRouterApp.png" alt="navLinkInReactRouterApp">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="dynamicRouter">Добавление Динамических Маршрутов с Параметрами</h4>

                    <div>
                        <p>В случае, если требуется отобразить страницу динамически, в конце ссылки props path добавляют
                            дополнительную часть "/:anyURL", где "anyURL" является обрабатываемым параметром:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/dynamicRouter.png" style="max-width: 500px" alt="dynamicRouter">
                        </div>
                        <p>Для того чтобы извлечь динамические параметры из "anyURL", в требуемый файл нужно
                            импортировать
                            кастомный
                            хук "useParams":</p>
                        <pre>
import {useParams} from "react-router-dom";
...
const params = useParams();
            </pre>
                        <p>В итоге params.anyURL будет в себе содержать ту часть URL которую ввели в адресной строке
                            после
                            основного адреса,
                            именно по ней можно динамически отображать информацию в компоненте на прямую либо при помощи
                            запроса
                            на сервер.</p>
                    </div>
                </section>

                <section>
                    <h4 id="switchComponent">Использование компонента Switch</h4>

                    <div>
                        <p>Т.к. при переходе по "ссылкам" из-за особенностей поведения React Router происходит
                            совмещение
                            компонентов на одной странице, в случае если требуется отобразить один компонент, используют
                            кастомный
                            компонент {Switch}, которым оборачивают все Route. При таком подходе будет отображено только
                            один
                            компонент, НО в случае когда части url совпадают,
                            будет отражен первый компонент в списке и для того, чтобы исключить такое поведение в Route
                            используют props "exact", либо перемещают Route с более коротким url ниже по списку:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/switchComponentReactRouter.png" style="max-width: 500px"
                                 alt="switchComponentReactRouter">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="inneredRouters">Вложенные Маршруты, Перенаправление и Предупреждение Пользователя и Работа с
                        Параметрами Запроса</h4>

                    <div>
                        <p>Вложенные маршруты создаются при помощи компонента Route в том компоненте где нам нужно
                            отобразить
                            дополнительную информацию при дописывании дополнительной части ссылки. При использовании
                            данной
                            фичи
                            требуется соблюдать соответсвие начальных частей ссылок:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/inneredRouters.png" style="max-width: 500px" alt="inneredRouters">
                        </div>
                        <p>В случае если с доменного имени без дополнительных эндпоинтов требуется перенаправлять
                            пользователя на какой-то компонент(стартовую страницу например), можно импортировать
                            компонент
                            {Redirect} в props "to" которого мы указываем ссылку на требуемый компонент. Так же
                            компонент
                            Redirect оборачивается Route с props "path='/'" и props exact:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/redirectReactRouter.png" style="max-width: 500px"
                                 alt="redirectReactRouter">
                        </div>
                        <p>В случае если требуется обработать невалидный ввод url после доменного имени, например
                            требуется
                            вывести
                            в UI "Страница не найдена", создается компонент с соответствующим предупреждением и
                            компонентом
                            Route
                            оборачиваем его в конце всего списка Route, так же в props path требуется указать "*":</p>
                        <pre>
...
&lt;Route path='*'&gt;
   &lt;PageNotFoundComponent&gt;
&lt;/Route&gt;
            </pre>
                        <p>В случае, если требуется после завершения работы какой-то функции(отправка формы на сервер
                            например)
                            перенаправить пользователя на другую страницу - применяется хук useHistory(). Создается
                            переменная,
                            которой присваивается вызов хука useHistory() и далее эта переменная вызывается с методом
                            push()
                            либо
                            replace() в параметрах которых указывают требуемый путь после доменного имени. Push и
                            Replace в
                            данном
                            случае отличаются тем, что в случае push кнопкой возврата будет переход на предыдущую
                            страницу,
                            а
                            вслучае replace - нет:</p>
                        <pre>
import {useHistory} from "react-router-dom";
...
history.push('/someLink');
// или
history.replace('/someLink');
            </pre>
                        <p>В случае если требуется предупреждать пользователя, когда он заполняет например форму и
                            случайно
                            жмет
                            кнопки перехода на другую страницу, можно использовать кастомный компонент {Prompt}. Данный
                            компонент
                            имеет два props - when и message, где when принимает в параметры boolean значения, которые
                            меняет
                            пользователь своими действиями, а message - функцию с параметром (location), которая
                            возвращает
                            текст предупреждения: </p>
                        <pre>
&lt;Prompt
    when={booleanValue}
    message={(location) => {
        return 'Вы точно хотите покинуть страницу? Данные в форме в случае перехода будут потеряны!'
    }}
/&gt;
            </pre>
                        <p>Для работы с параметрами запроса используют хук useLocation:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/useLocation.png" alt="useLocation">
                        </div>
                        <p>Для гибкого кода маршрутизации используют хук useRouteMatch. Переменной присваивают вызов
                            хука
                            useRouteMatch() и далее эту переменную с ".path" присваивают в path нужного Route. Таким же
                            образом
                            можно воспользоваться useLocation с атрибутом ".pathname". Так же в props компонента Link
                            можно
                            использовать данную переменную, но уже с ".url". Данный способ позволяет настроить путь
                            динамически.</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/useRouteMatch.png" alt="useRouteMatch">
                        </div>
                    </div>
                </section>
            </section>

            <section id="RTQQueryNav">
                <h3 id="RTQQueryBasics">RTK Query</h3>

                <section>
                    <h4 id="commonInfoRTQQuery">Основной функционал Redux Toolkit Query(RTK Query)</h4>

                    <div>
                        <p>Подробно можно почитать на <a href="https://redux-toolkit.js.org/tutorials/rtk-query">
                            Redux Toolkit Портале</a></p>

                        <p>RTK Query дефолтно включена в Redux Toolkit, скачивать дополнительно ничего не нужно. Эту
                            библиотеку
                            можно использовать вне реакта.</p>

                        <p>Сначала мы создаем Api файл где мы с помощью метода createApi создаем объект генерирующий
                            хуки,
                            при
                            помощи которых мы можем делать либо прямой запрос по требованию, либо запрашивать данные
                            сразу
                            при
                            монтировании компонента автоматически: </p>

                        <p>
                            <a href="https://github.com/Slipbang/albion-calculator-app-v1/blob/master/src/store/api/api.ts"
                               target="_blank">Гитхаб файл api.ts</a></p>

                        <pre>
import {createApi, fetchBaseQuery} from '@reduxjs/toolkit/query/react';

const baseUrl = 'https://albion-profit-calculator.com/api';

export interface IQueryTransportationParams{
    ...
}

export interface IQueryItemsParams {
    ...
}

export const albionApi = createApi({
    reducerPath: 'albion/api',
    baseQuery: fetchBaseQuery({
        baseUrl,
    }),
    endpoints: build => ({
        getTransportationsData: build.query&lt;TransportationData[], IQueryTransportationParams&gt;({
            query: ({from, to, count, skip, profitSort, checkSort, serverId}) => ({
                url: `transportations/sort?from=${from}&to=${to}&count=${count}&skip=${skip}&sort=${checkSort}${profitSort}&serverId=${serverId}`,
            }),
        }),
        getItemsData: build.query&lt;IItemsData[], IQueryItemsParams&gt;({
            query: ({itemsParams, isBlackMarket, serverId}) => ({
                url: `data?items=${itemsParams}&locations=${!!isBlackMarket ? 'Black%20Market,' : ''}Thetford,Bridgewatch,Lymhurst,Caerleon,Martlock,Fort%20Sterling,Brecilien&serverId=${serverId}`,
            })
        }),
    })
})

export const { useGetTransportationsDataQuery, useLazyGetItemsDataQuery, useGetItemsDataQuery} = albionApi;
            </pre>

                        <p>Где useGetTransportationsDataQuery - это хук с мгновенным срабатыванием при монтировании
                            компонента,
                            а
                            useLazyGetItemsDataQuery хук, который нужно вызывать в коде с помощью предоставленного им
                            метода
                            после
                            его декларации.</p>
                        <p>Далее к store надо подключить созданную api:</p>

                        <p><a href="https://github.com/Slipbang/albion-calculator-app-v1/blob/master/src/store/index.ts"
                              target="_blank">Гитхаб файл store.ts</a></p>

                        <pre>
import {combineReducers, configureStore} from "@reduxjs/toolkit";
//...остальные импорты

const rootReducer = combineReducers({
    ...
    [albionApi.reducerPath]: albionApi.reducer,
})

export const store = configureStore({
    reducer: rootReducer,
    middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(albionApi.middleware)
})

setupListeners(store.dispatch); // для refetchOnFocus(true/false) свойства в конфигурирующем объекте
            </pre>

                        <p>Далее в нужных компонентах мы вызываем требуемый нам хук и передаем в него параметры:</p>

                        <p>
                            <a href="https://github.com/Slipbang/albion-calculator-app-v1/blob/master/src/components/Transportation/TransportationTable/TransportationTable.tsx"
                               target="_blank">Гитхаб файл TransportationTable.tsx</a></p>
                        <p>
                            <a href="https://github.com/Slipbang/albion-calculator-app-v1/blob/master/src/components/Calculator/DefaultCalculator/InfoTable/InfoTable.tsx">Гитхаб
                                файл InfoTable.tsx</a></p>

                        <pre>
дефолтный хук:
import {useGetTransportationsDataQuery} from "../../../store/api/api";
//... остальные импорты

const TransportationTable = () => {
    ...

    const queryParams = useSelector(selectTransportationQueryParams);

    const {
        isFetching,
        isError,
        data,
    } = useGetTransportationsDataQuery({...queryParams}, {
        refetchOnReconnect: true,
    });

    ...
}

---------------------------------------------------------------------------
ленивый хук:

import {srcRoute, useLazyGetItemsDataQuery} from "../../../../store/api/api";
//... остальные импорты

const InfoTable = ({calculatorType}: {calculatorType: TCalcProps}) => {
    ...

    const [fetchItems, {
        isFetching: isItemFetching,
        isError: isErrorItems,
        data: itemsData,
    }] = useLazyGetItemsDataQuery();

    ...

    useEffect(() => {
        if (calculatorType === 'ITEMS') {
            fetchItems({itemsParams: queryItemsParams!, isBlackMarket: true, serverId});

            ...
        }

        ...
    }, [queryItemsParams, queryMatsParams!, queryJournalsParams, artefactId, serverId, itemId])
            </pre>

                        <p>Из самих хуков можно деструктурировать isFetching, isLoading, isError, error, data и фетч
                            функцию
                            в
                            случае Lazy хуков и хуков с мутациями</p>

                        <p>В случае если нам требуется отправить данные на бэкэнд/удалить с бэкэнда и тут же их обновить
                            в
                            приложении, то нужно использовать build.mutation в endpoints:</p>

                        <p><a href="https://github.com/michey85/rtk-query-example/blob/rtk/src/redux/goodsApi.js">Гитхаб
                            файл
                            goodsApi.js</a></p>
                        <pre>
import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

export const goodsApi = createApi({
    reducerPath: 'goodsApi',
    tagTypes: ['Products'],
    baseQuery: fetchBaseQuery({baseUrl: 'http://localhost:3001/'}),
    endpoints: (build) => ({
        getGoods: build.query({
            query: (limit = '') => `goods?${limit && `_limit=${limit}`}`,
            providesTags: (result) => result
              ? [
                  ...result.map(({ id }) => ({ type: 'Products', id })),
                  { type: 'Products', id: 'LIST' },
                ]
              : [{ type: 'Products', id: 'LIST' }],
        }),
        addProduct: build.mutation({
            query: (body) => ({
                url: 'goods',
                method: 'POST',
                body,
            }),
            invalidatesTags: [{type: 'Products', id: 'LIST'}]
        }),
        deleteProduct: build.mutation({
            query: (id) => ({
                url: `goods/${id}`,
                method: 'DELETE',
            }),
            invalidatesTags: [{type: 'Products', id: 'LIST'}]
        })
    })
});

export const {useGetGoodsQuery, useAddProductMutation, useDeleteProductMutation} = goodsApi;
            </pre>

                        <p>Где в addProduct мы передаем body в качестве параметра и тела будущего запроса, и далее при
                            использовании
                            хука useAddProductMutation мы будем деструктурировать из него функцию в параметры которой
                            собственно
                            и
                            будем передавать то, что мы хотим добавить.</p>
                        <p>В случае же deleteProduct в параметр мы передаем расширитель эндпоинта и используем тип
                            запроса
                            DELETE</p>
                        <p>tagTypes, providesTags и invalidatesTags используются для того, чтобы синхронизировать бэкенд
                            и
                            фронтэнд
                            и производить автоматические запросы для обновления данных в случае если МЫ поменяли данные
                            на
                            бэкенде,
                            данные сущности нужны в случае если мы работаем с build.mutation.</p>

                        <p>Деструктурированные из useAddProductMutation и useDeleteProductMutation функции АСИНХРОННЫ и
                            требуют
                            использования синтаксиса async/await!:</p>

                        <p><a href="https://github.com/michey85/rtk-query-example/blob/rtk/src/App.js">Гитхаб файл
                            App.js</a>
                        </p>

                        <pre>
...
const {data = [], isLoading} = useGetGoodsQuery(count);
const [addProduct, {isError}] = useAddProductMutation();
const [deleteProduct] = useDeleteProductMutation();

const handleAddProduct = async () => {
    if(newProduct) {
        await addProduct({name: newProduct}).unwrap();
        setNewProduct('');
    }
}

const handleDeleteProduct = async (id) => {
    await deleteProduct(id).unwrap();
}
...
            </pre>

                        <p>unwrap() нужен для обработки ошибок.</p>
                    </div>
                </section>
            </section>
        </section>

        <section id="typeScriptNav">
            <h2 id="typescript">Основы TypeScript</h2>

            <section>
                <h4 id="typeScriptCommonInfo">Общая информация о TypeScript</h4>

                <div>
                    <p>TypeScript это расширение JavaScript, которое типизирует переменные.</p>
                    <p>Тип в TS - простой способ обращения к различным свойствам и функциям, которые имеют значения.</p>
                    <p>Описание типов всех методов и их аргументов находится в библиотеке с definition файлами d.ts,
                        по-сути
                        разработчики перенесли туда всю документацию по методам и исходя из типов переменных применяемых
                        в
                        этих методах в документации, TS производит оценку валидности наших переменных, которые мы
                        пытаемся
                        подставить в аргументы к данным методам.</p>

                    <p>Система Типов TypeScript:</p>
                    <ul>
                        <li>Помогает нам обнаруживать ошибки во время разработки</li>
                        <li>Использует "аннотации типов" для анализа кода</li>
                        <li>Активна только во время разработки</li>
                        <li>Не обеспечивает оптимизацию производительности</li>
                    </ul>

                    <p>TypeScript compiler устанавливается с помощью следующей команды:</p>
                    <pre>npm install -g typescript ts-node</pre>

                    <p>Чтобы перевести код из ts в js нужно использовать команду tsc fileName или просто tsc в корневой
                        папке, чтобы сделать постоянную компиляцию из ts в js нужно использовать команду tsc -w в
                        корневой
                        папке</p>
                    <p>Для того чтобы js код сохранялся в определенной папке в конфигурационном файле tsconfig.json
                        нужно
                        включить и настроить опции "rootDir" и "outDir"</p>

                    <p>Типы делятся на:</p>
                    <ul>
                        <li>
                            Примитивные типы:
                            <ul>
                                <li>number</li>
                                <li>string</li>
                                <li>boolean</li>
                                <li>symbol</li>
                                <li>void</li>
                                <li>null</li>
                                <li>undefined</li>
                            </ul>
                        </li>
                        <li>
                            Объектные типы:
                            <ul>
                                <li>functions</li>
                                <li>classes</li>
                                <li>arrays</li>
                                <li>objects</li>
                            </ul>
                        </li>
                    </ul>
                    <p>interface используется в TS для определения структуры объектов.</p>
                </div>
            </section>

            <section>
                <h4 id="typeAnnotationsAndTypeInference">Аннотации и вывод типов</h4>

                <div>
                    <p>Type annotations(аннотации типов) - код, который мы добавляем для TS, чтобы он понял, значение
                        какого
                        типа будут содержаться в переменной.</p>
                    <p>Примеры аннотации типов:</p>
                    <pre>
//dummy variables
const someVariable1: number = 5;
const someVariable2: string = "string";
const someVariable3: boolean = true;
const someVariable4: null = null;      // в случае с null можно присвоить переменной undefined
const someVariable5: undefined = undefined;    // в случае же с undefined переменной можно присвоить null

//build-in objects(встроенные объекты)
const date: Date = new Date();

//array
const arrayOfColors: string[] = ["red", "yellow", "black"];
const numbers: number[] = [1, 2, 3];

// classes
class Car {

}
const car: Car = new Car();

 //annotation for object literal(аннотации для объектных литералов)
interface ServerConfiguration {
   protocol: 'http' | 'https',
   port: 3000 | 3001
}

const serverConfig: ServerConfiguration = {
   protocol: 'https',
   port: 3001
}

const port3000: number = 3000;
const port3001: number = 3001;

function startServer(protocol: "http" | "https", port: 3000 | 3001): "Server started" {
   if (port === port3000 || port === port3001) {
      console.log(`Server started on ${protocol}://server:${port}`)
   } else {
      console.error('Invalid Port ')
   }
   return "Server started";
}

startServer(serverConfig.protocol, serverConfig.port);

type someObjectType = {       // или interface someObjectType {...}
   someObjectKey1: string;
   someObjectKey2: number;
   someObjectKey3: string[];
   someObjectKey4: number[];
}

const someObject: someObjectType = {
   someObjectKey1: 'someString',
   someObjectKey2: 2,
   someObjectKey3: ["string","string","string",],
   someObjectKey4: [1, 2, 3,]
};

//functions
const logNumber: (i: number) => void = (i) => {
   console.log(i)
}

//примитивные литеральные типы(создание своих типов на основании конкретных значений примитивов)
let msg: 'Hello';
msg = 'Hello'; // и ничего больше сюда нельзя присвоить!
            </pre>
                    <p>Type inference(вывод типов) - TS пытается сам определить, значение какого типа будут содержаться
                        в
                        переменной.</p>
                    <p>Если декларация переменной и инициализация ее значения происходит в одной строке, то будет
                        происходить
                        автоматическое определение типа при помощи TS, НО если декларация и инициализация происходят на
                        разных
                        строках, то вывод типа не происходит!</p>
                    <pre>
let color = "red";    // let color: string
let color;
color = red;  // let color: any
            </pre>
                    <p>Поэтому если переменная объявляется и инициализируется в одном выражении - аннотация типов
                        НЕНУЖНА!</p>
                    <p>Аннотация типов используется в следующих случаях:</p>
                    <ul>
                        <li>Когда переменная объявляется, но инициализируется позже</li>
                        <li>Когда создается переменная, вывод о типе которой не может быть сделан</li>
                        <li>Когда функция возвращает тип "any" и нам нужно уточнить тип</li>
                    </ul>
                    <p>Тип "any" категорически нужно избегать!!! Т.к. TS не имеет входных данных для проверки кода на
                        валидность.</p>
                    <p>В случае если переменная объявляется через const и без аннотации типа, то типом данной переменной
                        будет присвоенное ей значение(литеральный тип)!</p>
                    <pre>
const isOkay = true; // const isOkay: true (НЕ boolean!!!!!!)
let movement: string | boolean = false;

if (isOkay){
    movement = 'moving'
}
            </pre>
                </div>
            </section>

            <section>
                <h4 id="typeAlias">Type Alias (Псевдонимы типов)</h4>

                <div>
                    <p>В случае если аннотация типов получается слишком длинная или используется несколько
                        раз в разных местах, то используют псевдоним типов</p>

                    <pre>
type AnimationTimingFunction = 'ease' | 'ease-out' | 'ease-in';
type AnimationID = string | number;

function createAnimation(
   id: AnimationID,
   animName: string,
   timingFunction: AnimationTimingFunction = 'ease',
   duration: number,
   iterCount: 'infinite' | number
): void {
   console.log(`${animName} ${timingFunction} ${duration} ${iterCount}`);
}
            </pre>
                </div>
            </section>

            <section>
                <h4 id="functionTypeAnnotations">Аннотации TS для функций и объектов</h4>

                <div>
                    <p>Type annotations(аннотации типов) для функций - Код, который мы добавляем для TS, чтобы он понял,
                        аргумент какого типа будет принимать функция и значение какого типа она будет возвращать.</p>
                    <p>Type inference(вывод типов) для функций - TS пытается сам определить, значение какого типа будет
                        возвращать функция(аргументы не определяются).</p>

                    <pre>
const add = (a: number, b: number): number => {
   return a + b;
}

//

const subtract: (a: number, b: number) => number = (a, b) => {
   return a - b;
}

//

function divide (a: number, b: number): number {
   return a / b;
}

//

const multiply = function (a: number, b: number): number {
   return a * b;
}
            </pre>
                    <p>Аннотации типов функций пишутся как для аргументов, так и для возвращаемого значения
                        ВСЕГДА!!!</p>
                    <p>В случае если функция ничего не возвращает, используют следующий синтаксис:</p>
                    <pre>
const logger = (message: string): void => {
   console.log(message)
}
            </pre>
                    <p>Если мы полностью уверены, что мы никогда не будем достигать конца функции, то используем
                        следующий
                        синтаксис:</p>

                    <pre>
const throwError = (message: string): never => {
   throw new Error(message);
}

//возврат never в качестве исчерпывающей проверки

const createError = (msg: string): never => {
    throw new Error(msg);
}

const userData: userDataTypes = JSON.parse(userDataJSON);

const logBirthday = (userData: userDataTypes): string => {
    if (userData.isBirthday){
        return `Congrats to ${userData.userNameData}, he is ${userData.ageData} age today`
    } else if (!userData.isBirthday) {
       return 'It is bad'
    }
    return createError('Error'); // исчерпывающая проверка
}

console.log(logBirthday(userData));
            </pre>
                    <p>В случае если в качестве аргумента в функции используется объект используют следующий
                        синтаксис:</p>
                    <pre>
const forecast = {
   date: new Date(),
   weather: 'rainy',
}

const logWeather = (forecast: {date: Date; weather: string}): void => {
   console.log(forecast.date);
   console.log(forecast.weather)
}
logWeather(forecast);
            </pre>
                    <p>Если же пользоваться синтаксисом ES2015 с деструктуризацией аргументов из объекта, то синтаксис
                        TS
                        будет выглядеть следующим образом:</p>
                    <pre>
const forecast = {
   date: new Date(),
   weather: 'rainy',
}
const logWeather1 = ({date, weather}: {date: Date; weather: string}) => {
   console.log(date)
   console.log(weather);
}
logWeather1(forecast);
            </pre>
                    <p>В случае если мы деструктуризируем объект и нам нужно применить TS, то используется следующий
                        синтаксис:</p>
                    <pre>
const profile = {
   name: 'Sally',
   age: 25,
   coordinates: {
       lat: 1,
       lng: 20
   },
   setAge(age: number): void{
      this.age = age;
   }
}

const {age}: {age: number} = profile;

const {coordinates: {lat, lng}}: {coordinates: {lat: number; lng: number}} = profile;
            </pre>
                    <p>В случае если у нас в функции объединенный тип из двух объектов и нужно получить доступ к одному
                        из
                        них то используют синтаксис с in</p>
                    <pre>
function checkReadings (readings: {system: number} | {user: number}){
   if ('system' in readings){
      console.log(readings.system);
   } else {
      console.log(readings.user);
   }
}
            </pre>
                </div>
            </section>

            <section>
                <h4 id="nullAndUndefinedTypes">Типы null и undefined</h4>

                <div>
                    <p>null является подтипом всех типов и может быть присвоен любой переменной с любой типизацией за
                        исключением типа undefined, НО данная возможность дефолтно отключена в tsconfig и настраивается
                        в
                        "strictNullChecks"! Такая же ситуация с undefined, и в этой ситуации все так же работает
                        "strictNullChecks"</p>
                </div>
            </section>

            <section>
                <h4 id="symbolAndBigIntTypes">Типы symbol и BigInt</h4>

                <div>
                    <p>Синтаксис типизации символов:</p>
                    <pre>
let id: symbol = Symbol('id');

const data = {
   [id]: 1
}

console.log(data[id]);
            </pre>
                    <p>BigInt позволяет безопасно работать с числами которые выходят за диапазоны стандартного типа
                        данных
                        number(+ или - 2^53-1)</p>
                    <pre>
const number1: bigint = 1n;
const number2: bigint = 2n;

console.log(number1 + number2);
console.log(number1 + 1n);
            </pre>

                    <p>Number и BigInt нельзя смешивать в операциях — они должны быть приведены к тому же типу.</p>
                </div>
            </section>

            <section>
                <h4 id="typeAny">Тип any</h4>

                <div>
                    <p>Тип который означает кто у данной переменной может быть любой тип, является недопустимым при
                        использовании TS!!!</p>
                    <p>Примеры когда возвращается тип any:</p>
                    <pre>
//объявление переменной без присвоения ей значения
let salary: number; // в данном случае type inference не сработает и без аннотации будет присвоен тип any
salary = 5000;


//возврат any в JSON.parse()

const userDataJSON = '{"isBirthdayData": true, "ageData": 40, "userNameData": "John"}';

interface userDataTypes {
    isBirthday: boolean;
    ageData: number;
    userNameData: string
}

const userData: userDataTypes = JSON.parse(userDataJSON); // дабы не возвратилось any делаем аннотацию перепенной через интерфейс

const logBirthday = (userData: userDataTypes) => {
    return `Congrats to ${userData.userNameData}, he is ${userData.ageData} age today`;
}

console.log(logBirthday(userData));  // Congrats to John, he is 40 age today
            </pre>
                </div>
            </section>

            <section>
                <h4 id="typeUnknown">Тип unknown</h4>

                <div>
                    <p>В случае если мы не знаем какой будет тип у данной переменной нужно присвоить ей тип unknown,
                        данный
                        тип
                        ограничит любые потенциально опасные операции с данной переменной.</p>
                    <pre>
let someVariable: unknown;
someVariable = 'str';
//someVariable = ['1', '2', '3'];

let someData: string[] = someVariable; //Type 'unknown' is not assignable to type 'string[]'

//соответственно чтобы выполнить какую-то операцию нужно выполнить проверку типа:

if (Array.isArray(someVariable) && someVariable.every(item => typeof item === 'string')){
   let someData: string[] = someVariable;
   someData.find(e => console.log(e));
}

//----------------------------------------------------------------------------------------//

const userDataUnknown = '{"isBirthdayData": true, "ageData": 40, "userNameData": "John"}';

function safeParse(str: string): unknown {
   return JSON.parse(str)
}

const unknownData = safeParse(userDataUnknown);

function transferData(data: unknown): void {
    if (typeof data === 'string'){
        console.log(data.toUpperCase());
    } else if (typeof data === 'object' && data){
        console.log(data); //{ isBirthdayData: true, ageData: 40, userNameData: 'John' }
    } else {
        console.error('Some Error')
    }
}

transferData(unknownData);

type T0 = number | unknown; // unknown всегда будет перекрывать number и любой другой тип
type T1 = any | unknown; // за исключением типа any
type T2 = number & unknown; // в данном случае ситуация обратная, number и другие типы будут перекрывать unknown
type T3 = any & unknown; // и any тоже перекроет unknown
            </pre>
                </div>
            </section>

            <section>
                <h4 id="returnVoid">Возвращаемый функцией тип void</h4>

                <div>
                    <p>Для того, чтобы обозначить что функция ничего не возвращает используют в аннотации тип void,
                        аннотация
                        можеть быть написана на прямую к блоку аргументов так и к имени функции, первый метод аннотации
                        будет
                        означать что функция вообще ничего не вернет, а второй метод будет игнорировать любое
                        возвращаемое
                        значение</p>
                    <pre>
type voidFunc = () => void;

const returnString: voidFunc = () => {
   return 'string';
}

console.log(returnString());

const returnNumber: voidFunc = () => {
   return 5;
}

console.log(returnNumber());

const someFunc = (): void => {
   //return true; //error: Type 'boolean' is not assignable to type 'void'
}

const names = ['Anna', 'John'];

names.forEach((name, index, array) => array.push('Hello')) //Array&lt;string&gt;.forEach(callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any): void
//комментарий к методу forEach говорит о том что callback функция проигнорирует возвращаемые значения других методов)
            </pre>
                </div>
            </section>

            <section>
                <h4 id="requestsType">Запросы типа</h4>

                <div>
                    <p>В случае если интерфейс или тип не требуется по причине одинарного использования переменной, то
                        можно
                        на
                        прямую запросить ее тип в аннотации следующим синтаксисом:</p>
                    <pre>
const dataFormControl = {
   water: 200,
   el: 350
}

function checkReadings(data: typeof dataFormControl): boolean{
   const dataFromUser = {
      water: 200,
      el: 350
   }

   return data.water === dataFromUser.water && data.el === dataFromUser.el;
}
            </pre>
                    <p>Так же с помощью аннотации через typeof конструкции можно скопировать значение в другую
                        переменную
                        создав литерал:</p>
                    <pre>
const PI = 3.14;
let PIClone: typeof PI; // let PIClone: 3.14
            </pre>
                </div>
            </section>

            <section>
                <h4 id="optionalOperatorReadonly">Опциональный (Optional operator) и notNull/notUndefined операторы и
                    модификатор readonly</h4>

                <div>
                    <p>В случае если нам требуется сделать одно или несколько свойств объекта опциональным, и мы точно
                        знаем
                        что свойство объекта будет существовать, то нам требуется использовать следующий синтаксис:</p>
                    <pre>
interface User {
   readonly login: string;
   password: string;
   age: number;
   readonly address?: string; // для опциональных свойств так же применяется
   parents?: {
      mother?: string;
      father?: string;
   }
}

const user: User = {
   login: 'login',
   password: 'password',
   age: 30,
   //address: 'address',  // ошибки не будет
}

const userFreeze: Readonly&lt;User&gt; = {
   login: 'login',
   password: 'password',
   age: 30,
}

// user.login = 'another login'; //Cannot assign to 'login' because it is a read-only property.
user.password = 'another password'; // ok

let dbName: string;
sendUserData(user, 'someDB');

//console.log(dbName); // TS выдаст ошибку что переменная используется до декларации
console.log(dbName!);  //notNull оператор же даст гарантию того что переменная будет существовать

function sendUserData(obj: User, db?: string): void {
   dbName = 'someDBName';
   console.log(obj.parents!.mother?.toUpperCase(), db?.toLowerCase()) // где "!" указывает на то что объект parents точно будет существовать,
                                                                      // а "?" проверяет на наличие вложенных в parents свойств
}

//const basicPorts: readonly number[] = [3000, 3001, 5555];
const basicPorts: ReadonlyArray&lt;number&gt; = [3000, 3001, 5555]; // тоже самое что и readonly number[]
//basicPorts[0] = 1000; //  Index signature in type 'readonly number[]' only permits reading
            </pre>
                </div>
            </section>

            <section>
                <h4 id="arraysInTS">Массивы в TS</h4>

                <div>
                    <p>Typed arrays(Типизированные массивы) - Массивы, в которых каждый элемент - это значение
                        определенного
                        типа.</p>
                    <p>Примеры:</p>
                    <pre>
const colors = ['green', 'red', 'yellow'];
const numbers: number[] = [];
const dates = [new Date(), new Date(), new Date(),];
const fruitsByColor = [   // string[][]
   ['apple','pear',],
   ['tomato', 'dragonFruit',],
   ['banana', 'pineapple',]
]

const fruitsByColor1: string[][] = []
            </pre>
                    <p>В случае если мы инициализируем пустой массив, обязательно нужно писать аннотацию, в обратном
                        случае
                        можно воспользоваться автоматическим выводом типов</p>
                    <pre>
const colors = ['blue', 'red', 'white']; // const colors: string[]
const numbers: number[] = [];
            </pre>
                    <p>Зачем TS для массивов?</p>
                    <pre>
//Помощь вывода типов при извлечении значения из массива
const color = colors[0] // const color: string

//TS может предотвратить добавление несовместимых типов в массив
colors.push(true) //error

//Мы можем получить помощь используя метод массивов "map", "forEach", "reduce"
colors.map((color: string): string => color.toUpperCase())

//Гибкость - массивы могут содержать значения разных типов
const importantDates = [new Date(), '11.11.1991', new Date(), '05.05.1995']; //const importantDates: (string | Date)[]
const importantDates1: (string | Date)[] = [new Date()];
importantDates1.push('11.11.1993') // ошибки нет
            </pre>
                    <p>Когда использовать типизированные массивы? - Каждый раз когда нам нужно представить коллекцию
                        записей
                        в случайном порядке.</p>
                </div>
            </section>

            <section>
                <h4 id="tuples">Tuples(Кортежи) в TS</h4>

                <div>
                    <p>Tuples(кортежи) - Структуры похожие на массивы, в которых каждый элемент - это какое-то свойство
                        записи.</p>
                    <p>Пример:</p>
                    <pre>
//объект отображающий напиток
const drink = {
   color: 'brown',
   carbonated: true,
   sugar: 40,
}

//Кортеж отображающий напиток, данный синтаксис жестко фиксирует
//тип значения с соответствующим индексом
const cola: [string, boolean, number] = ['brown', true, 40];

//также в кортежах можно использовать синтаксис типового alias
type Drink = [string, boolean, number];
const cola: Drink = ['brown', true, 40];
const sprite: Drink = ['clear', true, 40];

//в случае если количество элементов в кортеже не известно,
//то можно использовать спред оператор
const userDataTuple: [boolean, number, ...string[]] = [true, 40, "John", "Alex", "Ann"];
            </pre>
                </div>
            </section>

            <section>
                <h4 id="interfaces">Интерфейсы</h4>

                <div>
                    <p>Interface - создает новый тип, описывая название свойств и типы значений объекта.</p>
                    <p>Интерфейсы имеют следующий синтаксис:</p>
                    <pre>
interface Reportable  {
    //name: string;
    //year: number;
    //broken: boolean;
    summary?(): string;
}

const oldCivic = {
    name: 'Civic',
    year: 2000,
    broken: true,
    summary() {
        return `
        Name: ${this.name}
        Year: ${this.year}
        Broken?: ${this.broken}`
    }
}

const cola = {
    color: 'brown',
    carbonated: true,
    sugar: 40,
    summary(): string {
        return `
        color: ${this.color}
        carbonated?: ${this.carbonated}
        sugar: ${this.sugar}
        `
    }
}

const printSummary = (item: Reportable): void => {
   if (item.summary){
      console.log(item.summary());
   }
}

printSummary(oldCivic);
printSummary(cola);
            </pre>
                    <p>В случае если мы не знаем какое количество аргументов будет, то используем следующий
                        синтаксис:</p>
                    <pre>
interface IStyles {
   [key: string]: string
}

const styles: IStyles = {
   position: 'absolute',
   top: '20px',
   left: '50px'
}
            </pre>
                    <p>Основная стратегия повторно используемого кода в TS:</p>
                    <ul>
                        <li>Создание функций, которые принимают параметры, типизированные при помощи интерфейсов</li>
                        <li>Объекты/Классы могут "имплементировать" нужный интерфейс для работы с функцией</li>
                    </ul>
                </div>
            </section>

            <section>
                <h4 id="interfaceVSTypes">Interface VS Types</h4>

                <div>
                    <p>Если нужен примитивный тип в качестве псевдонима типа, то используется только type, если берется
                        готовый
                        тип объекта и его нужно расширить то нужно использовать только interface, если работаем только с
                        объектом то разницы в выборе нет, но чаще всего используют интерфейсы, type же используют когда
                        нужен примитивный или объединенный тип</p>
                </div>
            </section>

            <section>
                <h4 id="classesInTS">Классы в TS</h4>

                <div>
                    <p>Class - шаблон для создания объектов - с полями(значения) и методами(функции) для отображения
                        "чего-то" в
                        приложении.</p>
                    <p>Пример:</p>
                    <pre>
class Vehicle {

   //color: string; // поле класса

   //constructor(color: string) {
   //   this.color = color;
   //}

   constructor(public color: string) { // сокращенный способ с помощью конструктора конфигурировать поля
   }

   public drive(): void {
      console.log("i'm driving");
   }

   public stop(): void {
      console.log("i've stopped");
   }

   protected beep(): void {
      console.log("Beeeep!");
   }
}

class Car extends Vehicle {

   constructor(public wheels: number, color: string) {
      super(color);
   }

   private drive1(): void {
      console.log("i'm a car and i'm driving");
   }
   startDrivingProcess(): void{
      this.drive1(); // из-за модификатора private мы можем вызвать drive1 только внутри класса
      this.beep(); //мы можем здесь вызвать метод "beep()" тк его модификатор protected
   }
}

const vehicle = new Vehicle("black");
vehicle.drive(); //i'm driving
vehicle.stop(); //i've stopped
console.log(vehicle.color); //black

const car = new Car(4, 'red');
//car.drive1(); //error cus private
//car.beep(); //error cus protected
car.startDrivingProcess(); //i'm driving
car.stop(); //i'm a car and i'm driving
console.log(car.color); //black
            </pre>
                    <p>Где класс Vehicle является родительским(или супер) классом, а Car - дочерним</p>
                    <p>Модификаторы - ключевые слова которые мы можем размещать для методов и свойств классов, цель
                        модификаторов ограничивать для методов и свойств доступ.</p>
                    <p>Существует три модификатора:</p>
                    <ul>
                        <li>public - этот метод может быть вызван откуда угодно, в любое время. Является дефолтным.</li>
                        <li>private - Этот метод может быть вызван только другими методами внутри того же класса.</li>
                        <li>protected - этот метод может быть вызван другими методами внутри того же класса или другими
                            методами внутри класса наследника.
                        </li>
                    </ul>
                    <p>Поля - свойства с какими-то значениями, поля так же имеют все те же самые модификаторы.</p>
                    <p>interface + Class = повторное использование кода в TS. Внутри TS приложений классы используются
                        практически всегда.</p>
                </div>
            </section>

            <section>
                <h4 id="typeGuard">Type Guard (защита типов)</h4>

                <div>
                    <p>В случае когда у нас в аннотации присутвует объединенный тип двух интерфейсов, и свойства в них
                        разные, а
                        нам надо работать со всеми свойствами этих двух объектов, то требуется использовать защиту
                        типов:</p>
                    <pre>
interface Car {
   engine: string;
   wheels: {
      wheelsQuantity: number;
      wheelsType: string;
   }
}

interface Ship {
   engine: string;
   sail: string;
}

interface Airplane {
   name: 'airplane';
   engine: string;
   wings: string;
}

interface Rocket {
   name: 'rocket';
   engine: string;
   enginesQuantity: number;
}

type Vehicles = Car | Ship | Airplane | Rocket;

function repairVehicle(vehicle: Car | Ship){
   console.log(vehicle.engine) //доступно только свойство engine
   if (isCar(vehicle)){
      console.log(vehicle.wheels); // engine & wheels
   } else if (isShip(vehicle)) {
      console.log(vehicle.sail); // engine & sail
   } else {
      console.log(vehicle); //тк код сюда не дойдет то тип "never"
   }
}

function isCar(car: Car | Ship): car is Car{ // именно "car is Car" является защитником типа
    return 'wheels' in car;                  // если здесь будет просто boolean - данная конструкция не сработает
}
            </pre>
                    <p>Так же существует более продвинутая версия проверки на принадлежность к интерфейсу:</p>
                    <pre>
function isCar(car: Car | Ship): car is Car{
   //return 'wheels' in car;
   return (car as Car).wheels !== undefined; // фактически это тоже самое
}
            </pre>
                    <p>Вместо if else конструкции лучше использовать конструкцию switch case:</p>
                    <pre>
function repairVehicle(vehicle: Vehicles){
    switch (vehicle.name){
        case "car":
            console.log(vehicle.wheels);
            break;
        case "ship":
            console.log(vehicle.sail);
            break;
        case "airplane":
            console.log(vehicle.wings);
            break;
        case "rocket":
            console.log(vehicle.enginesQuantity);
            break;
        default:
            console.log('Транспортного средства не найдено');
            const someVar: never = vehicle; // vehicle: never
    }
}
            </pre>
                    <p>В случае если мы забудем обработать какой-то новый интерфейс, то vehicle будет уже не never, что
                        и
                        будет сигналом ошибки</p>
                </div>
            </section>

            <section>
                <h4 id="functionOverloads">Перегрузка функций (function overloads)</h4>

                <div>
                    <p>Для того чтобы было удобнее работать с функциями используют т.н. перегрузку функции, это
                        своеобразная
                        документация декларируемая до основной функции, где описываются сценарии количества аргументов и
                        что
                        будет возвращаться функцией:</p>

                    <pre>
interface Square {
   side: number;
   area: number;
}

interface Rectangle {
   sideA: number;
   sideB: number;
   area: number;
}

function calculateArea(side: number): Square; // перегрузка функции
function calculateArea(sideA: number, sideB: number): Rectangle;  // перегрузка функции

function calculateArea(a: number, b?: number): Square | Rectangle {
   if (b){
       return {
           sideA: a,
           sideB: b,
           area: a*b
       } as Rectangle;
   }else {
       return {
           side: a,
           area: a*a,
       } as Square;
   }
}

calculateArea(5); //function calculateArea(side: number): Square
calculateArea(5,10); //function calculateArea(sideA: number, sideB: number): Rectangle
            </pre>
                    <p>Правила работы с перегрузкой функции:</p>
                    <ul>
                        <li>Перегрузка функции всегда записывается ДО основного тела функции</li>
                        <li>Аргументы могут называться другими именами</li>
                        <li>Все перегрузки должны быть совместимы с главной функцией</li>
                    </ul>
                </div>
            </section>

            <section>
                <h4 id="designPatternsInTS">Использование шаблонов проектирования(Design Patterns) в TS</h4>

                <div>
                    <p>Для того чтобы запускать TS сразу в браузере нужно установить parcel-bundler в командной
                        строке:</p>
                    <pre>npm install -g parcel-bundler</pre>
                    <p>При запуске в командной строке нужно указать "parcel someFileName"</p>
                    <p>При декларировании типов свойств объектов и инициализации этого объекта в классах, в конструкторе
                        не
                        нужно обращаться к свойству объекта на прямую, тк сам объект еще не инициализирован!:</p>
                    <pre>
export class Company {
   companyName: string;
   catchPhrase: string;
   location: {  //здесь мы только декларируем типы, но не инициализируем
      lat: number;
      lng: number;
   };

   constructor() {
      this.companyName = faker.company.companyName();
      this.catchPhrase = faker.company.catchPhrase();
      this.location = {  // а здесь мы уже производим инициализацию объекта, поэтому не надо обращаться к свойствам объекта, а нужно присваивать их!
         lat: +faker.address.latitude(), // а не this.location.lat = +faker.address.latitude(); ЭТО ОШИБКА!!!
         lng: +faker.address.longitude() // а не this.location.lng = +faker.address.longitude(); ЭТО ОШИБКА!!!
      }
   }
}
            </pre>
                    <p>Когда мы через оператор или | присваиваем переменной два типа, и допустим это два объекта, то во
                        внимание будут приниматься только те свойства этих двух объектов, которые присутствуют в них
                        обоих.</p>
                    <pre>
async addMarker(obj: Company | User): Promise&lt;void&gt; {
   const { AdvancedMarkerElement } = await google.maps.importLibrary("marker") as google.maps.MarkerLibrary;
   const marker = new AdvancedMarkerElement({
      map: this.googleMap,
      position: {
         lat: obj.location.lat, // при этом нельзя обратиться к свойству obj.name или obj.companyName, исключительно только к свойству obj.location!!!
         lng: obj.location.lng
      },
   });
}
            </pre>
                    <p>В случае если мы используем интерфейс и нам нужно точно получить место ошибки, то этот интерфейс
                        нужно
                        импортировать в используемый класс и имплементировать этот класс в интерфейс:</p>
                    <pre>
import * as faker from "faker";
import {ObjInterface} from "./CustomMap";

export class User implements ObjInterface{
   name: string;
   location: {
      lat: number;
      lng: number;
   };
   constructor() {
      this.name = faker.name.firstName();
      this.location = {
         lat: +faker.address.latitude(),
         lng: +faker.address.longitude()
      }
   };

   markerContent(): string{
      return `User Name: ${this.name}`
   }
}
            </pre>
                    <p>В случае если при использовании объединенных типов нужно использовать весь набор свойств и
                        методов
                        определенного значения, то нужно применить охрану типов, т.е условную конструкцию с
                        instanceof:</p>
                    <pre>
class Sorter {
   constructor(public collection: number[] | string) {}
   counter: number = 0;
   sorting(): void{
      let {length} = this.collection
      for (let i = 0; i &lt; length; i++){
         for (let j = 0; j &lt; length - i - 1; j++) {
            if (this.collection instanceof Array){  //или Array.isArray(this.collection[j]) - type guard
               if (this.collection[j] &gt; this.collection[j + 1]){
                  this.counter += 1;
                  let acc = this.collection[j];
                  this.collection[j] = this.collection[j+1];
                  this.collection[j+1] = acc;
               }
            }
            if (typeof this.collection === 'string'){ // type guard

            }
         }
      }
   }
}
                    </pre>
                    <p>Если значения примитивного типа(string, number, symbol, boolean) то используется синтаксис
                        typeof,
                        если
                        же любое другое значение созданное с помощью функции конструктора, то instanceof!!!</p>
                </div>
            </section>

            <section>
                <h4 id="abstractClasses">Абстрактные классы</h4>

                <div>
                    <p>Абстрактные классы:</p>
                    <ul>
                        <li>Не может использоваться для создания объекта на прямую</li>
                        <li>Используется только как родительский класс</li>
                        <li>Может содержать реализацию некоторых методов</li>
                        <li>Реализованные методы могут ссылаться на другие методы, которых на самом деле еще не
                            существует(но
                            нужно указать имена и типы для нереализованных методов)
                        </li>
                        <li>Может заставить дочерние классы пообещать реализовать какой-то другой метод</li>
                    </ul>

                    <pre>
export abstract class Sorter {

   abstract compare(leftHand: number, rightHand:number): boolean;
   abstract swap(leftHand: number, rightHand:number): void;
   abstract get length(): number;

   sorting(): void {
      let {length} = this
      for (let i = 0; i &lt; length; i++) {
         for (let j = 0; j &lt; length - i - 1; j++) {
            if (this.compare(j, j+1)){
               this.swap(j, j+1)
            }
         }
      }
   }
}

interface IEngine {
    model: string;
    capacity: number;
    startEngine: (time: Date) =&gt; string;
    stopEngine: (time: Date) =&gt; string;
}

abstract class AbstractVehicle{
    model!: string;
    capacity!: number;

    constructor(model: string, capacity: number) {
        this.model = model;
        this.capacity = capacity;
    }

    abstract startEngine: (time: Date) =&gt; string;
    stopEngine(time: Date): string {
        return `Engine Stopped at ${time.toLocaleString()}`
    }
}

class SomeVehicle extends AbstractVehicle{
    startEngine = (time: Date): string =&gt; {
        return `Engine Started at ${time.toLocaleString()}`;
    }
}

const newVehicle = new SomeVehicle('1', 111);
newVehicle.startEngine(new Date());
newVehicle.stopEngine(new Date());
            </pre>
                    <p>методы и свойства с модификатором abstract удаляются в js файле!(вопрос на собеседовании, что с
                        ними происходит)</p>

                    <p>Интерфейсы VS Абстрактные классы</p>

                    <p>Интерфейсы:</p>
                    <ul>
                        <li>Устанавливают контракт между разными классами</li>
                        <li>Используются, когда у нас есть очень разные объекты, с которыми мы хотим работать вместе
                        </li>
                        <li>Способствует слабому сцеплению</li>
                    </ul>

                    <p>Абстрактные классы / наследование:</p>
                    <ul>
                        <li>Устанавливают контракт между разными классами</li>
                        <li>Используются, когда мы пытаемся создать определение класса</li>
                        <li>Способствует сильному сцеплению</li>
                    </ul>
                </div>
            </section>

            <section>
                <h4 id="enumerations">Enumerations(enum)</h4>

                <div>
                    <p>Тип enum или по-другому перечисление - это особый тип данных, который позволяет задавать некий
                        список
                        взаимосвязанных констант. Переменные этого типа могут принимать значения только из заданного в
                        перечислении набора. Это свойство перечислений делает их удобным инструментом для реализации
                        списка
                        связанных значений.</p>
                    <pre>
enum MatchResult {
   HomeWin = 'H',
   AwayWin = 'A',
   Draw = 'D'
}

enum Directions {
   RIGHT,
   LEFT,
   TOP,
   BOTTOM
}

enum TFunction {
   EASE = 'ease',
   LINEAR = 'linear',
   EASE_IN = 'ease-in',
   EASE_OUT = 'ease-out',
   EASE_IN_OUT = 'ease-in-out',
   CUBIC_BEZIER = 'cubic-bezier'
}

function frame(elem: string, dir: Directions, tFunction: TFunction): void {
   if (dir === Directions.RIGHT) {
      console.log(tFunction);
   }
}

frame('id', Directions.RIGHT, TFunction.EASE);
            </pre>
                    <p>Когда мы создаем enum, мы так же создаем новый тип, в случае из примера это будет
                        MatchResult.</p>
                    <p>Enums перечисления:</p>
                    <ul>
                        <li>Соблюдает почти идентичные правила синтаксиса как обычный объект</li>
                        <li>Создает объект с такими же ключами и значениями при преобразовании из TS в JS</li>
                        <li>Основная цель - дать понять другим разработчикам, что все эти значения тесно связаны</li>
                        <li>Используются всякий раз, когда у нас есть небольшой фиксированный набор значений(15ед макс),
                            которые тесно связаны и известны во время компиляции
                        </li>
                    </ul>
                </div>
            </section>

            <section>
                <h4 id="typeAssertions">Type assertions(утверждение типа)</h4>

                <div>
                    <p>Для того чтобы переприсвоить какой-то переменной определенный тип можно использовать следующий
                        синтаксис:</p>
                    <pre>
get getData(): string[][] {
   return fs.readFileSync(this.fileName, {
      encoding: 'utf-8'
}).split('\n').map((match: string): string[] =&gt; match.split(',')).map((stringArray: string[]): any =&gt; {
   return [
         dateStringToDate(stringArray[0]),
         stringArray[1],
         stringArray[2],
         parseInt(stringArray[3]),
         parseInt(stringArray[4]),
         stringArray[5] as MatchResult, // Type assertions
         stringArray[6]
      ]
   })
}
            </pre>

                    <p>Существует три способа применения оператора "as":</p>
                    <pre>
//1 способ
const requestOptions = {
   url: 'https://someurl.com',
   method: 'GET' as 'GET',
}

fetchData(requestOptions.url, requestOptions.method);

//2 способ
const requestOptions = {
   url: 'https://someurl.com',
   method: 'GET',
}

fetchData(requestOptions.url, requestOptions.method  as 'GET');

//3 способ
const requestOptions = {
   url: 'https://someurl.com',
   method: 'GET',
} as const;

fetchData(requestOptions.url, requestOptions.method);
            </pre>

                    <p>Так же есть альтернативный синтаксис утверждения типа:</p>
                    <p>Данный синтаксис нельзя использовать в React!!!</p>
                    <pre>
const requestOptions = {
   url: 'https://someurl.com',
   method: 'GET',
};

fetchData(requestOptions.url, &lt;"GET"&gt;requestOptions.method);
            </pre>

                    <p>Работа с HTML элементами:</p>
                    <pre>
//html
&lt;input id="inputId" type="text" value="55"/&gt;
&lt;div class="box"&gt;Hello&lt;/div&gt;


//js/ts
const box = document.querySelector('.box') as HTMLElement;
const input = document.querySelector('#inputId') as HTMLInputElement;
const someNumber: number = +input.value;
//const someNumber: number = input.value as any as number; //нежелательно!!!

console.log(someNumber); //55
            </pre>
                    <p>Синтаксис "as const"</p>
                    <pre>
let a = 'value' as const; //let a: "value"
let b = {f: 100} as const; //let b: {readonly f: 10}
let c = ['a', 'b', 'c'] as const; //let c: readonly ["a", "b", "c"]

let value = 'value';
//let someVar = value as const; //A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals.
            </pre>

                    <p>Утверждение к константе применимо только к простым выражениям!</p>
                    <pre>
let a = (Math.round(Math.random() * 1)
  ? 'yes'
  : 'no') as const; // Ошибка
let b = Math.round(Math.random() * 1)
  ? ('yes' as const)
  : ('no' as const); // Ok, let b: "yes" | "no"
            </pre>
                </div>
            </section>

            <section>
                <h4 id="typesOfConstructorCreatedVariables">Типы переменных значения которых созданы при помощи
                    конструкторов класса</h4>

                <div>
                    <p>Когда присваиваем переменным значения созданные при помощи конструктора энного класса, то тип
                        данной
                        переменной будет соответствовать примитивному типу НО начинаться с большой буквы! И при
                        сравнении
                        двух переменных с примитивными значениями, но разным способом создания двойное сравнение даст
                        true а
                        тройное false!</p>
                    <p>Так же благодаря неявному приведению типов переменной созданной с помощью конструктора можно
                        присвоить обычную переменную с соответвующим обычным типом, обратно же выполнить данную операцию
                        нельзя!</p>
                    <pre>
let num: Number = new Number(5);
let num2: number = 5;
let num3: number = Number(5); // данная функция так же создает примитивный тип number

num = num2; //ok
num2 = num //Type 'Number' is not assignable to type 'number'. 'number' is a primitive, but 'Number' is a wrapper object. Prefer using 'number' when possible.
            </pre>
                    <p>Как видно из описания ошибки разработчики рекомендуют по возможности использовать не объектный
                        способ
                        декларации примитивной переменной.</p>

                </div>
            </section>

            <section>
                <h4 id="objectCreation">Создание объектов на базе другого или других</h4>

                <div>
                    <p>В случае если требуется создать отдельный объект на базе другого, то можно использовать функцию
                        конвертор
                        с соответвующим возвращаемым интерфейсом требуемого объекта:</p>
                    <pre>
interface Department {
   name: string;
   budget: number;
}

const department: Department = {
   name: 'web-dev',
   budget: 50000
}

interface Project {
   name: string;
   projectBudget: number
}

function transformDepartment(department: Department, amount: number): Project {
   return {
      name: department.name,
      projectBudget: amount
   }
}

const mainProject: Project = transformDepartment(department, 5000);
            </pre>
                    <p>Не стоит стремиться описать одним интерфейсом несколько сущностей, лучше создать несколько
                        маленьких
                        интерфейсов!</p>

                    <pre>
interface ComplexVehicle {
    name: 'car' | 'ship' | 'airplane' | 'rocket';
    engine: string;
    wheels?: {
        wheelsQuantity: number;
        wheelsType: string;
    };
    sail?: string;
    wings?: string;
    enginesQuantity?: number;
}

const car: ComplexVehicle = {
   name: "car",
   engine: "v8",
}

function repairVehicle1(vehicle: ComplexVehicle){
    switch (vehicle.name){
        case "car":
            console.log(vehicle.wheels.wheelsQuantity * 2); //NaN, в данном случае больше подойдет узкоспециализированный интерфейс
            break;
        case "ship":
            console.log(vehicle.sail);
           break;
        case "airplane":
            console.log(vehicle.wings);
            break;
        case "rocket":
            console.log(vehicle.enginesQuantity);
            break;
        default:
   }
}
            </pre>
                </div>
            </section>

            <section>
                <h4 id="TSGenerics">Дженерики/Обобщения (generics) в TS</h4>

                <div>
                    <p>Generics:</p>
                    <ul>
                        <li>Как аргументы функции, но для типов - в определениях классов/функций</li>
                        <li>Позволяет нам определить тип свойства/аргумента/возвращаемого значения в будущем</li>
                        <li>Часто используется при написании повторно используемого кода</li>
                    </ul>
                    <pre>
class HoldAnything&lt;TypeOfData&gt;{
   data: TypeOfData;
}

const holdNumber = new HoldAnything&lt;number&gt;();
holdNumber.data = 111;

const holdString = new HoldAnything&lt;string&gt;();
holdString.data = 'something';

function processingData&lt;T, S&gt;(data: T[], options: S): string {
   switch (typeof data){
       case 'string':
           return `${data}, speed: ${options}`;
           break;
       case 'number':
           return `${data}, speed: ${options}`;
           break;
       default:
           return 'Not Valid'
   }
}

let res1 = processingData([5], 'fast');
let res2 = processingData(['5'], 'slow');
const res3 = processingData([5], 5);
const res4 = processingData&lt;number, string&gt;([5], 'slow');

interface DataSaver {
   //processing: &lt;T&gt;(data: T) => T;
   processing: typeof processing;
}

const saver: DataSaver = {
   processing(data) {
       console.log(data);
       return data;
   }
}

const saver2: DataSaver = {
   processing: &lt;T&gt;(data: T) => data,
}

const saver3: DataSaver = {
   processing: (data) => {
       return data
   },
   //processing: data => data;
}

class User2&lt;T, S&gt; {
   name1: T;
   age: S;

   constructor(name1: T, age: S) {
       this.name1 = name1;
       this.age = age;
   }

   sayMyFullName&lt;T&gt;(surname: T): string{
       return typeof surname !== 'string' ? `I have only name: ${this.name1}` : `Surname of ${this.name1} is ${surname}`
   }
}

class Admin&lt;G&gt; extends User2&lt;string, number&gt;{
   rules: G;
   constructor(name1: string, age: number, rules: G) {
       super(name1, age);
       this.rules = rules;
   }
}

const userJohn = new User2('John', 30);

const nameData = 'David';
const ageData = 30;

const userDavid = new User2&lt;string, number&gt;(nameData, ageData);
console.log(userDavid.sayMyFullName&lt;string&gt;('Bowie'));
            </pre>

                    <p>По конвенции используют короткое название &lt;T&gt;</p>
                    <pre>
class HoldAnything&lt;T&gt;{
   data: T;
}
            </pre>
                    <p>Для дженериков так же присущ автоматический вывод типов, НО, все-таки лучше указывать тип
                        дженерика!:</p>

                    <pre>
function printAnything&lt;T&gt;(arr: T[]){
   arr.forEach(el => console.log(el));
}

printAnything([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);  //function printAnything&lt;number&gt;, происходит автоматическое выведение типа
printAnything&lt;string&gt;(['a', 'b', 'c', 'd', 'e', 'f', 'g']);  // НО все-таки лучше производить аннотацию типа!!!
            </pre>

                    <p>Чтобы ограничит дженерики там, где будут использоваться наши кастомные методы или функции, есть
                        специальный синтаксис ограничения(generics constraints):</p>
                    <pre>
//generics constraints

class Human {
   print() {
      console.log('Im a human');
   }
}

class Robot {
   print() {
      console.log('Im a robot');
   }
}

interface Printable {
   print(): void;
}

function printClass&lt;T extends Printable&gt; (arg: T[]): void {
   arg.forEach(classEl => classEl.print());
}

printClass&lt;Printable&gt;([new Human(), new Robot(), new Human(), new Robot()]);

//-----------------------------------------------------------------------------//

interface User1&lt;ParentsData extends ParentsOfUser&gt; {
   login: string;
   age: number;
   parents: ParentsData
}

interface ParentsOfUser {
   father: string;
   mother: string;
}

const user1: User1&lt;{father: string, mother: string, married: boolean, anything: string}&gt;> = {
   login: 'some Login',
   age: 30,
   parents: {
       father: 'John',
       mother: 'Ann',
       married: true,
       anything: 'anything'
   }
}

//generic helpers type

type OrNull&lt;Type&gt; = Type | null;
type OneOrMany&lt;Type&gt; = Type | Type[];

const data1: OneOrMany&lt;number[]&gt; = [5,5,5];

//-----------------------------------------------------------//
const depositMoney = &lt;T extends number | string&gt;(amount: T): T => {
   console.log(`request to server with amount: ${amount}`);
   return amount;
}

depositMoney(500);
depositMoney('five hundreds');
            </pre>

                    <p>Само ограничение создается при помощи синтаксиса &lt;T extends ...&gt;</p>
                    <p>Partial дженерики это встроенный дженерик который позволяет обойти обязательное использование
                        всех
                        свойств задекларированных в интерфейсе:</p>

                    <pre>
interface IState {
   data: {
      name: string;
   };
   tag: string;
}

const state: Partial&lt;IState&gt; = {
   data: {
      name: 'John'
   }
}
            </pre>

                    <p>Если требуется сделать объект иммутабельным, то в блоке аргументов требуется применить
                        ДЖЕНЕРИК(не
                        путать
                        с модификатором!!!) Readonly&lt;interface&gt; где interface это выбранный нами интерфейс для
                        данного
                        объекта:</p>

                    <pre>
interface IState {
   data: {
      name: string;
   };
   tag: string;
}

const action = (state: Readonly&lt;IState&gt;) => {
   const newObj = state.data;
}

//Если же требуется обратная ситуация, где в интерфейсе есть опциональный оператор, а требуется чтобы все свойства
//были обязательными, то нужно использовать дженерик Required

interface IState {
       data: {
          name: string;
       };
       tag: string;
    }
    const strictState: Required&lt;IState&gt; = {
       data: {
           name: 'David',
       },
       tag: 'some tag',
       someValue: 42,
    }
            </pre>
                </div>
            </section>

            <section>
                <h4 id="TSOperators">TypeScript операторы</h4>

                <div>
                    <p>Оператор keyof:</p>
                    <pre>
interface ICompany {
   name: string;
   debts: number;
}

type CompanyKeys = keyof ICompany;
const keys: CompanyKeys = 'name';

function printDebts&lt;T, K extends keyof T, S extends keyof T&gt;(company: T, name: K, debts: S): void{
   console.log(`${company[name]}, debts: ${company[debts]}`);
}

const hh: ICompany = {
   name: 'HH',
   debts: 50000,
}

printDebts(hh, 'name', 'debts');

const google = {
   name: 'google',
   debts: 1000000000,
   open: true,
}
printDebts(google, 'name', 'debts');
            </pre>

                    <p>Оператор typeof</p>
                    <pre>
const google = {
   name: 'google',
   debts: 1000000000,
   open: true,
}

type GoogleKeys = keyof typeof google;
const someKeys0: GoogleKeys = 'name';
const someKeys1: GoogleKeys = 'debts';
const someKeys2: GoogleKeys = 'open';
            </pre>
                </div>
            </section>

            <section>
                <h4 id="TSClassPropertiesAndMethodsModifieres">TypeScript модификаторы свойств и методов класса</h4>

                <div>
                    <p>Существуют три модификатора в TS:</p>
                    <ul>
                        <li>public - дефолтный модификатор, который делает все свойства и методы доступны как внутри
                            класса
                            так
                            и снаружи при создании инстанса класса
                        </li>
                        <li>private - модификатор, который скрывает свойства и методы вне класса</li>
                        <li>protected - модификатор, который скрывает свойства и методы вне класса, НО оставляет их
                            доступными в
                            дочерних классах
                        </li>
                    </ul>
                    <p>Так же в нативном JS свойство либо метод можно сделать приватным с помощью "#", и тогда
                        свойство/метод
                        будет приватным даже в скомпилированном файле! ДОСТУПНО С ES2015!!!</p>
                    <pre>
const setName = (): string => {
    return "COD";
}

class Player {
    private static game: string = "COD";
    #login!: string;
    private _password!: string;
    public server!: string;
    protected consent!: boolean;

        static { // статичный блок который при первом вызове фиксирует свойства
            Player.game = setName();
        }

    constructor(login: string) {
        this.#login = login;
    }

    get password(){
        return this._password;
    }

    set password(pas: string){
        //validation
        this._password = pas
    }
}

class CompetitivePlayer extends Player{
    rank!: number;

    constructor(login: string, consent: boolean) {
        super(login);
        this.consent = consent;
    }

    isConsented(){
        return this.consent ? 'yes' : 'no'
    }
}

const player = new Player('abrwalg');

player.password = '125zqu';

const comPlayer = new CompetitivePlayer('abrwalgCompet', true);
comPlayer.password = '125zqu';
console.log(comPlayer.isConsented());
            </pre>
                </div>
                <p># лучше использовать для важных данных, которые следует обезопасить от изменений, в остальных случаях
                    лучше использовать private/protected.</p>
            </section>

            <section>
                <h4 id="indexedAccessTypes">Доступ по индексному ключу (Indexed Access Types)</h4>

                <div>
                    <p>Для того чтобы получить доступ к типу одного из значений интерфейса нужно использовать indexed
                        access
                        type, синтаксис следующий:</p>
                    <pre>
interface ICompany {
   name: string;
   debts: number;
   departments: Department1[];
   management: {
       owner: string;
   }
}

interface Department1 {
    [key: string]: string;
}

//Indexed Access Types
type CompanyDebtsType = ICompany['debts'];   //Alias for: ICompany["debts"]; Initial type: number;
type CompanyOwnerType = ICompany["management"]['owner'];    //Alias for: ICompany["management"]["owner"]; Initial type: string
type CompanyDepartmentsType = ICompany['departments'][number];    //Alias for: ICompany["departments"][number]; Initial type: Department1;
type UnionTypeOfICompany = ICompany[keyof ICompany]; //Alias for: ICompany[keyof ICompany]; Initial type: number | {owner: string} | string | Department1[]
            </pre>

                    <p>Для того чтобы в скобках использовать значение некой переменной которой мы присвоили ключ энного
                        интерфейса в виде строки, то это значение нужно типизировать как примитивный стоковый
                        литерал:</p>
                    <pre>
interface ICompany {
   name: string;
   debts: number; // требуется данный тип
   departments: Department1[];
   management: {
       owner: string;
   }
}
const debtsVar = 'debts';
type CompanyDebtsTypeFromVariable = ICompany[typeof debtsVar]; //Initial type: number
            </pre>
                </div>
            </section>

            <section>
                <h4 id="ternaryOperatorWithTS">Тернарный оператор и TS</h4>

                <div>
                    <p>Пример использования тернарного оператора и TS:</p>
                    <pre>type Example = 'string' extends 'Hello' ? string : number; //Alias for: number</pre>
                    <p>Где "string" и "Hello" это примитивные строковые литералы. Тк литерал "Hello" не является
                        строкой(а
                        строковый литерал), то итоговым типом будет number!!!</p>
                    <p>Реальный пример использования тернарного оператора:</p>
                    <pre>
type Example = 'string' extends 'Hello' ? string : number;

type FromUserOrFromBase&lt;T extends string | number&gt; = T extends string
    ? IDataFromUser
    : IDataFromBase;

interface IDataFromUser {
    weight: string;
}

interface IDataFromBase {
    calories: number;
}

const testDataFromBase: FromUserOrFromBase&lt;number&gt; = {
    calories: 500;
}

const testDataFromUser: FromUserOrFromBase&lt;string&gt; = {
    weight: '500';
}

interface SomeUser&lt;T extends 'created' | Date&gt; {
    created: T extends 'created' ? 'created' : Date;
}

const newUser: SomeUser&lt;'created'&gt; = {
    created: "created",
}

function calculateDailyCalories&lt;T extends string | number&gt;(numOrStr: T): T extends string ? IDataFromUser : IDataFromBase {
    if (typeof numOrStr === 'string'){
        const userObj: IDataFromUser = {
            weight: numOrStr,
        };
        return userObj as T extends string ? IDataFromUser : IDataFromBase;
    }
    else if(typeof numOrStr === 'number'){
        const baseObj: IDataFromBase = {
             calories: numOrStr,
        };
        return baseObj as T extends string ? IDataFromUser : IDataFromBase;
    }
}

console.log(calculateDailyCalories(500));
console.log(calculateDailyCalories('500'));
            </pre>
                    <p>Здесь мы проверяем какой будет тип аннотирован в T дженерике, если тип будет строкой, то в
                        условной
                        тернарной конструкции будет возвращен IDataFromUser интерфейс, если же числовой тип, то
                        IDataFromBase</p>
                    <p>Задача на собеседованиях, как сделать type с дженериком, который всегда будет возвращать массив
                        типов:</p>
                    <pre>
type ToArray&lt;Type&gt; = Type extends any ? Type[] : never;
type ExArray = ToArray&lt;string&gt; //Initial type: string[]
type ExArray2 = ToArray&lt;number&gt; //Initial type: number[]
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="mappedTypes">Сопоставление типов (mapped types)</h4>

                <div>
                    <p>Mapped types имеет следующий условный синтаксис:</p>
                    <pre>
// type СопоставимыйТип = {
    // [произвольныйИдентификатор in Множество] : ПроизвольныйТипДанных
// }

//example

type Keys = 'name' | 'age' | 'role';

type User3 = { //Initial type: {name: string, age: string, role: string}
    [key in Keys]: string
}

const Alex: User3 = {
    name: 'Alex',
    age: '30',
    role: 'admin'
}

type Currencies = {
    usa: 'usd';
    china: 'cny';
    ukraine: 'uah',
    kz: 'tenge';
}

//type ROnlyCurr = Readonly&lt;Currencies&gt;

type CreateCustomCurrencies&lt;T&gt; = {
    readonly [key in keyof T]?: string
}

// type CustomCurrencies = {
//     usa: string;
//     china: string;
//     ukraine: string,
//     kz: string;
// }

type CustomCurrencies = CreateCustomCurrencies&lt;Currencies&gt; //Initial type:
//{readonly usa?: string, readonly china?: string, readonly ukraine?: string, readonly kz?: string}
            </pre>
                    <p>Чтобы добавлять модификаторы или их убирать требуется перед модификаторами ставить + или -
                        соответственно:</p>
                    <pre>
type Currencies = {
    readonly usa?: 'usd';
    readonly china?: 'cny';
    readonly ukraine?: 'uah',
    readonly kz?: 'tenge';
}

type CreateCustomCurrencies&lt;T&gt; = {
    -readonly [key in keyof T]-?: string
}

type CustomCurrencies = CreateCustomCurrencies&lt;Currencies&gt; //Initial type: {usa: string, china: string, ukraine: string, kz: string}
            </pre>
                </div>
            </section>

            <section>
                <h4 id="templatesLiteralTypes">Шаблонные литеральные типы (Templates Literal Types)</h4>

                <div>
                    <p>Шаблонные литеральные типы работают +/- похоже как и шаблонные литеральные строки и основаны на
                        строковых литеральных типах:</p>

                    <pre>
type MyAnimation = 'fade';
type Direction = 'in' | 'out';
type MyNewAnimation = `${MyAnimation}${Capitalize&lt;Direction&gt;}`; //Initial type:"fadeIn" | "fadeOut" | "swipeIn" | "swipeOut"

type CreateCustomCurrencies1&lt;T&gt; = {
    -readonly [key in keyof T as `custom${Capitalize&lt;string & key&gt;}`]-?: string
}

type Currencies1 = {
    readonly usa?: 'usd';
    readonly china?: 'cny';
    readonly ukraine?: 'uah',
    readonly kz?: 'tenge';
}

type CustomCurrencies1 = CreateCustomCurrencies1&lt;Currencies1&gt; //Initial type: {customUsa: string, customChina: string, customUkraine: string, customKz: string}
            </pre>
                    <p>Дженерики <code>Uppercase&lt;&gt;, Lowercase&lt;&gt;, Capitalize&lt;&gt;,
                        Uncapitalize&lt;&gt;</code> преобразуют
                        строку в верхний регистр нижний регистр, делают первую букву заглавной или наоборот с малой.</p>
                </div>
            </section>

            <section>
                <h4 id="utilityTypes">Utility Types</h4>

                <div>
                    <p>Существуют следующие встроенные типы:</p>
                    <pre>
//Omit - исключение свойств типа
type CurrenciesWithoutUSA = Omit&lt;Currencies2, 'usa'&gt; // Initial type: {china: "cny", ukraine: "uah", kz: "tenge"}

//Pick - фильтрация по свойству
type CurrenciesUSAAndUkraine = Pick&lt;Currencies2, 'usa' | 'ukraine'&gt; // Initial type: {usa: "usd", ukraine: "uah"}

//Exclude - удаление из union type
type MyAnimation1 = 'fade' | 'swipe';
type FadeType = Exclude&lt;MyAnimation1, 'swipe'&gt; //Initial type: "fade"
type CountriesWithoutUSA = Exclude&lt;keyof Currencies2, 'usa'&gt; //Initial type: "china" | "ukraine" | "kz"

//Extract - извлекает тип подходящий по условию
type SwipeType = Extract&lt;MyAnimation1, 'swipe'&gt; //Initial type: "swipe"

//Record - позволяет сконструировать другой тип в формате ключ - значение
type Currencies2 = {
    usa: 'usd';
    china: 'cny';
    ukraine: 'uah',
    kz: 'tenge';
}
type PlayersNames = 'Alex' | 'John';
type CreateCustomCurrencies2&lt;T&gt; = {
    -readonly [key in keyof T as `custom${Capitalize&lt;string & key&gt;}`]-?: string
}

type CustomCurrencies2 = CreateCustomCurrencies2&lt;Currencies2&gt; //Initial type: {customUsa: string, customChina: string, customUkraine: string, customKz: string}
type GameDataCurrencies = Record&lt;PlayersNames, CustomCurrencies2&gt;

const gameData: GameDataCurrencies = {
    Alex: {
        customChina: 'qqqq',
        customUkraine: '1111',
        customUsa: '222',
        customKz: 'dadad'
    },
    John: {
        customKz: 'dawdawd',
        customUsa: 'davada',
        customUkraine: 'dawdawdac1',
        customChina: '141rfd2r4e1'
    }
}

ReturnType - позволяет вернуть тип из функции например
function calculate(a: number, b: number): number {
    return a*b;
}

type CalculateRT = ReturnType&lt;typeof calculate&gt; //Initial type: number
let anotherRes: CalculateRT = 5;

Parameters - позволяет вернуть тип аргументов функции
type calculatePT = Parameters&lt;typeof calculate&gt; //Initial type: [number, number]
type calculateFirstPT = Parameters&lt;typeof calculate&gt;[0]; //Initial type: number

ConstructorParameters - позволяет извлечь типы из аргументов конструктора класса

class Example3 {
    constructor(a: number) {
    }
}

type ConstructorParams = ConstructorParameters&lt;typeof Example3&gt; //Initial type: [number]

//для того чтобы "вытащить" тип из промиса используется дженерик Awaited:
interface AwaitedUser {
    name: string;
}

async function fetchUsers(): Promise&lt;AwaitedUser[]&gt;{
    const users: AwaitedUser[] = [
        {
            name: "Alex"
        }
    ]
    return users;
}

const users = fetchUsers();

type FetchUsersReturnType = Awaited&lt;ReturnType&lt;typeof fetchUsers&gt;&gt; //Initial type: AwaitedUser[]

//до введения данного дженерика это действие выглядело вот так:
type UnwrappedPromise&lt;T&gt; = T extends Promise&lt;infer Return&gt; ? Return : T;
type FetchDataReturnType = UnwrappedPromise&lt;ReturnType&lt;typeof fetchUsers&gt;&gt; //Initial type: AwaitedUser[]
            </pre>
                    <p><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank">
                        Здесь можно посмотреть список всех встроенных типов.</a></p>
                </div>
            </section>

            <section>
                <h4 id="TSFetchAndPromise">TS, Fetch и Promise</h4>

                <div>
                    <p>Для того чтобы работать с fetch запросами и соответственно с json строкой нужно пользоваться
                        защитой типов при присваивании переменным уже сформированный из json'a объект:</p>
                    <pre>
interface Todos {
    userId: number;
    id: number;
    title: string;
    completed: boolean;
}

let toDoList: Todos[] = [];

function isToDos(json: Todos[]): json is Todos[] {
    return json.every(json => {
        return 'userId' in json && 'id' in json && 'title' in json && 'completed' in json;
    })
}

fetch('https://jsonplaceholder.typicode.com/todos').then(res => res.json()).then(data => {
    if (isToDos(data)){
        toDoList = [...data];
    }
    console.log(toDoList)
})
            </pre>

                    <p>При создании же промисов, сам Promise можно использовать как дженерик:</p>
                    <pre>
const proms = new Promise&lt;string&gt;((resolve,reject) => {
    resolve('test');
})

proms.then(val => console.log(val.toUpperCase()));
            </pre>
                </div>
            </section>

            <section>
                <h4 id="inheritanceVSComposition">Inheritance vs Composition</h4>

                <div>
                    <p>Inheritance:</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/inheritanceInTS.png" alt="inheritanceInTS">
                    </div>
                    <p>Inheritance - характеризуется при помощи отношения "это" между двумя классами. Т.е. класс
                        MatchReader
                        это CsvFileReader.</p>
                    <p>Composition:</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/compositionInTS.png" alt="compositionInTS">
                    </div>
                    <p>Composition - характеризуется при помощи отношения "имеет" между двумя классами. Т.е. класс
                        MatchReader имеет ссылку на объект класса CsvFileReader/ApiReader</p>
                </div>
            </section>

            <section>
                <h4 id="staticMethodsAndProperties">Статические методы и свойства(static)</h4>

                <div>
                    <p>Cтатические методы используются для реализации функций, которые будут принадлежать классу в
                        целом, но
                        не какому-либо его конкретному объекту.</p>
                    <p>Статические методы недоступны для отдельных объектов энного класса, только для самого класса!</p>
                    <pre>
class Article {
   constructor(title, date) {
     this.title = title;
     this.date = date;
   }

   static compare(articleA, articleB) {
     return articleA.date - articleB.date;
   }
}

// использование
let articles = [
   new Article("HTML", new Date(2019, 1, 1)),
   new Article("CSS", new Date(2019, 0, 1)),
   new Article("JavaScript", new Date(2019, 11, 1))
];

articles.sort(Article.compare);

alert( articles[0].title ); // CSS
            </pre>
                    <p>Статические свойства также возможны, они выглядят как свойства класса, но с static в начале:</p>
                    <pre>
class Article {
   static publisher = "Илья Кантор";
}

alert( Article.publisher ); // Илья Кантор
            </pre>
                    <p>Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне
                        класса, а не какого-то одного объекта.</p>
                </div>
            </section>

            <section>
                <h4 id="TSWithJSLibraries">TS с JS библиотеками</h4>

                <div>
                    <p>Т.к. большинство библиотек было написано еще до введения классов и соответственно формирования
                        представления о типах, то существует проблема внедрения TS в эти библиотеки. При работе с TS и
                        некой
                        библиотекой есть несколько подходов:</p>
                    <ul>
                        <li>Использование библиотеки, как обычно, добавляя, где возможно, базовые аннотации типов</li>
                        <li>Использование библиотеки TS adapter, в которой есть помощники для использования нужной
                            библиотеки с TS
                        </li>
                        <li>Рефактор библиотеки для работы с классами TS</li>
                    </ul>

                    <p>При совместной работе TS и требуемой библиотеки должен быть один из двух результатов:</p>
                    <ul>
                        <li>Повышение безопасности типов(помочь TS лучше выявлять ошибки)</li>
                        <li>Значительно улучшить процесс разработки</li>
                    </ul>
                </div>
            </section>

            <section>
                <h4 id="ES2015ClassesInTS">Классы в ES2015 и TS</h4>

                <div>
                    <p>На самом деле классы как таковые не существуют в JavaScript, классы в JS - это синтаксический
                        сахар
                        при помощи прототипного наследования.</p>
                    <p>Это объясняется следующими примерами, где использован синтаксис EcmaScript 2005 года(когда
                        синтаксиса
                        классов еще не было и использовались прототипы):</p>
                    <pre>
//синтаксис классов в ES5
var Car = /** @class */ (function () {
    function Car() {
        this.color = 'red';
    }
    Car.prototype.drive = function () {
        console.log('Im driving');
    };
    return Car;
}());

new Car().drive(); // -> Im driving

// так же метод в классах можно создать когда объект класса уже был инициализирован.
const carWithoutBrake = new Car();
carWithoutBrake.stop(); // -> error: carWithoutBrake.stop() is not a function

Car.prototype.stop = function() {
   console.log('I have stopped')
}
carWithoutBrake.stop(); // -> I have stopped
                    </pre>
                    <p>и синтаксис 2015 года(когда добавили синтаксис классов):</p>
                    <pre>
class Car {
   color: string = 'red';
   drive(): void {
    console.log('im driving')
   }
}

// синтаксис вызова класса один и тот же что в ES5, что в ES2015
new Car().drive(); // -> im driving
                    </pre>
                    <p>Когда мы вызываем различные методы для объекта энного класса, прежде всего мы обращаемся к
                        прототипу
                        этого класса, в котором уже задекларированы методы</p>
                </div>
            </section>

            <section>
                <h4 id="setAnGetInTS">Сеттеры и геттеры в TS</h4>

                <div>
                    <p>сеттеры и геттеры имеют следующий синтаксис</p>
                    <pre>
class Box {
    width!: number;
    volume!: number | undefined;
    private _content!: string | undefined; // если нет модификатора private, но есть "_" то обращаться к данной переменной вне класса так же запрещено!!!

    constructor(width: number , public height: number, volume?: number, content?: string) {
        this.width = width;
        this.volume = volume;
        this._content = content;
    }

    calcVol(): void{
        if (this.volume){
            console.log(`Объем посылки: ${this.volume}`)
        } else {
            if (typeof this.width === 'number'){
                this.volume = this.width * this.height;
                console.log(`Объем посылки: ${this.volume}`)
            }
        }
    }

    checkBpxSize(transport: number | number[]): string {
        if (typeof transport === "number"){
            return transport >= this.width ? 'Ok' : 'Not Ok';
        } else {
            return transport.some(tr => tr >= this.width) ? 'Ok' : 'Not Ok'
        }
    }

    get content(){
        return this._content;
    }

    set content(val){
        this._content = `Date: ${new Date().toTimeString()}, Content: ${val}`;
    }


    //в случае если же нужна асинхронная операция, то set и get не могут с ними работать,
    //нужно использовать обычный асинхронный метод
    async asyncContent(val: string){
        const date = await new Date().toTimeString();
        this._content = `Date: ${date}, Content: ${val}`;
    }
}

const firstBox = new Box(500, 500);
firstBox.calcVol();
console.log(firstBox.checkBpxSize([300, 350,400,500]));
firstBox.content = 'test';
console.log(firstBox.content);
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="indexClassSignaturesInTS">Индексные сигнатуры классов в TS</h4>

                <p>Для того чтобы создавать свойства в уже созданном объекте энного класса, требуется использовать
                    индексные
                    сигнатуры:</p>
                <pre>
class Styles {
    [s: string]: string;
}

const style = new Styles();
style.color = 'red';
style.width = '500 px';
style.height = '500 px';

console.log(style); // Styles { color: 'red', width: '500 px', height: '500 px' };
                </pre>
                <p>НО!!! у данного метода есть недостаток - невозможно потом объявлять функции не аннотируя их в
                    индексной
                    сигнатуре:</p>
                <pre>
class Styles {
    [s: string]: string | ((number: number) => number);

    method(number: number): number {
        return number;
    }
}
                </pre>
            </section>

            <section>
                <h4 id="classInheritanceInTS">Наследование классов в TS и перезапись свойств и методов потомков</h4>

                <div>
                    <p>Наследование свойств классов в TS имеет аналогичный синтаксис JS, однако для методов существует
                        модификатор override, который следит за тем чтобы в родительском классе есть метод с таким же
                        названием, при этом можно так же с помощью super.parentsMethod() (parentsMethod - родительский
                        метод)
                        вызывать старую версию метода например при каком-то условии:</p>
                    <pre>
class PresentBox extends Box {
    wrap!: string;
    height: number = 600; // свойства перезаписываются новой декларацией.

    constructor(wrap: string, width: number, height?: number,volume?: number, content?: string) {
        super(width,height, volume, content ); // super - вызов конструктора родителя!

        this.wrap = wrap;
    }

    override async asyncContent(val: string, text?: string) {
        const date = await new Date().toTimeString();
        if (!text){
           await super.asyncContent(val); //вызов родительского метода в случае если text отсутствует
        } else {
            this._content = `Date: ${date}, Content: ${val}, Text: ${text ? text : "no text"}`;
        }
        console.log(this._content)
    }
}

const presentBox = new PresentBox('red', 500);
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="classInterfaces">Интерфейсы для классов(имплементация интерфейсов)</h4>

                <div>
                    <p>Для чтобы определить свойства у класса, в него имплементируют интерфейс:</p>
                    <pre>
interface IUser {
    login: string;
    password: string;
}

interface IValidation {
    valid: boolean;
    isValid: (data: string) => boolean;
}

class UserForm implements IUser {
    login!: string;
    password!: string;
    isValid: boolean = false;

    isValid(login: string): boolean { //расширение типа аргумента возможно!
        return login.length > 3;
    }
}
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="contextInClass">Контекст вызова в классе(this)</h4>

                <div>
                    <p>Когда мы в классе ссылаемся на this, то отсылка идет на свойство будущего экземпляра данного
                        класса</p>
                    <pre>
const setName = (): string => {
    return "COD";
}

class Player {
    private static game: string = "COD";
    #login!: string;
    private _password!: string;
    public server!: string;
    protected consent!: boolean;

    static {
        Player.game = setName();
    }

    constructor(login: string) {
        this.#login = login;
    }

    get password(){
        return this._password;
    }

    set password(pas: string){
        //validation
        this._password = pas;
    }

    static getGameName(): string{
        return Player.game;
    }

    logIn = () => {
        return `Player ${this.#login} online`
    }

    // logIn(this: Player) { // таким образом мы аннотируем каким должен быть this при вызове метода в инстансе класса
    //     return `Player ${this.#login} online`
    // }

    connect() {
        //Do smth
        return this;
    }

    isPro(): this is CompetitivePlayer{
        return this instanceof CompetitivePlayer;
    }


}

class CompetitivePlayer extends Player{
    rank!: number;

    constructor(login: string, consent: boolean) {
        super(login);
        this.consent = consent;
    }

    isConsented(){
        return this.consent ? 'yes' : 'no'
    }

    checkLogin(){
        return this.logIn(); // ВАЖНО!!! методы прописанные стрелочной функцией отсутствуют в прототипе!
        //поэтому к ним невозможно обратиться с помощью super
    }
}

const player = new Player('abrwalg');

player.password = '125zqu';
console.log(player.logIn());
console.log(player.connect().logIn()); // chaining
const test = player.logIn; //тк logIn - стрелочная функция то bind(player) не нужен!
//const test = player.logIn.bind(player); // в случае если метод класса ligIn объявляется не стрелочной функцией!!!!!!
                                          // тк при присваивании вызова данного метода в таком случае теряется контекст
console.log(test());
console.log(player.isPro()); // false

const comPlayer = new CompetitivePlayer('abrwalgCompet', true);
comPlayer.password = '125zqu';
console.log(comPlayer.isConsented());
console.log(comPlayer.checkLogin());
console.log(comPlayer.isPro()); // true
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="decoratorsWithTS">Декораторы в TypeScript</h4>

                <div>
                    <p>Decorators:</p>
                    <ul>
                        <li>Функции, которые можно использовать для модификации / изменения различных свойств или
                            методов в
                            классе
                        </li>
                        <li>Не то же самое, что декораторы в JS</li>
                        <li>Используются только с классами</li>
                        <li>Понимание порядка, в котором запускаются декораторы, является ключом к их общему пониманию
                        </li>
                        <li>Экспериментальная фича</li>
                    </ul>

                    <p>Пример декоратора:</p>
                    <pre>
class DecoratedCar {
   color: string = 'red';

   get formattedColor(): string {
      return `This color is ${this.color}`
   }

   @logError
   @testDecorator
   drive(): void {
      console.log("I'm driving");
   }
}

function testDecorator(target: any, key: string): void {
   console.log('Target', target); // Target { drive: [Function (anonymous)] }
   console.log('Key', key); // Key drive
}


function logError(target: any, key: string, descriptor: PropertyDescriptor): void {
   const method = descriptor.value;

   descriptor.value = function () {
       try {
           method();
       } catch (err){
           console.log('The car is crashed')
       }
   }
}

const someCar = new DecoratedCar();
someCar.drive(); // The car is crashed

//декораторы классов(курс Петриченко)
interface ICar {
    fuel: string;
    open: boolean;
    freeSeats: number;
    isOpenAndFuel: () => string;
}

function closeCarDec&lt;T extends {new (...args: any[]): {}}&gt;(constructor: T) {
    //constructor.prototype.fuel = '100%' не изменяет свойство тк конструктор перезаписывает его!
    //constructor.prototype.open = false; не изменяет свойство тк конструктор перезаписывает его!
    return class extends constructor {
        fuel = '100%';
        open = false;
    }
}

@closeCarDec
class MyCar implements ICar{
    fuel: string = '50%';
    open: boolean = true;
    freeSeats: number = 3;
    isOpenAndFuel() {
        return `${this.open} and ${this.fuel}`;
    }
}

const newCar = new MyCar();
//console.log(closeCar(addFuel(newCar).isOpenAndFuel())); //addFuel / close car / MyCar { fuel: '100%', open: false, freeSeats: 3 }
console.log(newCar.isOpenAndFuel()); //false and 100%
                    </pre>
                    <p>Где target/constructor - прототип декорируемого класса DecoratedCar, key - ключ свойства / метода
                        /
                        аксессора к объекту(в нашем случае drive). Так же существует третий аргумент - дескриптор
                        свойства(PropertyDescriptor - объект, который имеет конфигурационные опции о свойстве
                        определенном
                        для
                        объекта). Декораторы применяются при запуске кода для этого класса(а не при создании экземпляра
                        класса)</p>

                    <table class="jsTheoryTable">
                        <caption>PropertyDescriptor для методов:</caption>
                        <thead>
                        <tr>
                            <th>свойство</th>
                            <th>описание</th>
                        </tr>
                        </thead>
                        <tbody>
                        <tr>
                            <td>writable:</td>
                            <td>Можно ли изменить это свойство</td>
                        </tr>
                        <tr>
                            <td>enumerable:</td>
                            <td>Можно ли итерировать это свойство при помощи цикла(for...in)</td>
                        </tr>
                        <tr>
                            <td>value:</td>
                            <td>Текущее значение</td>
                        </tr>
                        <tr>
                            <td>configurable:</td>
                            <td>Определение свойства можно изменить и свойство можно удалить</td>
                        </tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <section>
                <h4 id="decoratorFactory">Decorator Factory (Фабрика декораторов)</h4>

                <div>
                    <p>Чтобы декоратор работал с конфигурационными параметрами нужно обернуть его в функцию, которая
                        будет возвращать сам декоратор, данный подход называется фабрикой декораторов:</p>
                    <pre>
class DecoratedCar {
   color: string = 'red';

   get formattedColor(): string {
      return `This color is ${this.color}`
   }

   @logError('The car is crashed')
   drive(): void {
      throw new Error();
      console.log("I'm driving");
   }
}

function logError(errorMessage: string) {
   return function (target: any, key: string, descriptor: PropertyDescriptor): void {
      const method = descriptor.value;

      descriptor.value = function () {
         try {
            method();
         } catch (err) {
            console.log(errorMessage)
         }
      }
   }
}

const someCar = new DecoratedCar();
someCar.drive();

//petrechenkos example

function changeAmountOfFuel(amount: number){
    console.log('fuel init');  // в консоли будет 1м месте
    return &lt;T extends { new(...args: any[]): {} }&gt;(constructor: T) => {
        console.log('fuel changed'); // в консоли будет на 4м месте
        return class extends constructor {
            fuel = `${amount}%`;
        }
    }
}

function changeDoorStatus(status: boolean) {
    console.log('door init'); // в консоли будет 2м месте
    return &lt;T extends { new(...args: any[]): {} }&gt;(constructor: T) => {
        console.log('door changed'); // в консоли будет 3м месте
        return class extends constructor {
            open = status;
        }
    }
}

@changeAmountOfFuel(75)
@changeDoorStatus(false) // цепочка вызова декораторов
class MyCar implements ICar{
    fuel: string = '50%';
    open: boolean = true;
    freeSeats: number = 3;
    isOpenAndFuel() {
    return `${this.open} and ${this.fuel}`;
    }
}

const newCar = new MyCar();
console.log(newCar.isOpenAndFuel()); //false and 75%
                    </pre>
                    <p>Порядок вызова функций от нижнего декоратора к верхнему, т.е. сначала сработает changeDoorStatus
                        тк
                        он ближе к декорируемому классу, а потом changeAmountOfFuel!!! Суть +- та же что и в декораторах
                        JS(первыми срабатывают те что вложены в функцию). НО инициализация функций происходит по порядку
                        следования кода!!! Т.е. инициализируются функции от первой к последней, а срабатывают от
                        последней
                        к первой по позициям в коде</p>
                </div>
            </section>

            <section>
                <h4 id="ESDecorators">ES декораторы из версии 5+, ES декораторы классов.</h4>

                <div>
                    <p>Тема требует разбора!</p>
                </div>
            </section>

            <section>
                <h4 id="methodsDecoratorsAndThis">Декораторы методов класса и работа с this</h4>

                <div>
                    <p>Чтобы создавать декораторы для методов класса нужно использовать три параметра: target - который
                        указывает на декорируемый объект, propertyKey - название метода и descriptor - объект
                        дескриптора,
                        соответствующий методу, для которого вызывается декоратор.</p>
                    <pre>
function changeAmountOfFuel(amount: number){
    console.log('fuel init')
    return &lt;T extends { new(...args: any[]): {} }&gt;(target: T) => {
        console.log('fuel changed');
        return class extends target {
            fuel = `${amount}%`;
        }
    }
}

function changeDoorStatus(status: boolean) {
    console.log('door init')
    return &lt;T extends { new(...args: any[]): {} }&gt;(target: T) => {
        console.log('door changed');
        return class extends target {
            open = status;
        }
    }
}

function checkAmountOfFuel(target: Object,propertyKey: string | symbol, descriptor: PropertyDescriptor): PropertyDescriptor | void{
    const isOpenAndFuelFunction = descriptor.value;
    descriptor.value = function(this: any, ...args: any[]) {
        return `${isOpenAndFuelFunction.apply(this, args)}, fuel amount: ${this.fuel}`; //функционал старого метода класса и добавление нового функционала
    }
}

//@closeCarDec
@changeAmountOfFuel(75)
@changeDoorStatus(false)
class MyCar implements ICar{
    fuel: string = '50%';
    open: boolean = true;
    freeSeats: number = 3;

    @checkAmountOfFuel
    isOpenAndFuel(value: string) {
        return `isOpen?: ${this.open} ${value}`;
    }
}
const newCar = new MyCar();
console.log(newCar.isOpenAndFuel('checked')); //isOpen?: false checked, fuel amount: 75%
                    </pre>
                    <p>Чтобы старый фукционал метода работал, необходимо создать новую переменную которой нужно
                        присвоить
                        descriptor.value где собственно и хранится ссылка на старый метод, и вызвать ее в теле новой
                        функции, но тк в старом методе могут содержаться контексты this иногда требуется привязать
                        контекст
                        к переменной с ссылкой через apply(this)</p>
                    <p>Так же в декорируемом методе могут быть аргументы, и для этого в функции требуется задать второй
                        параметр
                        где мы разворачиваем блок возможных переменных ...args: any[] и используем args в переменной со
                        ссылкой
                        на старый метод вторым аргументом после this</p>
                </div>
            </section>

            <section>
                <h4 id="decoratorsAndClassProperties">Декораторы и свойства класса</h4>

                <div>
                    <p>Мы можем получить через декоратор доступ к названию свойства, но к его содержимому получить
                        доступ
                        уже не можем, тк декоратор запускается до создания объекта данного класса.</p>
                </div>
            </section>

            <section>
                <h4 id="argumentsDecorators">Декораторы аргументов методов класса и декораторы самого класса</h4>

                <div>
                    <p>Декораторы можно использовать как для самого класса, как для аргументов метода этого класса, так
                        и
                        для статических методов:</p>
                    <pre>
@classDecorator
class DecoratedCar {
    color: string = 'red';

    get formattedColor(): string {
        return `This color is ${this.color}`
    }

    @logError('The car is crashed')
    drive(@propsDecorator speed: string): void {
        //throw new Error();
        if (speed === 'fast'){
            console.log("I'm driving fast")
        } else {
            console.log("I'm driving");
        }
    }
}

function classDecorator(constructor: typeof DecoratedCar | Function) {
    console.log(constructor);
}

function propsDecorator(target: any, key: string, index: number) {
    console.log(key, index);
}

function logError(errorMessage: string) {
    return function (target: any, key: string, descriptor: PropertyDescriptor): void {
        const method = descriptor.value;

        descriptor.value = function () {
            try {
                method();
            } catch (err) {
                console.log(errorMessage)
            }
        }
    }
}

const someCar = new DecoratedCar();
someCar.drive('fast');
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="propertiesDecorators">Декораторы свойств класса</h4>

                <div>
                    <p>Декораторы свойств работают по принципу set | get, мы в ручную создаем setter и getter с
                        аналогичным
                        функционалом в декораторе и с помощью Object.defineProperty заменяем set на setter и get на
                        getter:</p>
                    <pre>
function checkNumberOfSeats(limit: number){
    return function (target: Object, propertyKey: string | symbol){
        let value: number;
        const getter = function (){
            return value;
        }
        const setter = function (newAmount: number) {
            if (newAmount &gt;= 1 && newAmount &lt; limit){
                value = newAmount;
            } else {
                //console.log(`Больше ${limit} сидений быть не может`);
                Object.defineProperty(target, 'errors', {
                    value: `Больше ${limit} сидений быть не может`,
                })
            }
        }

        Object.defineProperty(target, propertyKey, {
            get: getter,
            set: setter,
        })
    }
}

@changeAmountOfFuel(75)
@changeDoorStatus(false)
class MyCar implements ICar{
    fuel: string = '50%';
    open: boolean = true;

    @checkNumberOfSeats(4)
    freeSeats!: number;

    @checkAmountOfFuel
    isOpenAndFuel(value: string) {
        return `isOpen?: ${this.open} ${value}`;
    }
}

const newCar = new MyCar();
newCar.freeSeats = 3;
console.log(newCar.freeSeats)
                    </pre>
                    <p>При создании декоратора так же используется фабрика декораторов, но только с двумя аргумента
                        аргументами - target: Object, propertyKey: string | symbol</p>
                </div>
            </section>

            <section>
                <h4 id="accessorsDecorators">Декоратор аксесоров класса</h4>

                <div>
                    <p>Декораторы аксесоров похожи на декораторы методов, но вместо descriptor.value используется
                        descriptor.set и descriptor.get изменяя соответственно сеттер и геттер класса. Декорировать @
                        можно как set так и get, но одновременно применять нельзя.</p>
                    <pre>
function logAddWeight(
    target: Object,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor
): PropertyDescriptor | void {
    const oldFunction = descriptor.set;
    const oldGet = descriptor.get;

    descriptor.set = function (this: any, ...args: any){
        console.log(`Изменяем значения на ${[...args]}`)
        return oldFunction?.apply(this, args)
    }

    descriptor.get = function () {
        console.log('some text');
        return oldGet?.apply(this)
    }
}

@changeAmountOfFuel(75)
@changeDoorStatus(false)
class MyCar implements ICar{
    fuel: string = '50%';
    open: boolean = true;
    _weight1: number = 1000;

    @logAddWeight
    set weight1(weight: number){
        this._weight1 = this._weight1 + weight;
    }

    get weight1(){
        return this._weight1;
    }

    @checkNumberOfSeats(4)
    freeSeats!: number;

    @checkAmountOfFuel
    isOpenAndFuel(value: string) {
        return `isOpen?: ${this.open} ${value}`;
    }
}

newCar.freeSeats = 3;//Изменяем значения на 300
console.log(newCar.weight1);//some text //1300
console.log(newCar); //MyCar { fuel: '75%', open: false, _weight1: 1300 }
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="parameterDecorators">Декораторы параметров</h4>

                <div>
                    <p>Декораторы параметров класса применяются прежде всего для их валидации. Для работы с параметрами
                        методов
                        класса нужно использовать библиотеку
                        <a href="https://github.com/rbuckton/reflect-metadata?ysclid=lnksrp3jye581655524"
                           target="_blank">Metadata
                            Reflection API</a>, для того чтобы через метадату настраивать функционал. Так же нужно
                        декорировать
                        как метод, так и параметры этого метода:</p>
                    <pre>
import 'reflect-metadata';
const limitMetaDataKey = Symbol('limit');

function passengersLimit(
    target: Object,
    propertyKey: string | symbol,
    parameterIndex: number,
){
    // console.log(Reflect.getOwnMetadata('design:type', target, propertyKey));
    // console.log(Reflect.getOwnMetadata('design:paramtypes', target, propertyKey));
    // console.log(Reflect.getOwnMetadata('design:returntype', target, propertyKey));

    let limitedParams: number[] = Reflect.getOwnMetadata(limitMetaDataKey, target, propertyKey) || [];
    limitedParams.push(parameterIndex);
    Reflect.defineMetadata(limitMetaDataKey, limitedParams, target, propertyKey);
}

function validateLimits(
    target: Object,
    propertyKey: string | symbol,
    descriptor: PropertyDescriptor,
): PropertyDescriptor | void {
    let method = descriptor.value;
    descriptor.value = function (...args: any) {
        let limitedParams: number[] = Reflect.getOwnMetadata(limitMetaDataKey, target, propertyKey);
        if (limitedParams) {
            for (let index of limitedParams){
                if (args[index] > 4){
                    throw new Error('Нельзя посадить больше 4х пассажиров')
                }
            }
        }

        return method?.apply(this, args);
    }
}

//@changeAmountOfFuel(75)
//@changeDoorStatus(false)
class MyCar implements ICar{
    fuel: string = '50%';
    open: boolean = true;
    _weight1: number = 1000;

    //@logAddWeight
    set weight1(weight: number){
        this._weight1 = this._weight1 + weight;
    }

    get weight1(): number {
        return this._weight1;
    }

    //@checkNumberOfSeats(4)
    freeSeats!: number;

    //@checkAmountOfFuel
    isOpenAndFuel(value: string) {
        return `isOpen?: ${this.open} ${value}`;
    }

    @validateLimits
    startTravel(@passengersLimit passengers: number){
        console.log(`Started with ${passengers} passengers`)
    }
}
const newCar = new MyCar();
newCar.startTravel(3); // Started with 3 passengers
newCar.startTravel(5); // error
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="decoratorsOrder">Порядок выполнения всех типов декораторов</h4>

                <div>
                    <p>Порядок выполнения декораторов имеет следующую последовательность:</p>
                    <ol>
                        <li>Декораторы параметров, за которыми следуют декораторы методов, аксессоров или свойств,
                            применяемые для каждого члена экземпляра.
                        </li>
                        <li>Декораторы параметров, за которыми следуют декораторы методов, аксессоров или свойств,
                            применяемые для каждого статического члена.
                        </li>
                        <li>Декораторы параметров применяемые для конструктора.</li>
                        <li>Декораторы класса применяемые к классу.</li>
                    </ol>
                </div>
            </section>

            <section>
                <h4 id="typeUnion">Type union(Объединение типов)</h4>

                <div>
                    <p>В случае если какой либо аргумент будет принимать различные объекты с различными
                        типами/интерфейсами - используют объединение типов:</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/typeUnion.png" alt="typeUnion">
                    </div>
                    <p>Где Action это тип в который мы поместили все возможные типы action применяемые в редьюсере.</p>
                </div>
            </section>

            <section>
                <h4 id="typeIntersection">Пересечение типов(intersection)</h4>

                <div>
                    <p>Пересечение типов позволяет использовать сразу несколько типов:</p>
                    <pre>
interface ServerConfiguration {
   protocol: 'http' | 'https';
   port: 3000 | 3001;
}

interface Role {
   role: 'admin' | 'sysadmin';
}

//type ServerConfigurationWithRole = ServerConfiguration & Role;
interface ServerConfigurationWithRole extends ServerConfiguration, Role{
   test: string;
}

const serverConfig: ServerConfigurationWithRole = {
   protocol: 'https',
   port: 3001,
   role: 'admin',
   test: 'some test'
}

const backupConfig: ServerConfigurationWithRole = {
   protocol: "http",
   port: 3000,
   role: 'sysadmin',
   test: 'some test'
}
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="reactWithRedux1">React при работе с TypeScript [1]</h4>

                <div>
                    <p>Для того чтобы типизировать функциональные компоненты, используют FC тип(function component).</p>
                    <p>В случае если нам требуется затипизировать props, то нужно создать type alias, который мы будем
                        передавать как дженерик в FC.</p>
                    <p>в случае если нам нужно запретить передачу children при последующем использовании компонентов, то
                        нужно просто не передавать его в наш type alias, и обратно если нужно.</p>
                    <p>В случае если мы хотим стилизовать некий элемент, и нам требуется взять некие стили из props, мы
                        так же можем их типизировать.</p>
                    <pre>
import React from "react";

type TodoItemProps = {
    id: string;
    title: string;
    completed: boolean;
    children?: React.ReactNode; // в случае если children не нужен, то просто удалить из type alias
    style?: React.CSSProperties;
}

const TodoItem: React.FC&lt;TodoItemProps&gt; = ({id, title, completed, children, style}) => {
    return (
        &lt;ul&gt;
            &lt;li style={{color: "red", background: "white", ...style}}&gt;
                &lt;input type="checkbox" checked={completed}/&gt;
            &lt;/li&gt;
            &lt;span&gt;{title}&lt;/span&gt;
            &lt;span&gt;&times;&lt;/span&gt;
            &lt;span&gt;{children}&lt;/span&gt;
        &lt;/ul&gt;
    )
}

TodoItem.defaultProps = {
    id: 'default id',
    title: 'default title',
    completed: false,
}

export default TodoItem;
                    </pre>
                    <p>В случае если нам нужен доступ к дефолтным props, то нужно типизировать саму функцию как в
                        примере
                        выше,
                        если это не требуется, то вместо нее можно типизировать блок аргументов с props</p>
                    <pre>
const TodoItem = ({id, title, completed, children, style}: TodoItemProps) => {
   ...
}
                    </pre>

                    <p>Когда мы работаем с useState, и передаем в него примитивные типы, то можно полагаться на вывод
                        типов(type inference), вывод типов отлично справится с контролем ошибок, в случае если же
                        передаем НЕ
                        примитивные типы, массивы объекты и тд, то useState&lt;T&gt; можно использовать как дженерик,
                        где
                        вместо T мы подставим свой type alias или напрямую аннотируем тип(например &lt;string[]&gt;.
                        [1]</p>

                    <p>В случае если мы работаем с хендлерами и их ивентами, то нам нужно их типизировать следующим
                        образом:
                        [2]</p>
                    <p>Тип хендлера можно узнать из описания onChange(или другого примененного атрибута, например
                        onClick).
                        [3]</p>
                    <p>При работе с useEffect в котором мы делаем запрос на сервер и ожидаем некий ответ от него, мы
                        можем
                        столкнуться с проблемой типа "any" ибо парсинг JSON объекта всегда возвращает неопределенный
                        объект.
                        Для решения данной проблемы мы можем создать type guard который будет сверять свойства в объекте
                        и в
                        случае если распаршеный объект соответствует нашему интерфейсу, мы можем выполнять с ним
                        какое-то
                        действие. [4]</p>
                    <p>В случае если мы используем useRef, то нам нужно задать ему дженерик в который мы поместим тот
                        HTML
                        элемент, к которому относится наш useRef, а при работе с .current.value нам нужно проверить сам
                        Ref
                        на наличие. [5]</p>

                    <pre>
//NewTodoForm React Component

interface NewTodoFormProps {
    //value: string;
    //onChange: (event: React.ChangeEvent&lt;HTMLInputElement&gt;) => void; //[2] //React.ChangeEventHandler&lt;HTMLInputElement&gt;
    clickHandler: (text: string) => void;
    //clickHandler: () => void; // [2]
}

const NewTodoForm = ({value, onChange, clickHandler }: NewTodoFormProps) => {
    const inputRef = useRef&lt;HTMLInputElement&gt;(null); //[5]

    const onClick = () => {
        if (inputRef.current){ //[5]
            clickHandler(inputRef.current.value)
        }
    }

    return (
        &lt;&gt;
            &lt;input
                type="text"
                placeholder='new todo'
                //value={value}
                //onChange={onChange} //[3] - React.InputHTMLAttributes&lt;T&gt;.onChange?: React.ChangeEventHandler&lt;HTMLInputElement&gt; | undefined
                ref={inputRef}
            /&gt;
            &lt;button onClick={onClick /*clickHandler*/}>Add todo&lt;/button&gt;
        &lt;/&gt;
    )
}

export default NewTodoForm;

//----------------------------------------------------------------------------//

//App React Component

import React, {useState} from 'react';

import './App.css';
import TodoItem from "./components/TodoItem";
import NewTodoForm from "./components/NewTodoForm";

type ITodo = {
    id: string;
    title: string;
    completed: boolean;
}

function App() {
    //const [text, setText] = useState(''); //[1]
    const [todos, setTodos] = useState&lt;ITodo[]&gt;([]); //[1]; если не типизировать дженерик то будет never[]

    //const inputChangeHandler = (event: React.ChangeEvent&lt;HTMLInputElement>) => {
    //    setText(event.target.value)
    //}

    const addTodoHandler = (text: string) =&gt; { // const addTodoHandler = () => {...}; если не используем useRef
        const newTodo: ITodo = {
            id: new Date().toLocaleString(),
            title: text,
            completed: false,
        }

        setTodos([newTodo, ...todos]);
        //setText('');
    }

    const dataIsTodo = (data: Todo[]): data is Todo[] => { //[4]
        return data.every(todo => {
            return 'id' in todo && 'title' in todo && 'completed' in todo;
        });
    }

    useEffect(() => { //[4]
        fetch('https://jsonplaceholder.typicode.com/todos')
            .then(res => res.json())
            .then((data: Todo[]) => {
                if (dataIsTodo(data)){
                    setTodos(data)
                } else {
                    throw new Error('Data is not Todo List')
                }
            })
    }, [])

    return (
      &lt;div className="App"&gt;
          &lt;NewTodoForm
                  //value={text}
                  //onChange={inputChangeHandler}
                  clickHandler={addTodoHandler}
          /&gt;
          &lt;TodoItem id={'qwerty'} title={'someTodo'} completed={false} style={{border: '1px solid white',}}&gt;Some children title&lt;/TodoItem&gt;
      &lt;/div&gt;
    );
}

export default App;
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="reactWithRedux2">React+Redux при работе с TypeScript [2]</h4>

                <div>
                    <p>Плюсы:</p>
                    <ul>
                        <li>Намного проще избежать очень распространенных опечаток, таких как неправильные типы action
                        </li>
                        <li>Дает разработчикам лучшее понимание типов передаваемых данных</li>
                        <li>Намного проще делать рефакторинг</li>
                    </ul>
                    <p>Минусы:</p>
                    <ul>
                        <li>Не самые лучшие файлы определения типа(особенно для Redux)</li>
                        <li>Огромное количество Generics</li>
                        <li>Очень много импортов, т.к. почти всё(action creator, action, reducer, store, component)
                            должно
                            знать
                            о разных типах
                        </li>
                        <li>Redux по своей сути функциональный и его трудно интегрировать с классами TS</li>
                    </ul>

                    <p>Для того, чтобы работать с props и state в КЛАССОВЫХ компонентах React, нужно
                        наследовать(extends)
                        наш классовый компонент от дженерика React.Component&lt;propArg, stateArg&gt;, где propArg это
                        интерфейс описывающий типы props, а stateArg это интерфейс описывающий типы состояний:</p>
                    <pre>
import React from "react";
import ReactDOM from "react-dom";

interface AppProps {
   color?: string;
}

interface AppState {
   counter: number;
}

class App extends React.Component&lt;AppProps, AppState&gt;{

    constructor(props: AppProps) {
        super(props);
        this.state = {counter: 0}
    }

    onIncrement(): void{
        this.setState({
            counter: this.state.counter + 1,
        })
    }
    onDecrement(): void{
        this.setState({
            counter: this.state.counter - 1,
        })
    }

    render() {
        return (
            &lt;div&gt;
                &lt;p&gt;{this.state.counter}&lt;/p&gt;
                &lt;button onClick={this.onIncrement.bind(this)}&gt;+&lt;/button&gt;
                &lt;button onClick={this.onDecrement.bind(this)}&gt;-&lt;/button&gt;
            &lt;/div&gt;
        )
    }
}

ReactDOM.render(&lt;App color='green'/&gt;, document.getElementById('root'));
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="reduxWithTS3">Redux + TypeScript [3]</h4>

                <div>
                    <p>При миграции приложения на React-Redux в перую очередь нужно создать хранилище состояний(store,
                        который вложим в качестве зависимости, оборачивающего компонента
                        <code>&lt;Provider store={store}&gt;&lt;App/&gt;&lt;Provider/&gt;</code>):</p>
                    <pre>
//store.ts

import { configureStore } from "@reduxjs/toolkit";
import { combineReducers } from "@reduxjs/toolkit";

const rootReducer = combineReducers({});

export const store = configureStore({
    reducer: rootReducer,
});

//export type RootState = ReturnType&lt;typeof rootReducer&gt;;
export type RootState = ReturnType&lt;typeof store.getState&gt;;
export type AppDispatch = typeof store.dispatch;
                    </pre>
                    <p>Далее мы создаем файл с кастомными Redux хуками(вцелом можно обойтись и без данного файла и
                        использовать
                        useDispatch совместно с дженериком в каждом файле где он применяется, но лучше вынести в
                        отдельный
                        файл):</p>
                    <pre>
import {TypedUseSelectorHook, useDispatch, useSelector} from 'react-redux';
import { AppDispatch, RootState } from './store';

export const useAppDispatch = () => useDispatch&lt;AppDispatch&gt;();
export const useAppSelector: TypedUseSelectorHook&lt;RootState&gt; = useSelector;
                    </pre>
                    <p>В файле со слайсами типизируются initialState и сами редьюсеры(а именно action при помощи
                        дженерика <code>PayloadAction&lt;&gt;</code>):</p>
                    <pre>
//todoSlice

import { createSlice, PayloadAction } from "@reduxjs/toolkit";

import {Todo} from "../../types";

const initialState: Todo[] = [];

const todoSlice = createSlice({
    name: '@todos',
    initialState,
    reducers: {
        addTodo(state, action: PayloadAction&lt;string&gt;){
            const newTodo: Todo = {
                id: new Date().toLocaleString(),
                title: action.payload,
                completed: false,
            }

            return [newTodo, ...state];
        },
        toggleTodo(state, action: PayloadAction&lt;Todo['id']&gt;) {
            // return state.map(todo => {
            //         if (todo.id !== action.payload) return todo
            //         return {
            //             ...todo,
            //             completed: !todo.completed,
            //         }
            // })
            const todo = state.find(el => el.id === action.payload);
            if (todo) {
                todo.completed = !todo.completed;
            }
        },
        removeTodo(state, action: PayloadAction&lt;Todo['id']&gt;){
            return state.filter(todo => todo.id !== action.payload);
        }
    }
})

export default todoSlice.reducer;
export const {
    addTodo,
    removeTodo,
    toggleTodo
} = todoSlice.actions
                    </pre>
                    <p>Для типизации селекторов, селектор выносят в отдельный файл и типизируют state:</p>
                    <pre>
//todoSelectors.ts

import {RootState} from "../../store";

export const selectAllTodos = (state: RootState) => state.todos;
                    </pre>
                    <p>Async thunk actions типизируются только внутренные переменные:</p>
                    <pre>
import { createAsyncThunk } from "@reduxjs/toolkit";
import {Todo} from "../../types";

export const fetchAllTodos = createAsyncThunk(
    'todos/fetchTodos',
    async () => {
        const response = await fetch('https://jsonplaceholder.typicode.com/todos?_limit=10');
        const data = await response.json() as Todo[];
        return data;
    }
)

export const createTodo = createAsyncThunk(
    'todo/createTodo',
    async (text: string) => {
        const newTodo: Todo = {
            title: text,
            id: Math.random(),
            completed: false,
            userId: Math.random(),
        }

        const response = await fetch('https://jsonplaceholder.typicode.com/todos',{
            method: 'POST',
            headers: {
                'Content-Type' : 'application/json',
            },
            body: JSON.stringify(newTodo)
        });

        return (await response.json()) as Todo;
    }
)
                    </pre>
                    <p>Сами же экстра редьюсеры в типизации не нуждаются тк они уже протипизированны "из коробки":</p>
                    <pre>
import { createSlice } from "@reduxjs/toolkit";

import { Todo } from "../../types";
import { createTodo, fetchAllTodos } from "./todoAsyncActions";

interface IInitialState {
    status: 'idle' | 'loading' | 'finished' | 'error';
    todoList: Todo[];
}

const initialState: IInitialState = {
    status: 'idle',
    todoList: [],
}

const todoSlice = createSlice({
    name: '@todos',
    initialState,
    reducers: {},
    extraReducers: (builder) => {
        builder
            .addCase(fetchAllTodos.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(fetchAllTodos.fulfilled, (state, action) => {
                state.status = 'finished';
                state.todoList = action.payload;
            })
            .addCase(fetchAllTodos.rejected, (state) => {
                state.status = 'error';
            })
            .addCase(createTodo.fulfilled, (state, action) => {
                state.todoList.push(action.payload);
            })
    }
})

export default todoSlice.reducer;
                    </pre>
                    <p>AsyncThunk как дженерик имеет следующие аргументы:</p>
                    <pre>
function createAsyncThunk&lt;
    Returned, // возвращаемое значение
    ThunkArg, // аргумент который принимает функция
    ThunkApiConfig extends AsyncThunkConfig
>
//где AsyncThunkConfig:

type AsyncThunkConfig = {
    state?: unknown
    dispatch?: Dispatch
    extra?: unknown
    rejectValue?: unknown
    serializedErrorType?: unknown
    pendingMeta?: unknown
    fulfilledMeta?: unknown
    rejectedMeta?: unknown
}
                    </pre>
                    <p>Пример:</p>
                    <pre>
import {createAsyncThunk} from "@reduxjs/toolkit";
import {Todo} from "../../types";
import {IInitialState} from "./asyncTodoSlice";

export const fetchAllTodos = createAsyncThunk&lt;
    Todo[], // возвращаемое значение
    undefined, // аргумент(в данном случае он отсутствует)
    {state: {asyncTodos: IInitialState} // cостояние из хранилища
}&gt;(
    'todos/fetchTodos',
    async () =&gt; {
        const response = await fetch('https://jsonplaceholder.typicode.com/todos?_limit=10');
        return await response.json();
    },
    {
        condition(_, {getState}){
            const {status} = getState().asyncTodos; //деструктурирование status из полученного состояния asyncTodos из getState

            if (status === 'loading'){
                return false;
            }
        }
    }
)

export const createTodo = createAsyncThunk&lt;
    Todo, // возвращаемое значение
    string // тип text
   &gt;(
    'todo/createTodo',
    async (text: string) => {
        const newTodo: Todo = {
            title: text,
            id: Math.random(),
            completed: false,
            userId: Math.random(),
        }

        const response = await fetch('https://jsonplaceholder.typicode.com/todos',{
            method: 'POST',
            headers: {
                'Content-Type' : 'application/json',
            },
            body: JSON.stringify(newTodo)
        });

        return await response.json();
    }
)
                    </pre>
                </div>
            </section>
        </section>

        <section id="nodeJSNav">
            <h2 id="nodeJSBasicsHeaderLink">Основы Node JS</h2>

            <section id="baseNodeJSNav">
                <h3 id="baseNodeJS">Базовый Node JS</h3>

                <section>
                    <h4 id="nodeJSModules">Стандартные модули Node JS</h4>

                    <div>
                        <p>В node JS существуют следующие глобально доступные объекты</p>
                        <ol>
                            <li>process</li>
                            <li>URL</li>
                        </ol>
                        <p>Так же можно экспортировать следующие модули:</p>
                        <ol>
                            <li>fs (file-system)</li>
                            <li>path</li>
                            <li>http</li>
                            <li>events (Event Emitter)</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="NJSCryptoModule">Потоки в node JS и модуль crypto</h4>

                    <div>
                        <p>Сам по себе node JS однопоточный, НО при этом библиотеки могут быть многопоточными благодаря
                            <a
                                    href="https://github.com/libuv/libuv" target="_blank">Libuv</a>, рассмотрим на
                            примере
                            глобального
                            объекта crypto</p>
                        <p>Модуль crypto предназначен для криптографических операций - для шифрования, дешифорования и
                            хеширования.</p>
                        <pre>
const crypto = require('crypto');

const start = Date.now();

crypto.pbkdf2('123ttt', '5', 1000000, 64, 'sha512', () => {
    console.log('1 end', Date.now() - start)
})

crypto.pbkdf2('123ttt', '5', 1000000, 64, 'sha512', () => {
    console.log('2 end', Date.now() - start)
})

crypto.pbkdf2('123ttt', '5', 1000000, 64, 'sha512', () => {
    console.log('3 end', Date.now() - start)
})

crypto.pbkdf2('123ttt', '5', 1000000, 64, 'sha512', () => {
    console.log('4 end', Date.now() - start)
})

crypto.pbkdf2('123ttt', '5', 1000000, 64, 'sha512', () => {
    console.log('5 end', Date.now() - start)
})

// 'end 1-4 выполняются первыми, после того как один из потоков освободился начинатеся выполняться "end 5"'
                        </pre>

                        <p>С помощью модуля crypto можно наглядно посмотреть как расспараллеливается выполнение задач в
                            node
                            JS,
                            библиотека Libuv по умолчанию поддерживает 4 потока, посему первые четыри вызова будут
                            выполнены
                            одновременно, пятый же начнет выполнение после того как один из потоков освободится.</p>
                    </div>
                </section>

                <section>
                    <h4 id="nodeJSEventLoop">Событийный цикл NodeJS (NodeJS Event Loop)</h4>

                    <div>
                        <p>Идея событийного цикла очень проста. Есть бесконечный цикл, в котором движок JavaScript
                            ожидает
                            задачи,
                            исполняет их и снова ожидает появления новых.</p>
                        <p>Общий алгоритм движка:</p>
                        <ol>
                            <li>Пока есть задачи выполнить их, начиная с самой старой</li>
                            <li>Бездействовать до появления новой задачи, а затем перейти к пункту 1</li>
                        </ol>

                        <p>Фазы выполнения операций в цикле событий:</p>
                        <ol>
                            <li>Таймеры (setTimeout/setInterval)</li>
                            <li>Input/Output коллбэки, здесь выполняются все коллбеки за исключением событий "close",
                                таймеров и
                                событий которые были определены с помощью функции setImmediate в Node JS.
                            </li>
                            <li>Ожидание, подготовка. Используется для внутренних целей</li>
                            <li>Опрос - получение новый I/O событий(при этом Node JS может блокироваться!!!)</li>
                            <li>Проверка - вызываются коллбеки, которые были определены с помощью функции setImmediate
                            </li>
                            <li>Коллбеки события "close", закрытие вебсокет соединений(событие "close"), закрытие
                                стрима,
                                считывающего данные и тд
                            </li>
                        </ol>
                        <p>Визуальная схема работы цикла событий в nodeJS:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/nodeJSEventLoop.png" alt="nodeJSEventLoop">
                        </div>
                        <p>Т.е. пока node JS крутит этот цикл, он после каждого шага проверяет на наличие новых
                            process.nextTick,
                            после этого также сразу проверяет наличие новых промисов и колбэков </p>
                    </div>
                </section>

                <section>
                    <h4 id="nodeJSProcess">Глобально доступный объект process</h4>

                    <div>
                        <p>process - глобальный объект с помощью которого можно получить информацию о текущем
                            процессе</p>
                        <p>process.pid - возвращает id процесса, его так же можно найти в диспетчере задач во кладке
                            "Подробности"</p>
                        <p>process.env - переменные окружения, их можно указывать в конфигурационных файлах, отдельные
                            переменные
                            можно указывать при запуске приложения при конфигурации Docker контейнера.</p>
                        <pre>
console.log(process.env);

//  (env object) {
//     USERDOMAIN_ROAMINGPROFILE: 'COMPUTER',
//     PROCESSOR_LEVEL: '6',
//     NVM_SYMLINK: 'C:\\Program Files\\nodejs',
//     SESSIONNAME: 'Console',
//     ALLUSERSPROFILE: 'C:\\ProgramData',
//     PROCESSOR_ARCHITECTURE: 'AMD64',
//     GATEWAY_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\gateway.vmoptions',
//     PSModulePath: 'C:\\Program Files\\........',
//     SystemDrive: 'C:',
//     RIDER_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\rider.vmoptions',
//     USERNAME: 'Slipbang',
//     DEVECOSTUDIO_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\devecostudio.vmoptions',
//     STUDIO_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\studio.vmoptions',
//     'ProgramFiles(x86)': 'C:\\Program Files (x86)',
//     GPU_USE_SYNC_OBJECTS: '1',
//     GPU_MAX_ALLOC_PERCENT: '100',
//     FPS_BROWSER_USER_PROFILE_STRING: 'Default',
//     PATHEXT: '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW',
//     APPCODE_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\appcode.vmoptions',
//     DriverData: 'C:\\Windows\\System32\\Drivers\\DriverData',
//     ProgramData: 'C:\\ProgramData',
//     DATASPELL_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\dataspell.vmoptions',
//     ProgramW6432: 'C:\\Program Files',
//     HOMEPATH: '\\Users\\Slipbang',
//     PROCESSOR_IDENTIFIER: 'Intel64 Family 6 Model 158 Stepping 13, GenuineIntel',
//     ProgramFiles: 'C:\\Program Files',
//     PUBLIC: 'C:\\Users\\Public',
//     windir: 'C:\\WINDOWS',
//     GPU_MAX_HEAP_SIZE: '100',
//     DATAGRIP_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\datagrip.vmoptions',
//     LOCALAPPDATA: 'C:\\Users\\Slipbang\\AppData\\Local',
//     ChocolateyLastPathUpdate: '133193147669235416',
//     GPU_SINGLE_ALLOC_PERCENT: '100',
//     USERDOMAIN: 'COMPUTER',
//     GPU_FORCE_64BIT_PTR: '0',
//     WEBSTORM_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\webstorm.vmoptions',
//     LOGONSERVER: '\\\\COMPUTER',
//     PYCHARM_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\pycharm.vmoptions',
//     FPS_BROWSER_APP_PROFILE_STRING: 'Internet Explorer',
//     CLION_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\clion.vmoptions',
//     JETBRAINSCLIENT_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\jetbrainsclient.vmoptions',
//     GOLAND_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\goland.vmoptions',
//     OneDrive: 'C:\\Users\\Slipbang\\OneDrive',
//     APPDATA: 'C:\\Users\\Slipbang\\AppData\\Roaming',
//     VBOX_HWVIRTEX_IGNORE_SVM_IN_USE: '1',
//     IDEA_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\idea.vmoptions',
//     RUBYMINE_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\rubymine.vmoptions',
//     ChocolateyInstall: 'C:\\ProgramData\\chocolatey',
//     JETBRAINS_CLIENT_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\jetbrains_client.vmoptions',
//     CommonProgramFiles: 'C:\\Program Files\\Common Files',
//     Path: 'C:\\Python311\\Scripts\\;C:\\Python311\\;C:\\Program Files (x86)\\...
//     OS: 'Windows_NT',
//     COMPUTERNAME: 'COMPUTER',
//     NVM_HOME: 'C:\\Users\\Slipbang\\AppData\\Roaming\\nvm',
//     PROCESSOR_REVISION: '9e0d',
//     CommonProgramW6432: 'C:\\Program Files\\Common Files',
//     ComSpec: 'C:\\WINDOWS\\system32\\cmd.exe',
//     TEMP: 'C:\\Users\\Slipbang\\AppData\\Local\\Temp',
//     SystemRoot: 'C:\\WINDOWS',
//     WEBIDE_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\webide.vmoptions',
//     HOMEDRIVE: 'C:',
//     USERPROFILE: 'C:\\Users\\Slipbang',
//     TMP: 'C:\\Users\\Slipbang\\AppData\\Local\\Temp',
//     'CommonProgramFiles(x86)': 'C:\\Program Files (x86)\\Common Files',
//     NUMBER_OF_PROCESSORS: '6',
//     PHPSTORM_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\phpstorm.vmoptions',
//     IDEA_INITIAL_DIRECTORY: 'C:\\Users\\Slipbang\\Desktop'
// }
                        </pre>

                        <p>Важные переменные, которые можно инициализировать самостоятельно - PORT, NODE_ENV</p>
                        <p>process.argv - возвращает массив с командами которые мы можем выполнять при запуске файла</p>
                        <pre>
console.log(process.argv);
node process.js command1 command2 command3 command4
const commands = [
    'C:\\Program Files\\nodejs\\node.exe',
    'C:\\Users\\Slipbang\\Desktop\\node JS\\process.js',
    'command1',
    'command2',
    'command3',
    'command4'
]
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="nodeJSPath">Модуль path</h4>

                    <div>
                        <p>Модуль path позволяет удобным образом взаимодействовать с путями(абсолютными или
                            относительными)</p>
                        <p>path имеет следующие методы:</p>

                        <p>join() позволяет соединить несколько участков пути вне зависимости от ОС:</p>
                        <pre>
console.log(path.join(__dirname, 'first', 'second', 'third')) // C:\Users\Slipbang\Desktop\nodeJS\modules_in_NodeJS\first\second\third
//с помощью __dirname можно на любом устройстве получить абсолютный путь от корня до директории выполнения, __filename - имя файла
                        </pre>

                        <p>Метод resolve() похожа на join(), но всегда возвращает абсолютный путь, есть нюансы с
                            работой!:</p>
                        <pre>console.log(path.resolve('first', 'second', 'third')) // C:\Users\Slipbang\Desktop\nodeJS\modules_in_NodeJS\first\second\third</pre>

                        <p>Метод parse() парсит путь в объект:</p>
                        <pre>
const fullPath = path.resolve(__dirname, 'first', 'second', 'third.js');
console.log('парсинг пути', path.parse(fullPath));
// результат выполнения
{
    root: 'C:\\',
    dir: 'C:\\Users\\Slipbang\\Desktop\\node JS\\first\\second',
    base: 'third',
    ext: '.js',
    name: 'third'
}
                        </pre>
                        <p>path.sep - Разделитель в ОС("\").</p>
                        <p>path.isAbsolute('first/second') - Проверка на абсолютный путь.</p>
                        <p>path.basename(fullPath) - Название файла.</p>
                        <p>path.extname(fullPath) - Расширение файла.</p>
                    </div>
                </section>

                <section>
                    <h4 id="nodeJSURL">Глобально доступный объект URL</h4>

                    <div>
                        <p>Объект URL предназначен для работы со ссылками и их параметрами.</p>
                        <pre>
const siteIRL = 'http://localhost:8080/users?id=5123';

const url = new URL(siteIRL);

console.log(url)

результат вывода в консоль: {
    href: 'http://localhost:8080/users?id=5123',
    origin: 'http://localhost:8080',
    protocol: 'http:',
    username: '',
    password: '',
    host: 'localhost:8080',
    hostname: 'localhost',
    port: '8080',
    pathname: '/users',
    search: '?id=5123',
    searchParams: URLSearchParams { 'id' => '5123' },
    hash: ''
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="nodeJSFS">Модуль fs (file-system)</h4>

                    <div>
                        <p>fs (file-system) служит для взаимодействия с файловой системой: создание или удаление
                            файлов/папок,
                            считывание, запись.</p>
                        <p>Медоты в fs дублированы на обычные и синхронные! Первый тип методов не блокирует главный
                            поток,
                            второй же
                            - блокирует! </p>

                        <p>mkdir/mkdirSync позволяет создать папку, в случае если папка уже существует - произойдет
                            ошибка.</p>
                        <pre>
const fs = require('fs');
const path = require('path');

fs.mkdirSync(path.resolve(__dirname, 'newDirName1', 'newDirName2', 'newDirName3'), {recursive: true});

// Асинхронный вариант mkdirSync
console.log('START');
fs.mkdir(path.resolve(__dirname, 'newDir1', 'newDir2', 'newDir3'),{recursive: true}, (err, ) => {
    if (err) {
        console.log(err);
        return;
    }
    console.log('Папка создана');
});
console.log('END');
                        </pre>

                        <p>fs.rmdir() - асинхронное удаление директории</p>
                        <pre>
fs.rmdir(path.resolve(__dirname, 'dirName'), (err) => {
    if (err) {
        throw err;
    }
})
                        </pre>

                        <p>fs.unlink() - асинхронное удаление файла</p>
                        <pre>
fs.unlink('./text-files/test.txt', (err) => {
    if (err && err.code !== 'ENOENT') throw err;
    fs.rmdir('./text-files', (err) => {
        if (err && err.code !== 'ENOENT') throw err;
    })
})
                        </pre>

                        <p>fs.writeFile() - создание и запись в файл, второй переданный аргумент будет ПЕРЕЗАТИРАТЬ
                            данные в
                            случае
                            если
                            они есть в файле</p>
                        <pre>
fs.writeFile(path.resolve(__dirname, 'test.txt'), '123456qwerty', (err) => {
    if (err) throw err;
    console.log('Файл создан')
})
                        </pre>

                        <p>fs.appendFile() - если нужно дозаписать в файл не удаляя старое содержимое(запись идет в
                            конце
                            файла).</p>
                        <pre>
fs.appendFile(path.resolve(__dirname, 'test.txt'), '123456qwerty', (err) => {
    if (err) throw err;
    console.log('Запись добавлена')
})
                        </pre>

                        <p>fs.readFile() - чтение файла, по умолчанию метод считывает буфер, для преобразования данных
                            нужно
                            передать
                            аргумент опций {encoding: 'utf-8'} (utf-8 как пример)</p>
                        <pre>
fs.readFile(path.resolve(__dirname, '../test.txt'), {encoding: 'utf-8'}, (err, data) => {
    if (err) throw err;

    console.log(data)
})
                        </pre>

                        <p>В случае если требуются операции выполняемые по цепочке, методы надо вызывать в колбеке
                            родительских
                            методов, и для избежания "ада колбеков", колбеки можно заменить на промисы.</p>
                        <pre>
//Асинхронное создание, запись и чтение файла с помощью промисов
const writeFileAsync = async (path, data) => {
    return new Promise((resolve, reject) => fs.writeFile(path, data, (err) => {
        if (err) reject(err.message);
        resolve()
    }))
}

const appendFileAsync = async (path, data) => {
    return new Promise((resolve, reject) => fs.appendFile(path, data, (err) => {
        if (err) reject(err.message);
        resolve()
    }))
}

const readFileAsync = async (path) => {
    return new Promise((resolve, reject) => fs.readFile(path, {encoding: 'utf-8'}, (err, data) => {
        if (err) reject(err.message);
        resolve(data);
    }))
}

const removeFileAsync = async (path) => {
    return new Promise((resolve, reject) => fs.rm(path, (err) => {
        if (err) reject(err.message);
        resolve();
    }))
}

writeFileAsync(path.resolve(__dirname, 'test1.txt'), 'data')
    .then(() => appendFileAsync(path.resolve(__dirname, 'test1.txt'), '123'))
    .then(() => appendFileAsync(path.resolve(__dirname, 'test1.txt'), '456'))
    .then(() => appendFileAsync(path.resolve(__dirname, 'test1.txt'), '789'))
    .then(() => readFileAsync(path.resolve(__dirname, 'test1.txt')))
    .then(data => console.log(data))
    .then(() => {
        removeFileAsync(path.resolve(__dirname, 'test1.txt'))
        console.log('Файл удален')
    })
    .catch(err => console.log(err));
                        </pre>
                        <p>Так же можно импортировать promise вариант fs, в данном варианте fa можно использовать
                            then/catch
                            цепочки:</p>
                        <pre>
const fs = require('fs/promises');

fs.readFile('./example.txt', 'utf-8')
    .then(data => {
        console.log(data);
    })
    .catch(error => console.log(error));
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="nodeJSOS">Модули os (operation-system) и cluster</h4>

                    <div>
                        <p>platform позволяет получить текущую операционную систему</p>
                        <pre>console.log(os.platform()) //win32</pre>

                        <p>arch позволяет получить архитектуру процессора</p>
                        <pre>console.log(os.arch()) //x64</pre>

                        <p>cpus возвращает массив, где каждый объект массива - описание ядра процессора</p>
                        <pre>
console.log(os.cpus())

// cpusArray [
//     {
//         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
//         speed: 3696,
//         times: {
//             user: 447250,
//             nice: 0,
//             sys: 1707546,
//             idle: 38694796,
//             irq: 482984
//         }
//     },
//     {
//         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
//         speed: 3696,
//         times: {
//             user: 1808562,
//             nice: 0,
//             sys: 26226046,
//             idle: 12814984,
//             irq: 3656
//         }
//     },
//     {
//         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
//         speed: 3696,
//         times: { user: 960375, nice: 0, sys: 1049437, idle: 38839781, irq: 3609 }
//     },
//     {
//         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
//         speed: 3696,
//         times: { user: 528000, nice: 0, sys: 580375, idle: 39741218, irq: 4484 }
//     },
//     {
//         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
//         speed: 3696,
//         times: { user: 434343, nice: 0, sys: 196265, idle: 40218984, irq: 3546 }
//     },
//     {
//         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
//         speed: 3696,
//         times: { user: 624765, nice: 0, sys: 161656, idle: 40063171, irq: 2203 }
//     }
// ]
                        </pre>

                        <p>Модуль cluster предназначен для того чтобы однопоточному nodeJS приложению использовать все
                            возможности
                            многоядерных систем.</p>

                        <pre>
// cluster.isMaster определяет является ли текущий процесс главым
if (cluster.isMaster) {
    for (let i = 0; i &lt; os.cpus().length-2; i++) {
        // cluster.fork() запускает дочерний процессж
        cluster.fork();
    }

    cluster.on() - подписка на определенное событие, в примере ниже это событие 'exit'
    cluster.on('exit', (worker, code, signal) =&gt; {
        console.log(`Воркер с pid=${worker.process.pid} был остановлен`);
        if (code === '...') {
            cluster.fork()
        } else {
            console.log('Воркер умер')
        }

    })
} else {
    console.log(`Воркер с pid=${process.pid} запущен`)

    setInterval(() =&gt; {
        console.log(`Воркер с pid=${process.pid} работает`)
    }, 5000)
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="nodeJSEvents">Модуль events</h4>

                    <div>
                        <p>Модуль events позволяет создавать события, подписываться на них и генерировать эти
                            события.</p>
                        <p>У данного модуля присутствуют те же методы, что есть у document - addEventListener,
                            removeEventListener и
                            тд </p>
                        <pre>
const { EventEmitter } = require('events');
const emitter = new EventEmitter();

// создание пользовательского события
const callback = (data, secondArg, thirdArg, ect) => {
    console.log('Вы прислали сообщение ' + data);
    console.log('Второй аргумент ' + secondArg);
}

emitter.on('message', callback);
const MESSAGE = process.env.message || '';

if (MESSAGE) {
    //Функция emit используется для генерации событий, ее аргумент - название события которое мы генерируем.
    emitter.emit('message', MESSAGE, 123);
} else {
    emitter.emit('message', 'вы не указали сообщение')
}
                        </pre>

                        <p>Данную концепцию удобно использовать в следующих случаях:</p>
                        <ol>
                            <li>При создании http серверов</li>
                            <li>В вебсокетах</li>
                            <li>long pulling</li>
                            <li>В кластеризации</li>
                        </ol>
                        <p>В случае если событие нужно сгенерировать единожды - можно применить метод once(вместо
                            on)</p>
                        <p>С помощью removeAllListeners можно удалять все слушатели, removeListener('eventName',
                            callback)
                            можно
                            удалить определенный слушатель</p>
                    </div>
                </section>

                <section>
                    <h4 id="nodeJSStreams">Стримы в nodeJS</h4>

                    <div>
                        <p>В nodeJS существуют 4 типа стримов:</p>
                        <ol>
                            <li>Readable - чтение</li>
                            <li>Writable - запись</li>
                            <li>Duplex - для чтения и записи (Readable + Writable)</li>
                            <li>Transform - то же что и Duplex, но может изменить данные по мере чтения</li>
                        </ol>
                        <p>Стримы используются для разбивки больших файлов на чанки и постепенная их загрузка, запись,
                            чтение и
                            тд.
                            По умолчанию размер чанка равен 64кб</p>
                        <pre>
const fs = require('fs');
const path = require('path');

// Чтение файла testDataFile методом readFile, в данном случае файл прочитан целиком
fs.readFile(path.resolve(__dirname, 'testDataFile.txt'), (err, data) => {
    if (err) {
        throw err;
    }
    console.log(data)
}) // &lt;Buffer 64 61 74 61 31 32 33 34 35 36 64 61 74 61 31 32 33 34 35 36 64 61 74 61 31 32 33 34 35 36 64 61 74 61 31 32 33 34 35 36 64 61 74 61 31 32 33 34 35 36 ... 301241 more bytes&gt;

// Чтение файла testDataFile при помощи стримов, а именно fs.createReadStream()
const stream = fs.createReadStream(path.resolve(__dirname, 'testDataFile.txt'), {encoding: 'utf-8'});

// Один чанк по умолчанию - 64кб
stream.on('data', (chunk) => {
    console.log(chunk) // выводит в лог информацию из файла порциями(чанками)
})

// Стримы имеют ряд событий таких как open/close/end/error и тд
stream.on('open', () => console.log('Начали читать'));
stream.on('end', () => console.log('Закончили читать'));
stream.on('error', (err) => console.log(err));

// Запись в файл при помощи стрима fs.createWriteStream()
const writableStream = fs.createWriteStream(path.resolve(__dirname, 'test.txt'));

for (let k = 0; k &lt; 20; k++) {
    writableStream.write(k + '\n');
}

//writableStream нужно завершать в ручную!
writableStream.end();

// закрытие стрима
// writableStream.close();

// уничтожение созданного потока, после вызова данного метода, метод write() более вызвать нельзя
writableStream.destroy();
                        </pre>

                        <p>При работе с http сервером для нас доступно два объекта - request и response, они так же
                            являются стримами! При этом request - readable stream, а response - writable stream.</p>
                        <pre>
const http = require('http');
http.createServer((req, res) =&gt; {
    // req - readable stream
    // res - writable stream
    const stream = fs.createReadStream(path.resolve(__dirname, 'test.txt'));

    Важный момент!!! Синхронизация стримов чтения и записи!
    stream.pipe(res)

    stream.on('data', chunk =&gt; res.write(chunk));
    stream.on('end', chunk =&gt; res.end());
})
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="nodeJSHttp">Модуль http</h4>

                    <div>
                        <p>Модуль http используется для создания серверов.</p>
                        <pre>
const http = require('http');
const PORT = process.env.PORT || 5000;

const server = http.createServer((req, res) => {
    // Сервер сайд рендеринг
    // res.writeHead(200, {
    //     'Content-type': 'text/html;'
    // })
    // res.end('&lt;h1&gt;Hello world&lt;/h1&gt;');

    // отправка JSON
    res.writeHead(200, {
        'Content-type': 'application/json'
    })

    if (req.url === '/users') {
        return res.end(JSON.stringify([
            {id: 1, name: 'Dmitry'}
        ]))
    }

    if (req.url === '/posts') {
        return res.end('POSTS')
    }
})

server.listen(PORT, () =&gt; console.log(`Server started on PORT ${PORT}`));
                        </pre>

                        <p>Подробнее по созданию собственного сервера nodeJS можно изучить в <a
                                href="https://github.com/Slipbang/nodeJS" target="_blank">данном репозитории Гитхаб</a>
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="moduleExportsImports">Экспорты и импорты модулей в javaScript</h4>

                    <div>
                        <p>В javaScript существует два способа экспортировать и импортировать модули:</p>
                        <ul>
                            <li>CommonJS Modules [require]</li>
                            <li>ECMAScript Modules(ESM) [import]</li>
                        </ul>
                        <p>Модули служат для: разделения приложения на части, организации кода, разделения
                            ответственности,
                            упрощение поддержки приложения.</p>
                        <p>Характеристики модулей:</p>
                        <ol>
                            <li>По умолчанию ни одна из переменных в модуле не доступна для импорта в других модулях
                            </li>
                            <li>Чтобы переменная стала доступна для импорта в других модулях, ее необходимо
                                экспортировать
                                из
                                модуля
                            </li>
                            <li>Для использования в определенном модуле переменных из других модулей, их необходимо
                                импортировать
                            </li>
                            <li>При импортировании названия переменных можно изменять</li>
                        </ol>
                    </div>
                </section>

                <section>
                    <h4 id="commonJSSyntax">Синтаксис CommonJS Modules</h4>

                    <div>
                        <pre>
// single-export.js
function greeting(name) {
    console.log(`Hello ${name}`)
}

module.exports = greeting;

// multiple-exports.js
const name = 'Dmitriy';
const hobbies = ['swimming', 'boxing', 'cycling'];
const favoriteNumber = 77;

console.log('console log from multiple-exports commonJS module')

module.exports = {
    name,
    hobbies,
    favoriteNumber
}

// index.js
const {name: myName, favoriteNumber, hobbies} = require('./multiple-exports.js');
const greetingFunction = require('./single-export.js');

console.log(myName, favoriteNumber, hobbies); // Dmitriy 77 [ 'swimming', 'boxing', 'cycling' ]
greetingFunction(name); // Hello Dmitriy
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="ESMSyntax">Синтаксис ECMAScript Modules (ESM)</h4>

                    <div>
                        <p>Существует два способа перехода с CommonJS на ESM:</p>
                        <ol>
                            <li>Изменить расширение файла на .mjs</li>
                            <li>Добавить "type": "module" в файле package.json</li>
                        </ol>
                        <p>Внутри ESM нет доступа к переменным из модуля CommonJS!!! тк модули ESM не оборачиваются в
                            анонимную
                            функцию с данными аргументами:</p>
                        <pre>
console.log(module); // ReferenceError: module is not defined in ES module scope
console.log(require); //ReferenceError: require is not defined in ES module scope, you can use import instead
console.log(exports); // ReferenceError: exports is not defined in ES module scope
console.log(__filename); // ReferenceError: __filename is not defined in ES module scope
console.log(__dirname); // ReferenceError: __dirname is not defined in ES module scope
                        </pre>

                        <p>Типы экспортов в ESM:</p>
                        <ul>
                            <li>Именованные экспорты (экспорт одной или нескольких переменных)</li>
                            <li>Экспорт по умолчанию</li>
                            <li>Смешанные экспорты (комбинация из двух выше перечисленных)</li>
                        </ul>

                        <p>Именованный экспорт:</p>
                        <pre>
// constants.mjs
const URL = 'http://localhost:5000';
const USERNAME = 'admin';
const PASSWORD = 'some_pass';

export { URL, USERNAME, PASSWORD }; // ключевое слово export является инструкцией (statement)
// ЛИБО inline експорты(в случае если переменных много следует использовать первый вариант!!!)
export const URL = 'http://localhost:5000';
export const USERNAME = 'admin';
export const PASSWORD = 'some_pass';

// index.mjs
import { URL, USERNAME, PASSWORD } from './hello.mjs';
                        </pre>

                        <p>Если требуются псевдонимы, то можно использовать следующий синтаксис:</p>
                        <pre>
// someFile.mjs
const season = 'spring';
const temperature = 13;

export {season as spring, temperature};

// index.mjs
import {spring, temperature} from './someFile.mjs';

console.log(spring, temperature)

//ЛИБО псевдоним можно присвоить в импорте
// someFile.mjs
const season = 'spring';
const temperature = 13;

export {season, temperature};

// index.mjs
import {season as spring, temperature} from './someFile.mjs';
console.log(spring, temperature);

//НО для того чтобы не возникло путаницы лучше переименовывать переменную в импорте!
                        </pre>
                        <p>Импорт по умолчанию имеет следующий синтаксис:</p>
                        <pre>
// default-export.mjs
async function getData(url) {
    const response = await fetch(url);
    const posts = await response.json();
    return posts;
}

export default getData;

//index.mjs
import getDataFromServer from "./default-export.mjs";
getDataFromServer('https://jsonplaceholder.typicode.com/todos/1')
    .then(post => console.log(post))
    .catch(err => console.log(err))
                        </pre>
                        <p>Примером смешанного импорта является импорт react хуков и самого React из библиотеки:</p>
                        <pre>import React, { useState, useEffect } from 'react';</pre>
                    </div>
                </section>
            </section>

            <section id="expressJSNav">
                <h3 id="expressJSFramework">Веб фреймворк Express</h3>

                <section>
                    <h4 id="expressIntro">Введение в Express</h4>

                    <div>
                        <p>Express - фреймворк для nodeJs, который упрощает создание API и веб приложений.</p>
                        <p>По своей сути express является оберткой над nodeJS модулем http и некоторых других модулей,
                            т.е. это просто NPM пакет собранный на базе nodeJS</p>
                        <p>Устанавливается командой:</p>
                        <p>npm install express</p>

                        <p>Базовый express синтаксис:</p>
                        <pre>
const express = require('express'); / import express from 'express';

const app = express();

app.get('/', (req, res) =&gt; res.send('Response from Express'));

app.listen(5000, () =&gt; console.log('Server was started on port 5000'));
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="expressRouting">Роутинг(маршрутизация) в express</h4>

                    <div>
                        <p>Роутинг(маршрутизация) определяет как сервер отвечает на разные запросы клиентов.
                            Можно указывать различные обработчики запросов клиента в зависимости от метода
                            http(get/post/ect),
                            а так же зависимости от пути, по которому обращается пользователь. </p>

                        <pre>app.httpMethod(requestPath, handler1, handler2, handler3, ...);</pre>
                        <p>Где:</p>
                        <ul>
                            <li>httpMethod - это метод http(get/post/ect), метод use является универсальным и принимает
                                все методы клиента
                            </li>
                            <li>requestPath - путь по которому обращается клиент, например /users, /login, ect</li>
                            <li>handler(1/2/3) - колбэк функции, которые обрабатывают запрос клиента и отправляют ответ,
                                имеют два параметра request(req) и response(res).
                                В случае если в хендлеров несколько, во всех кроме последнего обязательно нужно передать
                                третий параметр next() и вызвать его в конце хендлера
                                иначе не произойдет переход к следующему хендлеру! Очередность важна!
                            </li>
                        </ul>
                    </div>
                </section>

                <section>
                    <h4 id="routesParams_MVS">Параметры маршрута и MVC паттерн</h4>

                    <div>
                        <p>Пример пути (/users/234) при наличии параметра:</p>
                        <pre>
app.get('/users/:usersId', (req, res) => {
    console.log(req.params); // { userId: '234'}
    console.log(req.params.userId); // 234
})
                        </pre>

                        <p>Так же http методы можно конфигурировать цепочкой:</p>
                        <pre>
app
    .route('/users')
    .get(() => res.send('GET req at /users path'))
    .post(() => res.send('POST req at /users path'))
                        </pre>

                        <p>в случае если маршрутов много их можно вынести в отдельный модуль, так же в отдельный модуль
                            выносятся handlerы,
                            хендлеры правильно называть контроллерами:</p>
                        <pre>
// controllers/comments.js
const getCommentsHandler = (req, res) => {
    res.send('Get comments route')
}

const getSingleCommentHandler (req, res) => {
    res.send(`Get comment route. CommentId ${req.params.commentId}`)
}

module.exports = {
    getCommentsHandler,
    getSingleCommentHandler
}

//---------------------------------------------

// routes/comments.js
const express = require('express');
const {
    getCommentsHandler,
    getSingleCommentHandler
} = require('./controllers/comments.js')

const commentsRouter = express.Router();
commentsRouter.get('/', getCommentsHandler);
commentsRouter.get('/:commentId', getSingleCommentHandler);

module.exports = commentsRouter;

//---------------------------------------------

// routes/index.js
const express = require('express');
const commentsRouter = require('./routes/comments.js');

const router = express.Router();

router.use('/comments', commentsRouter);

module.exports = router;
//---------------------------------------------

// app.js
const express = require('express');
const router = require('./routes/index.js');

const app = express();
app.use(router);
app.listen(5000, () => console.log('Server was started on port 5000'));
                        </pre>

                        <p>Данный паттерн называется Model-View-Controller (MVC)</p>
                    </div>
                </section>

                <section>
                    <h4 id="expressMiddlewares">Middleware в express</h4>

                    <div>
                        <p>Middleware функция выполняется в процессе обработки запроса и отправки ответа.</p>
                        <p>У одного приложения экспресс может быть несколько middlewares и для конкретного маршрута
                            можно применить свой middleware.</p>
                        <p>Middleware может:</p>
                        <ul>
                            <li>Выполнять любой код</li>
                            <li>Изменять объекты request/response</li>
                            <li>Вызвать следующую middleware функцию</li>
                            <li>Завершать цикл запрос-ответ</li>
                        </ul>
                        <p>В случае если middleware не отправляет ответ клиенту - требуется вызвать next() функцию.</p>
                        <p>Базовый пример подключения middleware:</p>
                        <pre>
import express from 'express';
const app = express();

const logger = (req, res, next) => {
    console.log(req.method, req.path);
    next();
}
app.use(logger);
app.get((req, res) => res.send('This is express server'));
app.listen(5000, () => console.log(Server started on port 5000));
                        </pre>

                        <p>Встроенные express middleware:</p>
                        <ul>
                            <li>app.use(express.json()) - данный middleware конвертирует json в объект и присваивает его
                                req.body
                            </li>
                            <li>app.use(express.urlencoded({extended: true})) - данный middleware конвертирует данные
                                формы в объект и присваивает его req.body
                            </li>
                        </ul>
                        <p>Важный сторонний middleware - cors middleware, он нужен для настройки headers, чтобы с
                            клиентского браузера был доступ к требуемому серверу,
                            без настроеных заголовков при запросе на сервер без cors будет пробрасываться ошибка.</p>
                        <p>Следующий пример разрешает все запросы:</p>
                        <pre>
import cors from 'cors';
...
app.use(cors()); // обязательно с вызовом cors
...
                        </pre>
                        <p>Полная настройка cors на <a href="https://www.npmjs.com/package/cors" target="_blank">npmjs.com</a>
                        </p>
                    </div>
                </section>
            </section>
        </section>

        <section id="AlgorithmsAnDataStructuresNav">
            <h2 id="algorithmsHeaderLink">Алгоритмы и структуры данных</h2>

            <section>
                <h4 id="Algorithms">Алгоритмы</h4>
                <div>
                    <p>Алгоритм это набор последовательных действий, которые решают какую-то задачу.</p>
                    <p>Сложность алгоритмов:</p>
                    <ul>
                        <li>O(log2n)</li>
                        <li>O(n)</li>
                        <li>O(n*log2n)</li>
                        <li>O(n*n)</li>
                        <li>O(n!)</li>
                    </ul>
                    <p>Где О - большое специальная аннотация, а n - количество операций(в которой указывают
                        предполагаемый
                        худший результат).</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/AlgorithmsDifficulties.png" alt="AlgorithmsDifficulties">
                    </div>
                    <p><strong>Алгоритм линейного поиска</strong> в массиве начинается с первого элемента, и
                        последовательно
                        сравнивается с каждым элементом искомый элемент.</p>
                    <p><strong>Бинарный поиск</strong> в массиве начинается с середины массива, далее идет сравнение
                        срединного числа с искомым, если искомое число меньше,
                        то отсеиваются числа больше срединного числа, если же больше, то отсеиваются меньшие числа,
                        далее
                        алгоритм повторяется пока искомое число не будет найдено. Массив изначально должен быть
                        отсортирован, если он не отсортирован, то нужно применить другой алгоритм т.к. сортировка будет
                        дольше, чем линейный поиск</p>
                    <p><strong>Поиск в ширину (англ. breadth-first search, BFS)</strong> — один из методов обхода графа.
                        Пусть задан граф
                        G=(V,E) и выделена исходная вершина s. Алгоритм поиска в ширину систематически обходит все ребра
                        G
                        для «открытия» всех вершин, достижимых из s, вычисляя при этом расстояние (минимальное
                        количество
                        рёбер) от s до каждой достижимой из s вершины. Алгоритм работает как для ориентированных, так и
                        для
                        неориентированных графов.</p>
                    <p><strong>Поиск в глубину(Depth-First Search)</strong> второй метод обхода графа. Идея заключается
                        в том,
                        что мы двигаемся от начальной вершины (точки, места) в определенном направлении (по
                        определенному пути)
                        до тех пор, пока не достигнем конца пути или пункта назначения (искомой вершины). Если мы
                        достигли конца
                        пути,
                        но он не является пунктом назначения, то мы возвращаемся назад (к точке разветвления или
                        расхождения
                        путей)
                        и идем по другому маршруту.</p>
                    <p>Пример DFS и BFS алгоритмов для графов разных типов на <a
                            href="https://github.com/Slipbang/algorithms/blob/main/BFS_DFS.js"
                            target="_blank">Гитхабе</a></p>
                    <p><strong>Алгоритм Дейкстры</strong> - это алгоритм поиска кратчайшего пути для одной исходной
                        точки.
                        Основные идеи заключаются в следующем:</p>
                    <ol>
                        <li>
                            Разделите вершины на две части: множество вершин Q, которое уже знает текущий кратчайший
                            путь, и
                            множество недостижимых вершин R.
                        </li>
                        <li>
                            Определите массив расстояний (расстояние), чтобы записать расстояние от исходной точки до
                            каждой
                            вершины. Нижний индекс представляет вершину, а значение элемента - расстояние. Расстояние от
                            исходной точки (начала) до самого себя равно 0, а расстояние между вершиной, которой
                            исходная
                            точка
                            не может достичь, является большим числом (например, бесконечность).
                        </li>
                        <li>
                            Используйте вершину V с бесконечностью в массиве расстояний в качестве точки перехода. Если
                            предположить, что расстояние от V до вершины W плюс расстояние от вершины V до исходной
                            точки
                            меньше, чем расстояние от вершины W до исходной точки, то ее можно обновить. Расстояние от
                            вершины W до исходной точки. То есть расстояние [V] + матрица [V] [W] &lt; расстояние [W],
                            тогда расстояние [W]=расстояние [V] + матрица [V] [W].
                        </li>
                        <li>
                            Повторите предыдущий шаг, который состоит в том, чтобы пройти массив расстояний и не достичь
                            набора вершин R, который пуст.
                        </li>
                    </ol>

                    <p></p>
                </div>
            </section>

            <section>
                <h4 id="dataStructures">Структуры данных</h4>
                <div>
                    <p>Структура данных (англ. data structure) — программная единица, позволяющая хранить и обрабатывать
                        множество однотипных и/или логически связанных данных в вычислительной технике. Для добавления,
                        поиска,
                        изменения и удаления данных структура данных предоставляет некоторый набор функций, составляющих
                        её интерфейс.</p>
                    <p>Очередь(Queue) - это структура данных состоящая из каких-то элементов, основной принцип
                        построения
                        которой - добавление элемента происходит в конец, а извлечение с начала
                        FIFO - first in first out(первый вошел первый вышел)</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/queue.jpeg" alt="queue">
                    </div>

                    <p>Реализация очереди в JS на <a
                            href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/Queue.js"
                            target="_blank">Гитхаб</a></p>

                    <p>Деревья(Tree) - это рекурсивная структура данных, где каждый узел является так же деревом, но для
                        данного дерева каждый узел является поддеревом</p>

                    <div class="smallScreenContainer">
                        <img src="./assets/tree.png" alt="tree">
                    </div>

                    <p>Стек(Stack) - это структура данных, основной принцип построения которой - добавление элемента
                        происходит в конец и извлечение тоже с конца. LIFO - Last in First out(и кладем и берем сверху,
                        основные использующиеся методы push и pop)</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/stack.png" alt="stack">
                    </div>

                    <p>Реализация стэка JS на <a
                            href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/Stack.js"
                            target="_blank">Гитхаб</a></p>

                    <p>Массив(Array) - последовательный набор каких-то объектов. Отличительные особенности массивов -
                        они
                        занимают
                        конкретный участок в памяти и изначально определено,
                        сколько объектов в них будет находиться. Так же, чтобы добавить элемент, нужно создать новый
                        массив,
                        скопировать в него значения из старого и добавить новый элемент</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/arrays.jpeg" alt="arrays">
                    </div>

                    <p>Граф(Graph) - также известный как сеть (Network), представляет собой коллекцию связанных между
                        собой
                        узлов.
                        Бывает два вида графов — ориентированный и неориентированный, в зависимости от того,
                        имеют ли ссылки направление. Графы могут быть представлены в виде списка или матрицы.</p>

                    <div class="smallScreenContainer">
                        <img src="./assets/graph.jpeg" alt="graph">
                    </div>

                    <p>Поиск по графу осуществляется двумя методами — <a
                            href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/BFS_DFS.js"
                            target="_blank">поиск в ширину (Breath-First-Search, BFS) и поиск в глубину
                        (Depth-First-Search,
                        DFS)</a></p>

                    <p>Связный список(Linked List) - каждый отдельный элемент списка занимает отдельный элемент в
                        памяти.
                        Связность
                        списка происходит за счет того, что каждый предыдущий элемент хранит
                        ссылку на следующий элемент который лежит в списке. Можно мгновенно добавлять элементы в конец
                        или
                        начало списка. Чтобы получить какой-то элемент, нужно итерироваться
                        и сравнивать с самого начала списка</p>

                    <div class="smallScreenContainer">
                        <img src="./assets/linkedList.jpeg" alt="Linked list">
                    </div>

                    <p>Реализация Linked List в JS(typeScript) на <a
                            href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/LinkedList.ts">Гитхаб</a>
                    </p>

                    <p>Бинарное дерево поиска(Binary Search Tree) - структура данных, где каждый узел так же является
                        деревом(структура
                        рекурсивна) и у каждого узла может быть только два потомка.
                        Если добавляемое в дерево значение меньше по значению чем текущий угол, то значение уходит в
                        левое
                        поддерево, если больше - то в правое, сравнение происходит с каждым узлом</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/binarySearchTree.png" alt="BST">
                    </div>

                    <p>Реализация деревьев в JS(Binary Search Tree) на <a
                            href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/BST.js"
                            target="_blank">Гитхаб</a>
                    </p>

                    <p>Куча/пирамида(Heap) - по своей структуре напоминает бинарное дерево поиска, но в отличии него
                        имеет
                        следующие требования:</p>
                    <ul>
                        <li>Значение в любой вершине не меньше, чем значения её потомков для max-heap.</li>
                        <li>ЛИБО, значение в любой вершине не больше, чем значения её потомков для min-heap.</li>
                        <li>Глубина всех листьев (расстояние до корня) различается не более чем на 1 слой.</li>
                        <li>Последний слой заполняется слева направо без пропусков.</li>
                    </ul>
                    <p>Пример классической двоичной кучи:</p>
                    <div class="smallScreenContainer">
                        <img src="./assets/maxHeap.png" style="max-width: 400px" alt="maxHeap">
                    </div>

                    <p>Как видно по структуре сортировка ответвлений не обязательна.</p>
                    <p>JS реализация сортировки кучей на <a
                            href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/Heap.js"
                            target="_blank">Гитхаб</a>
                    </p>

                    <p>Map(словарь/карта) - хранит в себе пары "ключ: значение". Основное преимущество, что можно за
                        константное время добавлять (и извлекать) элементы в структуру. Как ключ можно хранить не только
                        строковые значения, но и объекты. В JS включен в дефолтный функционал.</p>
                    <p>Set(множество) - массив, который хранит только уникальные значения. В JS включен в дефолтный
                        функционал.</p>
                </div>
            </section>
        </section>

        <section id="devToolsNav">
            <h2 id="devToolsHeaderLink">Dev Tools</h2>

            <section id="webpackNav">
                <h3 id="webpackBasicsLink">Основы Webpack</h3>

                <section>
                    <h4 id="webpackIntro">Введение. Инициализацния проекта и обозначение проблемы</h4>

                    <div>
                        <p>Мануал по <a href="https://webpack.js.org/guides/" target="_blank">Webpack</a></p>
                        <p>Установка Webpack:</p>
                        <pre>npm install webpack webpack-cli --save-dev</pre>
                    </div>
                </section>

                <section>
                    <h4 id="configurationOpt_env_prodVebBundle">Конфигурация. Опции конфигурации. Переменные окружения.
                        Prod/dev сборка</h4>

                    <div>
                        <p>Мануал <a href="https://webpack.js.org/configuration/" target="_blank">конфигурации</a></p>
                        <p>Минимальная конфигурация webpack.config.js:</p>
                        <pre>
// webpack.config.js

const path = require('path');

module.exports = (env) => {
    return {
        mode: env.mode ?? 'development',
        entry: path.resolve(__dirname, 'src', 'index.js'),
        output: {
            filename: '[name].[contenthash].bundle.js',
            path: path.resolve(__dirname, 'build'),
            clean: true,
        },
    }
};
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="htmlScriptsPlugins">HTML и скрипты. Плагины</h4>

                    <div>
                        <p>Установка готового webpack плагина:</p>
                        <pre>npm i -D html-webpack-plugin</pre>
                        <pre>
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack');


module.exports = (env) => {
    return {
        mode: env.mode ?? 'development',
        entry: path.resolve(__dirname, 'src', 'index.js'),
        output: {
            filename: '[name].[contenthash].bundle.js',
            path: path.resolve(__dirname, 'build'),
            clean: true,
        },
        plugins: [
            new HtmlWebpackPlugin({ template: path.resolve(__dirname, 'public', 'index.html')}),
            new webpack.ProgressPlugin(), // для прода лучше не использовать
        ],
    }
};
                        </pre>
                        <p>Список + документация <a href="https://webpack.js.org/plugins/" target="_blank">Webpack
                            плагинов</a></p>
                    </div>
                </section>

                <section>
                    <h4 id="loaders_typescript_regularExpressions">Лоадеры. Поддержка TypesCript. Регулярные
                        выражения</h4>

                    <div>
                        <p>Лоадеры (loaders) в Webpack — это преобразователи, которые обрабатывают файлы других типов
                            (например, CSS, изображения, TypeScript, JSON) и превращают их в модули, которые могут быть
                            включены в JavaScript.
                            Webpack изначально понимает только JavaScript и JSON, поэтому для обработки других типов
                            файлов необходимы лоадеры.
                            В общих словах лоадеры представляют из себя определенную цепочку обработчиков, через которые
                            проходят файлы с тем или иным расширением.</p>

                        <p>Установка TypeScript для Webpack:</p>
                        <pre>npm install --save-dev typescript ts-loader</pre>
                        <p>Документация для настройки <a href="https://webpack.js.org/guides/typescript/">TypeScript</a>
                        </p>
                        <p>Пример webpack.config.js с TS:</p>
                        <pre>
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const webpack = require('webpack');


module.exports = (env) => {
    return {
        mode: env.mode ?? 'development',
        entry: path.resolve(__dirname, 'src', 'index.ts'),
        output: {
            path: path.resolve(__dirname, 'build'),
            filename: '[name].[contenthash].bundle.js',
            clean: true,
        },
        plugins: [
            new HtmlWebpackPlugin({ template: path.resolve(__dirname, 'public', 'index.html')}),
            new webpack.ProgressPlugin(),
        ],
        module: {
            rules: [
                {
                    test: /\.tsx?$/, // проверка расширений с помощью регулярки
                    use: 'ts-loader',
                    exclude: /node_modules/,
                },
            ],
        },
        resolve: {
            extensions: ['.tsx', '.ts', '.js'],
        },
    }
};
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="tsWebpackConfig">Webpack конфиг на TypeScript</h4>

                    <div>
                        <p>Документация для <a href="https://webpack.js.org/configuration/configuration-languages/">webpack.config.js</a>
                        </p>
                        <p>Пример:</p>
                        <pre>
import path from "path";
import HtmlWebpackPlugin from "html-webpack-plugin";
import webpack from 'webpack';

type TMode = 'production' | 'development';

interface IEncVariables {
    mode: TMode;
}

export default (env: IEncVariables) => {
    const config: webpack.Configuration = {
        mode: env.mode ?? 'development',
        entry: path.resolve(__dirname, 'src', 'index.ts'),
        output: {
            path: path.resolve(__dirname, 'build'),
            filename: '[name].[contenthash].bundle.js',
            clean: true,
        },
        plugins: [
            new HtmlWebpackPlugin({ template: path.resolve(__dirname, 'public', 'index.html')}),
            new webpack.ProgressPlugin(),
        ],
        module: {
            rules: [
                {
                    test: /\.tsx?$/,
                    use: 'ts-loader',
                    exclude: /node_modules/,
                },
            ],
        },
        resolve: {
            extensions: ['.tsx', '.ts', '.js'],
        },
    }

    return config;
};
                        </pre>
                        <p>При использовании ts все импорты можно перевести на ESM синтаксис.</p>
                        <p>В tsconfig.json дополнительно можно поставить флаги "esModuleInterop": true и
                            "allowSyntheticDefaultImports": true.</p>
                        <p><code>esModuleInterop</code> позволяет работать с пакетами, которые используют CommonJS как с
                            обычными пакетами с помощью import,
                            <code>allowSyntheticDefaultImports</code> активирует у ts-loader или babel-loader функцию
                            генерации дефолтных импортов для библиотек,
                            которые их не имеют, благорадя этому можно писать не <code>import * as React from
                                'react'</code>, а <code>import React from 'react'</code></p>
                    </div>
                </section>

                <section>
                    <h4 id="devServer_watchMode_sourceMaps">DevServer. Watch режим. Source maps</h4>

                    <div>
                        <p><a href="https://webpack.js.org/guides/development/" target="_blank">Документация</a> для
                            поднятия DevServer, watch режима и webpack-dev-middleware.</p>
                        <p>DevServer удобно использовать на стадии разработки, позволяет поднимать на локалке сервер с
                            hot reaload.</p>
                        <p>Итоговый webpack.config.js:</p>
                        <pre>
import path from "path";
import HtmlWebpackPlugin from "html-webpack-plugin";
import webpack from 'webpack';
import type { Configuration as DevServerConfiguration } from 'webpack-dev-server'

type TMode = 'production' | 'development';

interface IEncVariables {
    mode: TMode;
    port: number;
}

export default (env: IEncVariables) => {
    const isDev = env.mode === 'development';

    const config: webpack.Configuration = {
        ...
        ...

        devtool: isDev ? 'inline-source-map' : false,
        devServer: isDev ? {
            port: env.port ?? 3000,
            open: true,
        } : undefined,
    }

    return config;
};
                        </pre>
                        <p>Импорт "type { Configuration as DevServerConfiguration }" нужен для протаскивания типа
                            переменной
                            devServer для webpack.Configuration, иначе TS будет выбрасывать ошибку при компиляции!!!</p>
                        <p>Source Map в Webpack — это файл, который служит для сопоставления минифицированного или
                            транслированного
                            кода (например, после сборки или транспиляции) с исходным кодом. Source Map позволяет
                            разработчикам отлаживать код,
                            видя оригинальные строки, файлы и столбцы из исходных файлов, вместо трудно читаемого
                            собранного кода.</p>
                    </div>
                </section>

                <section>
                    <h4 id="react_JSX">React. JSX. Стили. CSS + препроцессоры (SCSS)</h4>

                    <div>
                        <p>При работе с react принципиальных различий нет. Преднастроенного выше пресета
                            webpack.config.js хватит,
                            чтобы установить react/react-dom и работать.</p>
                        <p>Для того чтобы работать с CSS требуется добавить css-loader и style-loader:</p>
                        <pre>
...
rules: [
    {
        test: /\.css$/i,
        use: ['style-loader', 'css-loader'],
        exclude: /node_modules/,
    },
    {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
    },
],
...
                        </pre>
                        <p>Документация <a href="https://webpack.js.org/loaders/css-loader/"
                                           target="_blank">css-loader</a>:</p>
                        <pre>npm install --save-dev css-loader</pre>
                        <p>Документация <a href="https://webpack.js.org/loaders/style-loader/" target="_blank">style-loader</a>:
                        </p>
                        <pre>npm install --save-dev style-loader</pre>

                        <p>В случае если нужен css препроцессор, нужно установить sass-loader:</p>
                        <pre>
...
module: {
    rules: [
        {
            test: /\.s[ac]ss$/i,
            use: [
                // Creates `style` nodes from JS strings
                "style-loader",
                // Translates CSS into CommonJS
                "css-loader",
                // Compiles Sass to CSS
                "sass-loader",
            ],
        },
        {
            test: /\.tsx?$/,
            use: 'ts-loader',
            exclude: /node_modules/,
        },
    ],
},
...
                        </pre>
                        <p>Документация <a href="https://webpack.js.org/loaders/sass-loader/" target="_blank">sass-loader</a>:
                        </p>
                        <pre>npm install sass-loader sass webpack --save-dev</pre>

                        <p>Для того чтобы webpack создавал отдельные минифицированные css файлы нужно использовать
                            mini-css-extract-plugin.</p>
                        <p>Документация <a href="https://webpack.js.org/plugins/mini-css-extract-plugin/"
                                           target="_blank">mini-css-extract-plugin</a>:</p>
                        <pre>npm install --save-dev mini-css-extract-plugin</pre>
                        <p>И так же вместо style-loader нужно использовать MiniCssExtractPlugin.loader:</p>
                        <pre>
import path from "path";
import HtmlWebpackPlugin from "html-webpack-plugin";
import webpack from 'webpack';
import type { Configuration as DevServerConfiguration } from 'webpack-dev-server'
import MiniCssExtractPlugin from "mini-css-extract-plugin";

type TMode = 'production' | 'development';

interface IEncVariables {
    mode: TMode;
    port: number;
}

export default (env: IEncVariables) => {
    const isDev = env.mode === 'development';

    const config: webpack.Configuration = {
        mode: env.mode ?? 'development',
        entry: path.resolve(__dirname, 'src', 'index.tsx'),
        output: {
            path: path.resolve(__dirname, 'build'),
            filename: '[name].[contenthash].bundle.js',
            clean: true,
        },
        plugins: [
            new HtmlWebpackPlugin({ template: path.resolve(__dirname, 'public', 'index.html')}),
            new webpack.ProgressPlugin(),
            new MiniCssExtractPlugin({
                filename: 'css/[name].[contenthash].css',
                chunkFilename: 'css/[name].[contenthash].css'
            }),
        ],
        module: {
            rules: [
                {
                    test: /\.s[ac]ss$/i,
                    use: [
                        MiniCssExtractPlugin.loader,
                        "css-loader",
                        "sass-loader",
                    ],
                },
                {
                    test: /\.tsx?$/,
                    use: 'ts-loader',
                    exclude: /node_modules/,
                },
            ],
        },

        ...
    }

    return config;
};
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="decomposition_reusableConfiguration">Декомпозиция. Переиспользуемая конфигурация</h4>

                    <div>
                        <p>Под декомпозицией подразумевается инкапсуляция параметров возвращаемой в webpack.config.js/ts
                            конфигурации при помощи функций в отдельных файлах:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/webpackConfigDecomposition.png" style="max-width: 400px"
                                 alt="webpackConfigDecomposition">
                        </div>
                        <p>Config возвращаемый в webpack.config.js/ts вызывает билдер функцию buildWebpack, которая
                            содержит в себе конфигурационный скелет:</p>
                        <pre>
import webpack from "webpack";
import type { Configuration as DevServerConfiguration } from 'webpack-dev-server';
import {buildDevServer} from "./buildDevServer";
import {buildLoaders} from "./buildLoaders";
import {buildPlugins} from "./buildPlugins";
import {buildResolver} from "./buildResolver";
import {IBuildOptions} from "./types/types";

export function buildWebpack(options: IBuildOptions): webpack.Configuration {
    const {mode, paths} = options;
    const isDev = mode === 'development';

    return {
        mode: mode ?? 'development',
        entry: paths.entry,
        output: {
            path: paths.output,
            filename: '[name].[contenthash].bundle.js',
            clean: true,
        },
        plugins: <code>buildPlugins(options)</code>,
        module: {
            rules: <code>buildLoaders()</code>,
        },
        resolve: <code>buildResolver(options)</code>,
        devtool: isDev ? 'inline-source-map' : false,
        devServer: isDev ? <code>buildDevServer(options)</code>  : undefined,
    }
}
                        </pre>
                        <p>И каждый параметр в свою очередь вызывает соответсвующую builder функцию:</p>
                        <pre>
import type { Configuration as DevServerConfiguration } from 'webpack-dev-server';
import {IBuildOptions} from "./types/types";

export function <code>buildDevServer</code>({port}: IBuildOptions): DevServerConfiguration {
    return {
        port: port ?? 3000,
        open: true,
    }
}

//----------------------------------------------------------------------------------

import {ModuleOptions} from "webpack";
import MiniCssExtractPlugin from "mini-css-extract-plugin";

export function <code>buildLoaders</code>(): ModuleOptions['rules'] {
    const scssLoader = {
        test: /\.s[ac]ss$/i,
        use: [
            MiniCssExtractPlugin.loader,
            "css-loader",
            "sass-loader",
        ],
    };

    const tsLoader = {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
    };

    return [
        scssLoader,
        tsLoader,
    ];
}

//---------------------------------------------------------------------------------

import webpack, {Configuration} from "webpack";
import HtmlWebpackPlugin from "html-webpack-plugin";
import MiniCssExtractPlugin from "mini-css-extract-plugin";
import {IBuildOptions} from "./types/types";

export function <code>buildPlugins</code>({mode, paths}: IBuildOptions): Configuration['plugins'] {
    const isDev = mode === 'development';

    const plugins: Configuration['plugins'] = [
        new HtmlWebpackPlugin({ template: paths.html}),
        new MiniCssExtractPlugin({
            filename: 'css/[name].[contenthash].css',
            chunkFilename: 'css/[name].[contenthash].css'
        }),
    ]

    if (isDev) plugins.push(new webpack.ProgressPlugin());

    return plugins;
}

//--------------------------------------------------------------------------------------

import {Configuration} from "webpack";
import {IBuildOptions} from "./types/types";

export function <code>buildResolver</code>(options: IBuildOptions): Configuration['resolve'] {
    return {
        extensions: ['.tsx', '.ts', '.js'],
    };
}

//--------------------------------------------------------------------------------------
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="styleIsolation_cssMidules">Изоляция стилей. CSS modules</h4>

                    <div>
                        <p>Для того чтобы не было css коллизий используются css модули.</p>
                        <p>Документация <a href="https://webpack.js.org/loaders/css-loader/#modules" target="_blank">webpack
                            css модулей</a></p>
                        <p>Модули точно такие же как преднастроенные модули в react, так же в названии через точку
                            указывается
                            fileName.module.ext и имеют такой же классовый синтаксис:</p>
                        <pre>
//App.module.scss
.button {
    padding: 5px;
    margin: 5px;

    span {
        color: red;
        font-size: 16px;
    }
}

.button:hover {
    background: green;
}

.button:active {
    background: blue;
}

.value {
    font-size: 50px;
}
                        </pre>
                        <p>В настройках лоадера добавляются следующие параметры:</p>
                        <pre>
import {ModuleOptions} from "webpack";
import MiniCssExtractPlugin from "mini-css-extract-plugin";
import {IBuildOptions} from "./types/types";

export function buildLoaders({mode}: IBuildOptions): ModuleOptions['rules'] {
    const isDev = mode === 'development';
<code>
    const cssModuleLoader = {
        loader: 'css-loader',
        options: {
            modules: {
                localIdentName: isDev ? '[path][name]__[local]' : '[hash:base64:8]'
            },
        }
    }
</code>
    const scssLoader = {
        test: /\.s[ac]ss$/i,
        use: [
            isDev ? 'style-loader' : MiniCssExtractPlugin.loader,
            <code>cssModuleLoader,</code>
            "sass-loader",
        ],
    };

    const tsLoader = {
        test: /\.tsx?$/,
        use: 'ts-loader',
        exclude: /node_modules/,
    };

    return [
        scssLoader,
        tsLoader,
    ];
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="routing_lasyChunks_bundleSize_codeSplit">Роутинг. Ленивые чанки. Размер бандла и код
                        сплитинг</h4>

                    <div>
                        <p>Роутинг очевидно обеспечивает react-router-dom, устанавливаем требуемую версию RRD:</p>
                        <pre>npm i react-router-dom</pre>
                        <p>И как обычно интегрируем в приложение:</p>
                        <pre>
import {createRoot} from "react-dom/client";
import {App} from "./components/App";
import {createBrowserRouter, RouterProvider} from "react-router-dom";
import {LazyAbout} from "./pages/About/About.lazy";
import {LazyShop} from "./pages/Shop/Shop.lazy";
import {Suspense} from "react";

const root = document.getElementById('root');

if (!root) {
    throw new Error('No root found');
}

const container = createRoot(root);

const router = createBrowserRouter([
    {
        path: '/',
        element: &lt;App /&gt;,
        children: [
            {
                path: '/about',
                element: &lt;Suspense fallback={'loading...'}&gt;&lt;LazyAbout /&gt;&lt;/Suspense&gt;
            },
            {
                path: '/shop',
                element: &lt;Suspense fallback={'loading...'}&gt;&lt;LazyShop /&gt;&lt;/Suspense&gt;
            }
        ]
    }
]);

//либо облегченным путем: container.render(&lt;BrowserRouter&gt;&lt;App/&gt;&lt;/BrowserRouter&gt;);

container.render(&lt;RouterProvider router={router} /&gt;);
                        </pre>

                        <p>Так же требуется интегрировать в код &lt;Outlet&gt; для рендера ссылочных компонентов.</p>

                        <p>Чтобы при развернутой локалке работали чанки, нужно в DevServer добавить опцию
                            historyApiFallBack с флагом:</p>
                        <pre>
import type { Configuration as DevServerConfiguration } from 'webpack-dev-server';
import {IBuildOptions} from "./types/types";

export function buildDevServer({port}: IBuildOptions): DevServerConfiguration {
    return {
        port: port ?? 3000,
        open: true,
        <code>historyApiFallback: true,</code>
    }
}
                        </pre>
                        <p>Чтобы сделать чанки ленивыми, делаем lazy реэкспорт:</p>
                        <pre>
//About.tsx
const About = () => {
    return (&lt;h1&gt;About&lt;/h1&gt;)
}

export default About;

//----------------------------------------------------

//About.lazy.tsx
import {lazy} from "react";

export const LazyAbout = lazy(() => import('./About'));
                        </pre>
                        <p>Для легкой инспекции чанков можно использовать плагин <a
                                href="https://github.com/webpack-contrib/webpack-bundle-analyzer">Webpack Bundle
                            Analyzer</a></p>
                        <pre>npm install --save-dev webpack-bundle-analyzer</pre>
                        <p>Использовать как обычный плагин:</p>
                        <pre>
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
...
plugins: [
    new BundleAnalyzerPlugin(),
]
...
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="alias_moduleResolving">Алиасы(псевдонимы) и резолвинг модулей</h4>

                    <div>
                        <p>Алиасы для путей особенно полезны в том случае, когда в проекте присутствует глубокая
                            вложенность компонентов
                            и нужно импортировать компоненты с далеко расположенных уровней.</p>
                        <p>Настройка:</p>
                        <pre>
import {Configuration} from "webpack";
import {IBuildOptions} from "./types/types";

export function buildResolver(options: IBuildOptions): Configuration['resolve'] {
    return {
        extensions: ['.tsx', '.ts', '.js'],
        alias: {
            '@': options.paths.src, // параметр src: path.resolve(__dirname, 'src'),
        }
    };
}
                        </pre>
                        <p>В случае если проект на TypeScript в tsconfig.json обязательно нужно добавить следующие
                            параметры:</p>
                        <pre>
{
  "compilerOptions": {
    "outDir": "./dist/",
    "noImplicitAny": true,
    "module": "ESNext",
    "target": "es5",
    "jsx": "react-jsx",
    "allowJs": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    <code>"baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }</code>
  },
  "ts-node": {
    "compilerOptions": {
      "module": "CommonJS"
    }
  }
}
                        </pre>
                        <p>Впоследствии импортировать можно следующим образом:</p>
                        <pre>
...
import {LazyAbout} from "@/pages/About/About.lazy";
import {LazyShop} from "@/pages/Shop/Shop.lazy";
import {App} from "@/components/App";
...
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="assetsWork">Работа с асетами (картинки, шрифты, иконки и тд)</h4>

                    <div>
                        <p>Для того чтобы обработать png/jpg/jpeg файлы требуется следующий
                            <a href="https://webpack.js.org/guides/asset-management/#loading-images" target="_blank">webpack
                                loader</a>:</p>
                        <pre>
export function buildLoaders({mode}: IBuildOptions): ModuleOptions['rules'] {
    ...

    const assetLoader = {
        test: /\.(png|jpg|jpeg|gif)$/i,
        type: 'asset/resource',
        exclude: /node_modules/,
    }

    ...

    return [..., assetLoader, ...];
}
                        </pre>
                        <p>Чтобы TypeScript не выдавал ошибки и показывал свойства, так же необходимо объявить
                            модули:</p>
                        <pre>
// global.d.ts
// модули для картинок, можно добавить еще расширений:
declare module '*.png';
declare module '*.jpg';
declare module '*.jpeg';

// модули для svg иконок
declare module "*.svg" {
    import React from "react";
    const SVG: React.VFC&lt;React.SVGProps&lt;SVGSVGElement&gt;&gt;
    export default SVG;
}
                        </pre>
                        <p>Теперь импортированные картинки(и svg) можно использовать для передачи их в scr для img
                            тега</p>
                        <pre>
import imageExample from '@/assets/imageExample.png';
...
&lt;img width={300} src={imageExample} alt="imageExample"/&gt;
...
                        </pre>
                        <p>В случае если требуется использовать svg в компонентном стиле (<code>&lt;Svg /&gt;</code>),
                            нужно установить и подключить
                            <a href="https://react-svgr.com/docs/webpack/" target="_blank">svgrLoader</a>:</p>
                        <pre>npm install --save-dev @svgr/webpack</pre>
                        <p>Использование в buildLoaders:</p>
                        <pre>
export function buildLoaders({mode}: IBuildOptions): ModuleOptions['rules'] {
    ...

    const svgrLoader = {
        test: /\.svg$/i,
        issuer: /\.[jt]sx?$/,
        use: [
            {
                loader: '@svgr/webpack',
                options: {
                    icon: true,
                    svgoConfig: {
                        plugins: [
                            {
                                name: 'convertColors',
                                params: {
                                    currentColor: true,
                                }
                            }
                        ]
                    }
                }
            }
        ],
    }

    return [..., svgrLoader];
}
                        </pre>
                        <p>В данном svgrLoader так же используется плагин, который позволяет применять цвет из color
                            атрибута (color: 'red' и тд)</p>
                        <p>В итоге svg можно использовать следующим образом:</p>
                        <pre>
import UlbiIcon from '@/assets/app-image.svg';
import styles from './App.module.scss';
...
&lt;UlbiIcon className={styles.icon} width={50} height={50} /&gt;
...
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="globalBundleVariables_treeShaking">Глобальные переменные сборки. Tree shaking</h4>

                    <div>
                        <p>У webpack есть дефолтный плагин DefinePlugin, он позволяет сделать любую переменную
                            глобально-доступной:</p>
                        <pre>
export function buildPlugins({mode, paths, analyzer, platform}: IBuildOptions): Configuration['plugins'] {
    const isDev = mode === 'development';

    const plugins: Configuration['plugins'] = [
        new HtmlWebpackPlugin({ template: paths.html}),
        new MiniCssExtractPlugin({
            filename: 'css/[name].[contenthash].css',
            chunkFilename: 'css/[name].[contenthash].css'
        }),
        <code>new DefinePlugin({
            __PLATFORM__: JSON.stringify(platform),
        })</code>
    ]

    if (isDev) plugins.push(new webpack.ProgressPlugin());
    if (analyzer) plugins.push(new BundleAnalyzerPlugin());

    return plugins;
}
                        </pre>
                        <p>В качестве аргумента DefinePlugin функции мы передаем объект, где ключ это имя глобальной
                            переменной
                            и застрингованное(JSON.stringify()) значение передается извне через опции и далее можно
                            передать через ENV.</p>
                        <p>В случае если применяется TypeScript, нужно также сделать объявление константы в d.ts
                            файле:</p>
                        <pre>declare const __PLATFORM__: 'mobile' | 'desktop';</pre>
                        <p>Tree shaking это механизм удаления неиспользуемых частей кода, удобно когда для разных версий
                            приложения
                            неиспользуемый код удаляется и итоговый бандл становится меньше. Базовый функционал
                            webpack.</p>
                    </div>
                </section>

                <section>
                    <h4 id="bundlingSpeedUp">Ускорение сборки. Вынос проверки типов в отдельный процесс</h4>

                    <div>
                        <p>В случае если сборка бандла занимает слишком много времени, для ускорения сборки можно
                            вынести проверку типов в отдельный процесс.</p>
                        <p>Для этого в tsLoader можно добавить следующие параметры:</p>
                        <pre>
export function buildLoaders({mode}: IBuildOptions): ModuleOptions['rules'] {
    ...

    const tsLoader = {
        test: /\.tsx?$/,
        use: {
            loader: 'ts-loader',
            <code>options: {
                transpileOnly: true,
            }</code>
        },
        exclude: /node_modules/,
    }

    ...

    return [..., tsLoader, ...];
}
                        </pre>
                        <p>Данная настройка убирает проверку типов из основного процесса сборки, и для того чтобы
                            вернуть проверку,
                            но уже в отдельном процессе требуется установить
                            плагин <a href="https://github.com/TypeStrong/fork-ts-checker-webpack-plugin"
                                      target="_blank">ForkTsCheckerWebpackPlugin</a>:</p>
                        <pre>npm install --save-dev fork-ts-checker-webpack-plugin</pre>
                        <p>Интегрируется в проект как обычно:</p>
                        <pre>
export function buildPlugins({mode, paths, analyzer, platform}: IBuildOptions): Configuration['plugins'] {
    ...

    const plugins: Configuration['plugins'] = [
        ...,
        new ForkTsCheckerWebpackPlugin(),
    ]

    ...

    return plugins;
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="HMR">HMR (Hot Module Replacement)</h4>

                    <div>
                        <p><a href="https://webpack.js.org/guides/hot-module-replacement/" target="_blank">HMR</a> -
                            механизм обновления
                            контента на странице без перезагрузки страницы, по своей сути улучшение hot reload.</p>
                        <p>Полезно в случае, если надо часто дебажить формы, селектора, инпуты и т.д.</p>
                        <p>Для того чтобы подключить HMR в случае, если в проекте нет
                            фреймворков(React/Vue/Angular/ect), достаточно в DevServer подключить hot флаг:</p>
                        <pre>
export function buildDevServer({port}: IBuildOptions): DevServerConfiguration {
    return {
        port: port ?? 3000,
        open: true,
        historyApiFallback: true,
        <code>hot: true,</code>
    }
}
                        </pre>
                        <p>В случае же если фреймворки все-таки используются, нужно установить соответсвующий фреймворку
                            плагин:</p>
                        <p><a href="https://github.com/pmmmwh/react-refresh-webpack-plugin" target="_blank">react-refresh-webpack-plugin</a>
                            для React:</p>
                        <pre>
npm install -D @pmmmwh/react-refresh-webpack-plugin react-refresh
// если есть TypeScript то так же нужно установить типы (un-official integration):
npm install -D react-refresh-typescript
                        </pre>
                        <p>Настройка в проекте с tsLoader:</p>
                        <pre>
import {ModuleOptions} from "webpack";
import MiniCssExtractPlugin from "mini-css-extract-plugin";
import {IBuildOptions} from "./types/types";
import ReactRefreshTypeScript from 'react-refresh-typescript';

export function buildLoaders({mode}: IBuildOptions): ModuleOptions['rules'] {
    ...

    const tsLoader = {
        test: /\.tsx?$/,
        use: {
            loader: 'ts-loader',
            options: {
                transpileOnly: true,
                getCustomTransformers: () => ({
                    before: [isDev && ReactRefreshTypeScript()].filter(Boolean),
                })
            }
        },
        exclude: /node_modules/,
    }

    ...

    return [..., tsLoader, ...];
}
                        </pre>
                        <p>Так же нужно добавить плагин:</p>
                        <pre>
import HtmlWebpackPlugin from "html-webpack-plugin";
import MiniCssExtractPlugin from "mini-css-extract-plugin";
import {IBuildOptions} from "./types/types";
import {BundleAnalyzerPlugin} from "webpack-bundle-analyzer";
import ForkTsCheckerWebpackPlugin from "fork-ts-checker-webpack-plugin";
import ReactRefreshWebpackPlugin from '@pmmmwh/react-refresh-webpack-plugin';

export function buildPlugins({mode, paths, analyzer, platform}: IBuildOptions): Configuration['plugins'] {
    const isDev = mode === 'development';

    const plugins: Configuration['plugins'] = [
        new HtmlWebpackPlugin({ template: paths.html}),
        new MiniCssExtractPlugin({
            filename: 'css/[name].[contenthash].css',
            chunkFilename: 'css/[name].[contenthash].css'
        }),
        new DefinePlugin({
            __PLATFORM__: JSON.stringify(platform),
        }),
        new ForkTsCheckerWebpackPlugin(),
    ]

    if (isDev) {
        plugins.push(new webpack.ProgressPlugin(), new ReactRefreshWebpackPlugin());
    }
    if (analyzer) plugins.push(new BundleAnalyzerPlugin());

    return plugins;
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="copyPlugin">Favicon + copy plugin</h4>

                    <div>
                        <p>Чтобы подключить favicon нужно в HtmlWebpackPlugin добавить favicon свойство, в котором
                            указать путь до иконки:</p>
                        <pre>
new HtmlWebpackPlugin({
    template: paths.html,
    <code>favicon: path.resolve(paths.public, 'favicon.ico')</code>
}),
                        </pre>
                        <p>Для копирования статических файлов можно установить и использовать <a
                                href="https://webpack.js.org/plugins/copy-webpack-plugin/"
                                target="_blank">CopyPlugin</a>:</p>
                        <pre>npm install copy-webpack-plugin --save-dev</pre>
                        <p>Подключение:</p>
                        <pre>
...
import path from "path";
import CopyPlugin from "copy-webpack-plugin";

export function buildPlugins({mode, paths, analyzer, platform}: IBuildOptions): Configuration['plugins'] {
    ...
    const isProd = mode === 'production';

    const plugins: Configuration['plugins'] = [
        ...
    ]

    if (isProd) {
        plugins.push(
            <code>new CopyPlugin({
                patterns: [
                    {from: path.resolve(paths.public, 'locales'), to: path.resolve(paths.output, 'locales')},
                ]
            }))</code>
    }
    ...

    return plugins;
}
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="babel">Babel. Создаем свой плагин</h4>

                    <div>
                        <p><a href="https://babeljs.io" target="_blank">Babel</a> — транспайлер, который преобразует
                            код, написанный на современном JavaScript (ES6+), в совместимый
                            с более старыми версиями JavaScript (ES5 и ниже), чтобы его можно было выполнять в различных
                            окружениях,
                            включая устаревшие браузеры. </p>

                        <p>Чтобы Babel правильно работал с фреймворками, ему нужно установить и настроить пресеты.</p>
                        <p>Установка babel для webpack + установка требуемых пресетов:</p>
                        <pre>
// установка Babel
npm install --save-dev babel-loader @babel/core

// react preset
npm install --save-dev @babel/preset-react

// typescript preset
npm install --save-dev @babel/preset-typescript
                        </pre>
                        <p>Замена tsLoader на babelLoader + добавление установленных пресетов в массив presets:</p>
                        <pre>
export function buildLoaders({mode}: IBuildOptions): ModuleOptions['rules'] {
    const isDev = mode === 'development';

    ...

    const babelLoader = {
        test: /\.tsx?$/, // поставить требуемое расширение файла!!!
        exclude: /node_modules/,
        use: {
            loader: "babel-loader",
            options: {
                presets: [ // пресеты
                    '@babel/preset-env',
                    '@babel/preset-typescript',
                    [ // react пресет нужно дополнительно настроить
                        '@babel/preset-react',
                        {
                            runtime: isDev ? 'automatic' : 'classic',
                        }
                    ],
                ]
            }
        }
    }

    ...

    return [
        ...
        // tsLoader,
        babelLoader,
        ...
    ];
}
                        </pre>
                        <p>Все настройки которые передаются в presets можно вынести в babel.config.json например если
                            конфиг так же нужен для jest:</p>
                        <pre>
// babel.config.json
{
        "presets": [
            "@babel/preset-env",
            "@babel/preset-typescript",
            [
                "@babel/preset-react",
                {
                    "runtime": "automatic",
                }
            ],
        ]
    }
}
                        </pre>
                        <p>babelLoader так же желательно декомпозировать из webpack buildLoader файла тк этот лоадер
                            может тоже сильно разрастись.</p>
                        <p>Для babelLoader так же можно написать свой плагин, рассмотрим пример
                            с <a href="https://www.npmjs.com/package/@types/babel__core">babel__core</a> библиотекой:
                        </p>
                        <pre>
// устанавливаем babel__core
npm i -D @types/babel__core

//------------------------------------------------------------

import {PluginItem} from "@babel/core";

export function removeDataTestIdBabelPlugin(): PluginItem {
    return {
        visitor: {
            Program(path, state) {
                const forbiddenProps = state.opts.props || [];

                path.traverse({
                    JSXIdentifier(current) {
                        const nodeName = current.node.name;

                        if (forbiddenProps.includes(nodeName)) {
                            current.parentPath.remove();
                        }
                    }
                })
            }
        }
    }
}
                        </pre>
                        <p>Подключаем плагин к babelLoader:</p>
                        <pre>
import {IBuildOptions} from "../types/types";
import {removeDataTestIdBabelPlugin} from "./removeDataTestIdBabelPlugin";

export function buildBabelLoader({mode}: IBuildOptions) {
    const isDev = mode === 'development';
    const isProd = mode === 'production';

    const plugins = [];

    if (isProd) {
        plugins.push([
            removeDataTestIdBabelPlugin,
            {
                props: ['data-testid']
            }
        ])
    }

    return {
        test: /\.tsx?$/,
        exclude: /node_modules/,
        use: {
            loader: "babel-loader",
            options: {
                presets: [
                    '@babel/preset-env',
                    '@babel/preset-typescript',
                    [
                        '@babel/preset-react',
                        {
                            runtime: isDev ? 'automatic' : 'classic',
                        }
                    ],
                ],
                plugins: plugins.length ? plugins : undefined,

            }
        }
    }
}
                        </pre>
                        <p>Данный плагин удаляет data-testid атрибут тегов в конечно prod билде.</p>
                    </div>
                </section>

                <section>
                    <h4 id="sourceMapыDetails">Source maps детальный разбор</h4>

                    <div>
                        <p>Source maps в Webpack позволяют сопоставлять скомпилированный JavaScript-код с исходным,
                            чтобы упростить отладку и отображение ошибок в удобном виде. Это особенно полезно, когда
                            исходный код написан на языке,
                            который компилируется в JavaScript (например, TypeScript, CoffeeScript или ES6+).</p>
                        <p>Допустим у нас есть код, который выдает по тем или иным причинам ошибку:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/webpackSourceMaps.png" alt="webpackSourceMaps">
                        </div>
                        <p>В случае если source maps отключены devTools в Source вкладке покажет нечитаемый
                            скомпилированный код:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/webpackTurnedOffSourceMaps.png" alt="webpackTurnedOffSourceMaps">
                        </div>
                        <p>В случае же если source maps включены, код будет точно такой же как в компоненте:
                        <div class="smallScreenContainer">
                            <img src="./assets/webpackTurnedOnSourceMaps.png" alt="webpackTurnedOnSourceMaps">
                        </div>
                        <p>Настройка включающая source maps - devtool:</p>
                        <pre>
import webpack from "webpack";
import type { Configuration as DevServerConfiguration } from 'webpack-dev-server';
import {buildDevServer} from "./buildDevServer";
import {buildLoaders} from "./buildLoaders";
import {buildPlugins} from "./buildPlugins";
import {buildResolver} from "./buildResolver";
import {IBuildOptions} from "./types/types";

export function buildWebpack(options: IBuildOptions): webpack.Configuration {
    const {mode, paths} = options;
    const isDev = mode === 'development';

    return {
        mode: mode ?? 'development',
        entry: paths.entry,
        output: {
            path: paths.output,
            filename: '[name].[contenthash].bundle.js',
            clean: true,
        },
        plugins: buildPlugins(options),
        module: {
            rules: buildLoaders(options),
        },
        resolve: buildResolver(options),
        <code>devtool: isDev ? 'eval-cheap-module-source-map' : 'source-map',</code>
        devServer: isDev ? buildDevServer(options)  : undefined,
    }
}
                        </pre>
                        <p>Возможные параметры <a href="https://webpack.js.org/configuration/devtool/" target="_blank">devtool</a>.
                        </p>
                    </div>
                </section>

                <section>
                    <h4 id="monorepository">Монорепозиторий. Конфигурация проекта + workspaces</h4>

                    <div>
                        <p>Монорепозиторий во фронтенд-разработке — это подход к управлению исходным кодом, при котором
                            все связанные
                            проекты и их зависимости хранятся в одном репозитории. Вместо того чтобы разрабатывать и
                            поддерживать
                            каждую часть приложения в отдельном репозитории, разработчики объединяют их в одном
                            месте.</p>

                        <p>Основные особенности монорепозитория:</p>
                        <ul>
                            <li>Единое хранилище кода: Все приложения, библиотеки, утилиты, компоненты и конфигурации
                                находятся в одном репозитории.
                            </li>
                            <li>Совместное управление зависимостями: Библиотеки и пакеты, используемые в нескольких
                                частях проекта, могут обновляться централизованно.
                            </li>
                            <li>Упрощенная разработка: Легче отслеживать изменения, устранять конфликты и тестировать
                                код, так как все части системы доступны в одном месте.
                            </li>
                            <li>Централизованная CI/CD: Единая система для автоматического тестирования, сборки и
                                деплоя.
                            </li>
                        </ul>
                        <p>Плюсы:</p>
                        <ul>
                            <li>Упрощенное управление зависимостями: Обновление библиотек в одном месте сразу для всех
                                проектов.
                            </li>
                            <li>Единый стандарт: Общие правила форматирования, линтинга и конфигурации (например,
                                ESLint, Prettier).
                            </li>
                            <li>Ускорение разработки: Легче взаимодействовать с кодом разных проектов, так как они
                                находятся "под одной крышей".
                            </li>
                            <li>Согласованность версий: Упрощенная работа с совместимыми версиями пакетов.</li>
                        </ul>
                        <p>Минусы:</p>
                        <ul>
                            <li>Масштабируемость: С ростом проекта репозиторий может становиться слишком большим,
                                усложняя клонирование и работу.
                            </li>
                            <li>Ограничения инструментов: Некоторые инструменты и системы контроля версий могут плохо
                                справляться с огромными монорепозиториями.
                            </li>
                            <li>Риск ошибок: Неправильные изменения могут повлиять сразу на множество проектов.</li>
                        </ul>
                        <div class="smallScreenContainer">
                            <img src="./assets/monorepo.png" alt="monorepo">
                        </div>

                        <p>Общая структура монорепозитория выглядит следующим образом:</p>
                        <div class="smallScreenContainer" style="max-width: 400px">
                            <img src="./assets/monorepoStructure.png" alt="monorepoStructure">
                        </div>

                        <p>Корневой package.json имеет отличную от обычного package настройку, вместо dependencies в нем
                            настраивается массив workspaces:</p>
                        <pre>
// package.json
{
  "name": "monorepo-module-federation",
  "version": "1.0.0",
  "workspaces": [
    "packages/*",
    "services/*"
  ]
}
                        </pre>
                        <p>Папка services содержит микрофронтенды(отдельные фронтенд приложения):</p>
                        <div class="smallScreenContainer" style="max-width: 400px">
                            <img src="./assets/monorepoServicesStructure.png" alt="monorepoServicesStructure">
                        </div>
                        <p>В корне services можно сделать tsconfig.base.json, который будет содержать общую для всех
                            микрофронтендов конфигурацию:</p>
                        <pre>
// tsconfig.base.json
{
  "compilerOptions": {
    "noImplicitAny": true,
    "module": "ESNext",
    "target": "es5",
    "jsx": "react-jsx",
    "allowJs": true,
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "resolveJsonModule": true
  },
  "ts-node": {
    "compilerOptions": {
      "module": "CommonJS"
    }
  }
}
                        </pre>
                        <p>tsconfig.json микрофронтендов при таком подходе должны обязательно иметь extends опцию, для
                            расширения основного tsconfig.base.json:</p>
                        <pre>
// tsconfig.json для "shop" мирофронтенда:
{
  <code>"extends": "../tsconfig.base.json",</code>
  "compilerOptions": {
    "outDir": "./dist/",
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
                        </pre>

                        <p>Папка packages содержит переиспользуемый код и общая конфигурация:</p>
                        <div class="smallScreenContainer" style="max-width: 400px">
                            <img src="./assets/monorepoPackagesStructure.png" alt="monorepoPackagesStructure">
                        </div>
                        <p>В директории "shared" переиспользуемый общий код(компоненты, функции и тд),
                            а в "build-config" общие для всех микрофронтендов настройки webpack, babel и тд</p>
                        <p>Глобально настройка webpack для монорепозиториев не отличается от настройки для стандартного
                            приложения,
                            за исключением требования плагина ModuleFederationPlugin, который будет рассмотрен далее,
                            а так же желательно сделать реэкспорт кастомного buildWebpack модуля и типов:.</p>
                        <pre>
// ./packages/build-config/src/index.ts

export {buildWebpack} from './buildWebpack';
export type {TBuildMode, IBuildPaths, IBuildOptions, TBuildPlatform} from './types/types';
                        </pre>
                    </div>
                </section>

                <section>
                    <h4 id="microServicesConfig_moduleFederation">Конфигурация микросервисов. Module federation</h4>

                    <div>
                        <p>package.json каждого микросервиса должен иметь в зависимостях содержимое директорий shared и
                            build-config!</p>
                        <p>Пример package.json для "shop" микросервиса(остальные имеют тот же принцип):</p>
                        <pre>
{
  "name": "shop",
  "version": "1.0.0",
  "scripts": {
    "start": "webpack serve --open",
    "build:dev": "webpack --env mode=development",
    "build:prod": "webpack --env mode=production",
    "build:mobile": "webpack --env mode=production --env platform=mobile",
    "build:desktop": "webpack --env mode=production --env platform=desktop"
  },
  "dependencies": {
    <code>"@packages/shared": "*",
    "@packages/build-config": "*",</code>
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.16.0"
  },
  "devDependencies": {
    "@babel/core": "^7.23.2",
    "@babel/preset-react": "^7.22.15",
    "@babel/preset-typescript": "^7.23.2",
    "@types/babel__core": "^7.20.3",
    "@types/node": "^20.8.3",
    "@types/react": "^18.2.25",
    "@types/react-dom": "^18.2.11",
    "@types/webpack": "^5.28.3",
    "@types/webpack-bundle-analyzer": "^4.7.0",
    "@types/webpack-dev-server": "^4.7.2",
    "babel-loader": "^9.1.3",
    "copy-webpack-plugin": "^11.0.0",
    "css-loader": "^6.8.1",
    "fork-ts-checker-webpack-plugin": "^9.0.0",
    "html-webpack-plugin": "^5.5.3",
    "mini-css-extract-plugin": "^2.7.6",
    "sass": "^1.69.0",
    "sass-loader": "^13.3.2",
    "style-loader": "^3.3.3",
    "ts-loader": "^9.5.0",
    "ts-node": "^10.9.1",
    "typescript": "^5.2.2",
    "webpack": "^5.88.2",
    "webpack-bundle-analyzer": "^4.9.1",
    "webpack-cli": "^5.1.4",
    "webpack-dev-server": "^4.15.1",
    "@pmmmwh/react-refresh-webpack-plugin": "^0.5.11",
    "@svgr/webpack": "^8.1.0",
    "react-refresh-typescript": "^2.0.9"
  }
}
                        </pre>
                        <p>А каждый webpack.config.js/js иметь дополнительный плагин <a
                                href="https://webpack.js.org/plugins/module-federation-plugin/" target="_blank">ModuleFederationPlugin</a>:
                        </p>
                        <pre>
import path from "path";
import webpack from 'webpack';
import {IBuildPaths, TBuildMode, TBuildPlatform, buildWebpack, IBuildOptions} from '@packages/build-config';
<code>import packageJson from './package.json';</code>

interface IEncVariables {
    mode?: TBuildMode;
    port?: number;
    analyzer?: boolean;
    platform?: TBuildPlatform;
    SHOP_REMOTE_URL?: string;
    ADMIN_REMOTE_URL?: string;
}

export default (env: IEncVariables) => {
    const paths: IBuildPaths = {
        output: path.resolve(__dirname, 'build'),
        entry: path.resolve(__dirname, 'src', 'index.tsx'),
        html: path.resolve(__dirname, 'public', 'index.html'),
        src: path.resolve(__dirname, 'src'),
        public: path.resolve(__dirname, 'public')
    }

    const SHOP_REMOTE_URL = env.SHOP_REMOTE_URL ?? 'http://localhost:3001';
    const ADMIN_REMOTE_URL = env.ADMIN_REMOTE_URL ?? 'http://localhost:3002';

    const config: webpack.Configuration = buildWebpack({
        port: env.port ?? 3000,
        mode: env.mode ?? 'development',
        paths,
        analyzer: env.analyzer ?? false,
        platform: env.platform ?? 'desktop',
    });

    <code>config.plugins.push(new webpack.container.ModuleFederationPlugin({
        name: 'host',
        filename: 'remoteEntry.js',
        remotes: {
            shop: `shop@${SHOP_REMOTE_URL}/remoteEntry.js`,
            admin: `admin@${ADMIN_REMOTE_URL}/remoteEntry.js`,
        },
        shared: {
            ...packageJson.dependencies,
            react: {
                eager: true,
                requiredVersion: packageJson.dependencies['react'],
            },
            'react-router-dom': {
                eager: true,
                requiredVersion: packageJson.dependencies['react-router-dom'],
            },
            'react-dom': {
                eager: true,
                requiredVersion: packageJson.dependencies['react-dom'],
            }
        }
    }))</code>

    return config;
};
                        </pre>
                        <p>Где:</p>
                        <ul>
                            <li>name - имя контейнера</li>
                            <li>filename - задаёт имя файла, который будет содержать точку входа (entry point) для
                                модуля или микрофронтенда.
                            </li>
                            <li>remotes - настройка удалённых модулей (микрофронтендов или модулей), которые могут быть
                                загружены динамически в приложение.
                                Она позволяет подключать другие приложения или модули, предоставленные как удалённые
                                (remote),
                                чтобы использовать их компоненты или функциональность.
                            </li>
                            <li>shared - используется для указания зависимостей, которые должны быть разделяемыми
                                (shared)
                                между приложением и подключаемыми удалёнными модулями.
                            </li>
                        </ul>
                        <p>Примечание для filename - Имя файла должно быть уникальным: Если в одном приложении
                            подключается несколько удалённых модулей,
                            убедитесь, что каждый из них использует уникальное имя для filename, чтобы избежать
                            конфликтов.
                            Если filename не указано, Webpack по умолчанию создаст файл с именем remoteEntry.js.</p>
                        <p>shared имеет следующие опции:</p>
                        <ul>
                            <li><code>singleton</code> (логическое значение): Указывает, что данная зависимость должна
                                быть единственной для всех микрофронтендов.
                            </li>
                            <li><code>strictVersion</code> (логическое значение): Если true, Webpack выбросит ошибку,
                                если версии библиотеки в разных приложениях не совпадают.
                            </li>
                            <li><code>requiredVersion</code> (строка): Указывает требуемую версию зависимости, с которой
                                приложение совместимо.
                            </li>
                            <li><code>eager</code> (логическое значение): Если true, зависимость будет загружаться сразу
                                же при загрузке приложения, а не по запросу. Это может быть полезно для критически
                                важных модулей.
                            </li>
                            <li><code>import</code> (логическое значение или строка): Если false, зависимость не будет
                                автоматически импортироваться из node_modules. Если это строка, указывается путь для
                                импорта.
                            </li>
                        </ul>

                        <p>В каждом микросервисе код в index.tsx нужно переместить в bootstrap.tsx, а в самом index.tsx
                            сделать следующий реэкспорт:</p>
                        <pre>
import('./bootstrap');
export {}
                        </pre>
                        <p>Код в bootstrap.tsx</p>
                        <pre>
import {createRoot} from "react-dom/client";
import {RouterProvider} from "react-router-dom";
import {router} from "@/router/Router";

const root = document.getElementById('root');

if (!root) {
    throw new Error('No root found');
}

const container = createRoot(root);

container.render(&lt;RouterProvider router={router} /&gt;);
                        </pre>
                        <p>И так же необходимо декомпозировать createBrowserRouter в отдельный Router.tsx файл</p>
                        <pre>
import {createBrowserRouter} from "react-router-dom";
import {App} from "@/components/App";
import {Suspense} from "react";
import {LazyAbout} from "@/pages/About/About.lazy";

const routes = [
    {
        path: '/admin',
        element: &lt;App /&gt;,
        children: [
            {
                path: '/admin/about',
                element: &lt;Suspense fallback={'loading...'}&gt;&lt;LazyAbout /&gt;&lt;/Suspense&gt;
            },
        ]
    }
]

export const router = createBrowserRouter(routes);
export default routes;
                        </pre>

                        <p>Для хостового приложения декомпозировать Router с особыми настройками для children:</p>
                        <pre>
import {createBrowserRouter} from "react-router-dom";
import {App} from "@/components/App";

import shopRoutes from 'shop/Router';
import adminRoutes from 'admin/Router';

export const router = createBrowserRouter([
    {
        path: '/',
        element: &lt;App /&gt;,
        children: [
            ...shopRoutes,
            ...adminRoutes
        ]
    }
]);
                        </pre>
                        <p>Для shopRoutes и adminRoutes нужно объявить модули в global.d.ts, и использовать их в
                            children массиве,
                            это ссылки на routes из дочерних микросервисов. Т.е. дочерние микросервисы монтируются на
                            прямую в основной хостовый,
                            и да они при этом имеют свой отдельный порт.</p>

                        <p>Весь код с <a href="https://github.com/Slipbang/monorepo-module-federation" target="_blank">monorepo-module-federation
                            на Github</a>.</p>
                    </div>
                </section>
            </section>

            <section id="viteNav">
                <h3 id="viteBasicsLink">Vite</h3>

                <section>
                    <h4 id="viteGettingStarted">Getting Started</h4>

                    <div>
                        <p>Конкретно с Vite разжевывать что-то смысла нет - это сборщик очень похожий на webpack, только
                            упрощенный.</p>
                        <p>Далее описан только quick start, т.к. документация сжатая, без воды и достаточно простая,
                            чтобы подключить что-либо по ходу написания проекта.</p>
                        <p>Сайт с гайдом: <a href="https://vite.dev/guide/" target="_blank">https://vite.dev/guide/</a>
                        </p>
                        <p>Создание проекта:</p>
                        <pre>npm create vite@latest &lt;projectName&gt;</pre>
                        <p>Далее выбираем шаблон проекта, vanilla/vue/react и т.д., если надо то ts тоже в наличии.</p>
                        <p>Скрипты package.json старта/билда/превью:</p>
                        <pre>
{
  "scripts": {
    "dev": "vite", // start dev server, aliases: `vite dev`, `vite serve`
    "build": "vite build", // build for production
    "preview": "vite preview" // locally preview production build
  }
}
                        </pre>
                        <p></p>
                    </div>
                </section>
            </section>

            <section id="git_githubNav">
                <h3 id="git_github_basics">Основы Git и GitHub</h3>

                <section>
                    <h4 id="GitVSGitHub">Разница между Git и GitHub</h4>

                    <div>
                        <p>Git - распределенная система управления версиями.</p>
                        <p>Преимущества Git:</p>
                        <ul>
                            <li>Позволяет сохранять различные версии проектов</li>
                            <li>Быстрый переход между различными версиями проекта</li>
                            <li>Откат к предыдущим версиям при необходимости</li>
                            <li>Улучшает процесс командной разработки над одими и теми же проектами</li>
                            <li>Независимая одновременная разработка различных новых функций в проекте</li>
                        </ul>

                        <p>Разница между Git и GitHub: Git это распределенная система контроля версий(технология),
                            GitHub же это сервис хостинга Git репозиториев(сервис-продукт).</p>
                        <p>Git - РАСПРЕДЕЛЕННАЯ система, т.к. на каждом компьютере находится полная версия репозитория
                            (это позволяет работать с гит даже без интернета).</p>
                    </div>

                </section>

                <section>
                    <h4 id="shellCommand">Команды консоли</h4>

                    <div>
                        <div class="tableWrapper">
                            <table class="jsTheoryTable">
                                <thead>
                                <tr>
                                    <th>action</th>
                                    <th>PowerShell</th>
                                    <th>Linux Shell</th>
                                </tr>
                                </thead>
                                <tbody>
                                <tr>
                                    <td>Переход в папку</td>
                                    <td><code>cd ./Desktop</code></td>
                                    <td><code>cd ~/Desktop</code></td>
                                </tr>
                                <tr>
                                    <td>Создание новой папки</td>
                                    <td colspan="2"><code>mkdir my-project</code></td>
                                </tr>
                                <tr>
                                    <td>Переход в папку</td>
                                    <td colspan="2"><code>cd my-project</code></td>
                                </tr>
                                <tr>
                                    <td>Создание файла с текстом</td>
                                    <td colspan="2"><code>echo "Some text" &gt; file.txt</code></td>
                                </tr>
                                <tr>
                                    <td>Список файлов в папке</td>
                                    <td><code>dir</code></td>
                                    <td><code>ls</code></td>
                                </tr>
                                <tr>
                                    <td>Чтение файла</td>
                                    <td><code>type file.txt</code></td>
                                    <td><code>cat file.txt</code></td>
                                </tr>
                                <tr>
                                    <td>Удаление файла</td>
                                    <td><code>del file.txt</code></td>
                                    <td><code>rm file.txt</code></td>
                                </tr>
                                <tr>
                                    <td>Копирование файла</td>
                                    <td><code>copy source.txt destination.txt</code></td>
                                    <td><code>cp source.txt destination.txt</code></td>
                                </tr>
                                <tr>
                                    <td>Перемещение файла</td>
                                    <td><code>move file.txt new-folder\</code></td>
                                    <td><code>mv file.txt new-folder/</code></td>
                                </tr>
                                <tr>
                                    <td>Переименование файла</td>
                                    <td><code>rename oldname.txt newname.txt</code></td>
                                    <td><code>mv oldname.txt newname.txt</code></td>
                                </tr>
                                <tr>
                                    <td>Очистка терминала</td>
                                    <td><code>cls</code></td>
                                    <td><code>clear</code></td>
                                </tr>
                                <tr>
                                    <td>Просмотр процессов</td>
                                    <td><code>tasklist</code></td>
                                    <td><code>ps aux</code></td>
                                </tr>
                                <tr>
                                    <td>Вывод содержимого с паузой</td>
                                    <td colspan="2"><code>more file.txt</code></td>
                                </tr>
                                <tr>
                                    <td>Поиск файлов</td>
                                    <td><code>dir /s filename.txt</code></td>
                                    <td><code>find . -name "filename.txt"</code></td>
                                </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="gitRepoCreation">Создание нового репозитория Git</h4>

                    <div>
                        <p>Качаем и устанавливаем <a href="https://git-scm.com/downloads" target="_blank">Git</a></p>
                        <p>После установки Git необходимо настроить имя и email:</p>
                        <pre>
git config --global user.name &lt;user name&gt;
//имя без знаков, но если нужно указать "имя фамилия", то требуются двойные кавычки

git config --global user.email &lt;user email&gt;
//емейл так же без знаков
                        </pre>

                        <p>Получение списка всех настроек Git:</p>
                        <pre>git config --list</pre>

                        <p>Для создания нового Git репозитория либо открываем папку с помощью IDE и вводим команду ниже,
                            либо с помощью Shell переходим к нужной папке и выполняем эту команду уже в консоли:</p>
                        <pre>git init</pre>
                        <p>В папке к которой мы применили git инициализацию, появляется скрытая папка .git</p>
                    </div>
                </section>

                <section>
                    <h4 id="gitAreas">Области гит</h4>

                    <div>
                        <p>Рабочая директория(working directory) - та область Git, которая содержит файлы и папки,
                            видимые в проекте.</p>
                        <p>Индекс(staging area) - в эту область добавляются файлы, до сохранения в
                            репозиторий(добавленные(new file) или измененные файлы(modified)).</p>
                        <p>Репозиторий(repository) - то, что находится в папке .git/objects.</p>
                    </div>
                </section>

                <section>
                    <h4 id="mainCommands">Подготовка и сохранение изменений и перемещение между версиями</h4>

                    <div>
                        <p>Чтобы подготовить файлы к сохранению(добавить файлы в индекс), в консоль требуется ввести
                            команду:</p>
                        <pre>
git add &lt;file name&gt;
// добавляет определенный файл

// или

git add .
// добавляет все изменения
                    </pre>

                        <p>Чтобы сохранить изменения(добавить файлы в репозиторий), в консоль нужно ввести команду:</p>
                        <pre>git commit</pre>

                        <p>Если требуется перейти к определенной версии проекта, в консоль нужно ввести команду:</p>
                        <pre>git checkout</pre>
                    </div>
                </section>

                <section>
                    <h4 id="fileStatuses">Статусы отслеживания файлов</h4>

                    <div>
                        <p>Существуют 4 статуса отслеживания файлов:</p>
                        <ul>
                            <li>Untracked(не отслеживаемый)</li>
                            <li>Staged(подготовленный)</li>
                            <li>Unmodified(не модифицированный)</li>
                            <li>Modified(модифицированный)</li>
                        </ul>
                    </div>
                </section>

                <section>
                    <h4 id="gitObjectTypes">Типы объектов в Git</h4>

                    <div>
                        <ul>
                            <li>Blob (файл)</li>
                            <li>Tree (папка)</li>
                            <li>Commit (коммит)</li>
                            <li>Annotated Tag (аннотированный тег)</li>
                        </ul>

                        <p>Каждый объект в Git имеет уникальный id (SHA1 хэш)</p>
                        <p>Хэш SHA1 имеет фиксированную длину 160 бит, 40 шестнадцатеричных символов.</p>
                        <p>Название tree папки основано на первых двух символах хеша, название файла внутри этой папки,
                            основано на остальных символах.</p>
                    </div>
                </section>

                <section>
                    <h4 id="commitInfo">Что такое коммит</h4>

                    <div>
                        <p>Коммит - это указатель на дерево.</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/commitInfo.png" alt="commitInfo">
                        </div>
                        <p>Как у любого объекта Git у коммита есть свой:</p>
                        <ul>
                            <li>SHA1 хэш</li>
                            <li>Имя и email автора</li>
                            <li>Описание коммита</li>
                            <li>Родительский(е) коммит(ы), каждый следующий коммит, ссылается на предыдущий(е)
                                коммит(ы)!!!
                            </li>
                            <li>Дерево</li>
                        </ul>

                        <p>Первый коммит - корневой коммит. Каждый коммит ссылается на предыдущий, и так до корневого,
                            образуя структуру похожую на linked list.
                            В Git есть определенный указатель - head, который ссылается на определенный коммит,
                            благодаря head мы видим версию проекта,
                            на коммит которой ссылается head.</p>
                        <p>Но как правило head ссылается не на коммит, а на ветку, которая уже ссылается на коммит:</p>
                        <pre>
rootCommit(1) &lt;- commit2 &lt;- commit3 &lt;- commit4
                                    main ^
                                head ^
                        </pre>

                        <p>При создании коммита Git автоматически передвигает указатель ветки на последний коммит.</p>
                    </div>
                </section>

                <section>
                    <h4 id="mainGitCommands">Основные команды Git</h4>

                    <div>
                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>command</th>
                                <th>description</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td><code>git status</code></td>
                                <td>Отображает текущее состояние Git репозитория</td>
                            </tr>
                            <tr>
                                <td><code>git add &lt;files&gt;</code></td>
                                <td>Подготовка файлов перед коммитом</td>
                            </tr>
                            <tr>
                                <td><code>git commit -m "&lt;message&gt;"</code></td>
                                <td>Создание коммита с записью изменений в репозиторий</td>
                            </tr>
                            <tr>
                                <td><code>git log</code></td>
                                <td>Просмотр истории изменений (коммитов)</td>
                            </tr>
                            <tr>
                                <td><code>git checkout &lt;commit hash&gt;</code></td>
                                <td>Переход в определенную версию проекта по SHA1 хэшу коммита</td>
                            </tr>
                            <tr>
                                <td><code>git checkout &lt;branch name&gt;</code></td>
                                <td>Переход в определенную версию проекта по названию ветки</td>
                            </tr>
                            <tr>
                                <td><code>git branch &lt;branch name&gt;</code></td>
                                <td>Создание новой ветки</td>
                            </tr>
                            <tr>
                                <td><code>git branch</code></td>
                                <td>Отображает список всех веток</td>
                            </tr>
                            <tr>
                                <td><code>git branch -m &lt;branch new name&gt;</code></td>
                                <td>Переименовывание текущей ветки</td>
                            </tr>
                            <tr>
                                <td><code>git branch -d &lt;branch name&gt;</code></td>
                                <td>Удаление ветки(текущую ветку удалить нельзя)</td>
                            </tr>
                            <tr>
                                <td><code>git merge &lt;feature branch name&gt;</code></td>
                                <td>Слияние другой ветки(feature branch) в текущую ветку(receiving branch)</td>
                            </tr>
                            <tr>
                                <td><code>git push</code></td>
                                <td>Переносит изменения с локального репозитория в удаленный</td>
                            </tr>
                            <tr>
                                <td><code>git pull</code></td>
                                <td>Переносит изменения с удаленного репозитория в локальный</td>
                            </tr>
                            <tr>
                                <td><code>git clone &lt;url&gt;</code></td>
                                <td>Клонирование удаленного репозитория в локальный</td>
                            </tr>
                            <tr>
                                <td><code>git branch -a</code></td>
                                <td>Отображает все ветки, включая те, которые находятся в удаленных репозиториях</td>
                            </tr>
                            <tr>
                                <td><code>git remote add origin &lt;url&gt;</code></td>
                                <td>Подключение удаленного репозитория</td>
                            </tr>
                            <tr>
                                <td><code>git push -u origin &lt;branch&gt;</code></td>
                                <td>Загрузка изменений из локальной ветки в удаленную с созданием связи между ними</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="branch_Creation_Merge">Создание и слияние ветвей</h4>

                    <div>
                        <p>Ветка - ссылка на коммит.

                        <p>Для того чтобы создать ветку и сразу к ней перейти можно использовать следующую консольную
                            команду:</p>
                        <pre>git checkout -b &lt;branch name&gt;</pre>

                        <p>Слияние веток необходимо когда разработка дополнительной ветки закончена, и требуется слияние
                            в основную ветку.
                            В таком случае создается коммит со слиянием, и этот коммит будет иметь двух предков,
                            предыдущий и конечный коммит ветки слияния.
                            Такой коммит называется merge(объединяющий) коммит</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/mergeCommit.png" alt="mergeCommit">
                        </div>
                        <p>Команда слияния веток:</p>
                        <pre>git merge &lt;feature branch name&gt;</pre>
                        <p>Следует перейти в ветку в которую будет merge(receiving branch), и ввести команду с именем
                            ветки слияния(feature branch).</p>
                    </div>
                </section>

                <section>
                    <h4 id="gitHub_creatingRemoteRepo">GitHub и создание удаленных репозиториев</h4>

                    <div>
                        <p>Origin - имя удаленного репозитория по-умолчанию</p>
                        <p>После клонирования удаленного репозитория можно проверить в нем все ветки, включая те, что
                            находятся в удаленных репозиториях:</p>
                        <pre>git branch -a</pre>
                        <p>Для создания собственного репозитория в GitHub, в своей учетной записи заходим в:</p>
                        <code>&gt; Repositories &gt; New</code>
                        <p>Заполняем <code>Repository name, Description</code> и тд, кликаем <code>Create
                            repository</code>.</p>
                        <p>Далее по полученной ссылке привязываем свой локальный УЖЕ ИНИЦИАЛИЗИРОВАННЫЙ репозиторий к
                            удаленному:</p>
                        <pre>
git remote add origin https://guthub.com/&lt;user-name&gt;/&lt;project-name&gt;.git
git branch -M main
git push -u origin main
                        </pre>
                        <p>Чтобы иметь возможность пушить изменения нужен либо access токен, либо если IDE позволяет -
                            зайти со своего аккаунта GitHub в IDE(например в WebStorm).</p>
                        <p>Так же на самом GitHub в репозитории можно создавать файлы: <code>&gt; Add File &gt; Create
                            new file &gt;</code>.
                            При создании файла можно записать имя с расширением и содержимое файла</p>
                    </div>
                </section>

                <section>
                    <h4 id="linkinRepos">Связывание локальных и удаленных репозиториев</h4>

                    <div>
                        <p>Связь существующего локального репозитория с удаленным:</p>
                        <pre>git remote add origin &lt;url&gt;</pre>
                        <p>Где "origin" это имя для репозитория, и называть его возможно как угодно.</p>

                        <p>При первой загрузке изменений из локальной ветки main, на удаленный сервер под названием
                            origin,
                            требуется связать локальную ветку main с соответствующей удаленной веткой:</p>
                        <pre>git push -u origin &lt;branch&gt;</pre>
                        <p>При этом название локальной ветки и удаленной могут отличаться, но как правило они
                            одинаковы</p>
                        <p>После первого связывающего пуша, можно использовать обычный <code>git push</code> и <code>git
                            pull</code>.</p>
                    </div>
                </section>
            </section>

            <section id="dockerNav">
                <h3 id="dockerHeaderLink">Docker</h3>

                <section>
                    <h4 id="dockerBasics">Основы Docker</h4>

                    <div>

                    </div>
                </section>

                <section>
                    <h4 id="dockerInstall">Установка Docker в Linux и Windows</h4>

                    <div>
                        <p>Все дистрибутивы и дефолт мануал можно найти на <a href="https://docs.docker.com">docs.docker.com</a>
                        </p>
                        <p>Ру мануал по установке для <a href="https://youtu.be/O8N1lvkIjig?si=2phWaEFHQaCBp3eG&t=1170"
                                                         target="_blank">Linux (Ubuntu) / Windows</a></p>
                    </div>
                </section>

                <section>
                    <h4 id="mainDockerCommands">Основные команды</h4>

                    <div>
                        <table class="jsTheoryTable">
                            <thead>
                            <tr>
                                <th>Linux command</th>
                                <th>PowerShall command</th>
                                <th>description</th>
                            </tr>
                            </thead>
                            <tbody>
                            <tr>
                                <td><code>service docker status</code></td>
                                <td><code>Get-Service -Name "com.docker.service"</code></td>
                                <td>Проверка состояния службы Docker</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker ps -a</code></td>
                                <td>Получить список контейнеров</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker inspect &lt;containerId&gt;</code></td>
                                <td>Получение всей информации по контейнеру</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker logs &lt;containerId&gt;</code></td>
                                <td>Получение логов контейнера</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker run &lt;imageName&gt;</code></td>
                                <td>Создание контейнера</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker start &lt;containerId&gt;</code></td>
                                <td>Запуск уже созданного контейнера</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker pause/unpause &lt;containerId&gt;</code></td>
                                <td>Пауза/снятие с паузы созданного контейнера</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker stop &lt;containerId&gt;</code></td>
                                <td>Остановка контейнера</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker kill &lt;containerId&gt;</code></td>
                                <td>Быстрая остановка контейнера</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker rm &lt;containerId&gt;</code></td>
                                <td>Удаление контейнера</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker images</code></td>
                                <td>Просмотр images</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker rmi &lt;imageName&gt;</code></td>
                                <td>Удаление image</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker pull &lt;imageName&gt;</code></td>
                                <td>Скачивание требуемого image</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker exec -it &lt;containerId&gt; /bin/bash</code></td>
                                <td>Подключение к консоли контейнера</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker system prune -a --volumes</code></td>
                                <td>Полная очистка Docker</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker volume ls</code></td>
                                <td>Просмотр всех volume</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker volume create &lt;volumeName&gt;</code></td>
                                <td>Создание volume</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker volume rm &lt;volumeName/id&gt;</code></td>
                                <td>Удаление volume по имени/id</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker network create --driver &lt;networkType&gt; &lt;networkName&gt;</code>
                                </td>
                                <td>Создание сети</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker network inspect &lt;networkName/Id&gt;</code></td>
                                <td>Получение параметров сети</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker network rm &lt;networkName/Id&gt;</code></td>
                                <td>Удаление сети</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>docker network connect &lt;networkName&gt; &lt;containerName/id&gt;</code>
                                </td>
                                <td>Присоединение к сети</td>
                            </tr>

                            <tr>
                                <td colspan="2"><code>network disconnect &lt;networkId&gt;
                                    &lt;containerName/id&gt;</code></td>
                                <td>Отсоединение контейнера от сети</td>
                            </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <section>
                    <h4 id="portMapping">Управление портами: Port Mapping</h4>

                    <div>
                        <p>Для того чтобы открыть внешний порт контейнера, нужно использовать команду со следующей
                            конфигурацией:</p>
                        <pre>docker run <code>-p 8080:80</code> nginx</pre>
                        <p>Где 8080 это внешний порт, а 80 - порт контейнера.</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/dockerOpenPort.png" alt="dockerOpenPort">
                        </div>
                    </div>
                </section>

                <section>
                    <h4 id="environmentVariables">Переменные в Docker: Environment Variables</h4>

                    <div>
                        <p>Пример задания переменной при старте контейнера:</p>
                        <pre>docker run --name DB-mysql <code>-e MYSQL_ROOT_PASSWORD=pw123456qwerty</code> -d mysql</pre>
                        <p>Как правило в документации(блок Environment Variables) контейнера указаны все переменные
                            которые могут использоваться в нем.</p>
                        <p>Чтобы задать переменную можно использовать следующий синтаксис:</p>
                        <pre>export VARIABLE_NAME=variableValue</pre>
                    </div>
                </section>

                <section>
                    <h4 id="dockerVolumes">Постоянные данные: Docker Volumes</h4>

                    <div>
                        <p>При запуске приложения, данные сохраняются в определенной директории, и в случае если
                            контейнер останавливается или уничтожается - данные теряются.</p>
                        <p>В случае если нужно оставить данные при остановке или уничтожении контейнера - данные нужно
                            сохранять на самом сервере или на хосте.
                            Такие данные называются сохраняющимися данными (<code>Persisting data</code>)</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/persistingData.png" alt="persistingData">
                        </div>

                        <p>Существует три способа монтировки данных на физический сервер:</p>
                        <p><code>Host Volumes:</code></p>

                        <div class="smallScreenContainer">
                            <img src="./assets/hostVolumes.png" alt="hostVolumes">
                        </div>

                        <p><code>Anonymous Volumes:</code></p>

                        <div class="smallScreenContainer">
                            <img src="./assets/anonymousVolumes.png" alt="anonymousVolumes">
                        </div>

                        <p><code>Named Volumes:</code></p>

                        <div class="smallScreenContainer">
                            <img src="./assets/namedVolumes.png" alt="">
                        </div>

                        <p>Действия с volume:</p>

                        <ul>
                            <li>Просмотр всех volume: <code>docker volume ls</code></li>
                            <li>Создание volume: <code>docker volume create &lt;volumeName&gt;</code></li>
                            <li>Удаление volume по имени/id: <code>docker volume rm &lt;volumeName/id&gt;</code></li>
                        </ul>

                        <p>Для сохранения данных обязательно нужно использовать или Host volumes или Named
                            volumes!!!</p>
                    </div>
                </section>

                <section>
                    <h4 id="dockerNetwork">Сети в Docker. Network</h4>

                    <div>
                        <p>При запуске Docker мы получаем несколько типов сетей по умолчанию:</p>

                        <ul>
                            <li><code>bridge:</code> docker0: 172.17.0.0/16</li>
                            <li><code>host:</code> ServerIP(10.15.11.12)</li>
                            <li><code>none</code></li>
                            <li><code>macvlan</code></li>
                            <li><code>ipvlan</code></li>
                            <li><code>overlay</code> (Docker Swarm Cluster)</li>
                        </ul>

                        <p><code>bridge</code> создается когда мы запускаем команду <code>docker run
                            &lt;imageName&gt;</code></p>
                        <p><code>host</code> создается когда мы запускаем команду <code>docker run &lt;imageName&gt;
                            --network=host</code></p>
                        <p><code>none</code> создается когда мы запускаем команду <code>docker run &lt;imageName&gt;
                            --network=none</code></p>

                        <p>Для создания именования сети типа <code>bridge</code> нам требуется ввести следующие команды:
                        </p>
                        <pre>
docker network create --driver bridge NAME
docker run --net myNAME nginx
                        </pre>

                        <p>Для сети типа <code>Host</code> подход тот же:</p>
                        <pre>
docker network create --driver host NAME
docker run --net myNAME nginx
                        </pre>

                        <p>Для <code>None</code> подход тот же:</p>
                        <pre>
docker network create --driver none NAME
docker run --net myNAME nginx
                        </pre>

                        <p>И Host и None могут быть созданы только один раз.</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/networkSettings.png" alt="networkSettings">
                        </div>

                        <p>Устройство macvlan | ipvlan</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/lanNetworkSettings.png" alt="lanNetworkSettings">
                        </div>

                        <p>network команды:</p>

                        <ul>
                            <li>Создание сети: <code>docker network create --driver &lt;networkType&gt; &lt;networkName&gt;</code>
                            </li>
                            <li>Получение параметров сети: <code>docker network inspect &lt;networkName/Id&gt;</code>
                            </li>
                            <li>Удаление сети: <code>docker network rm &lt;networkName/Id&gt;</code></li>
                            <li>Присоединение контейнера к сети: <code>docker network connect &lt;networkName&gt; &lt;containerName/id&gt;</code>
                            </li>
                            <li>Отсоединение контейнера от сети: <code>network disconnect &lt;networkId&gt; &lt;containerName/id&gt;</code>
                            </li>
                        </ul>

                        <p>Пример создание собственной сети, со своими параметрами:</p>
                        <pre><code>docker network create -d bridge --subnet 192.168.10.0/24 --gateway 192.168.10.1 myNet192</code></pre>

                        <p>Пример запуска macvlan с диапазоном ip адресов:</p>
                        <pre><code>docker network create -d macvlan --subnet 192.168.100.0/24 --gateway 192.168.100.1 --ip-range 192.168.100.99/32 -o parent=eth0 myMACvlan</code></pre>
                    </div>
                </section>

                <section>
                    <h4 id="dockerfile">Создание своих контейнеров. Dockerfile</h4>

                    <div>
                        <p>В Dockerfile входит (+ примеры):</p>
                        <ul>
                            <li>Базовый образ (image): <code>FROM ubuntu:22.04</code></li>
                            <li>Описание образа: <code>LABEL author=Slipbang</code></li>
                            <li>Команды: <code>RUN apt-get upgrade / RUN apt-get install nginx -y</code></li>
                            <li>Рабочие директории: <code>WORKDIR /var/www/html</code></li>
                            <li>Файлы: <code>COPY files2/script.sh /opt/script.sh</code></li>
                            <li>Работа с файлами: <code>RUN chmod +x /opt/script.sh</code></li>
                            <li>Указание переменных: <code>ENV OWNER="Slipbang" / ENV TYPE=demo</code></li>
                            <li>Порты: <code>EXPOSE 80</code></li>
                            <li>Описание команд при запуске контейнера: <code>ENTRYPOINT ["echo"] / CMD ["Hello my first
                                Docker"]</code></li>
                        </ul>
                        <p>Для построения образа из текущей директории с докерфайлом:</p>
                        <pre>docker build -t &lt;imageName&gt; .</pre>

                        <p>ENTRYPOINT - фиксированная команда! Команда CMD может быть перезаписана.</p>
                    </div>
                </section>

                <section>
                    <h4 id="dockerCompose">Docker Compose. Применение</h4>

                    <div>
                        <p>Docker compose:</p>
                        <ul>
                            <li>Используется для управления одним или несколькими контейнерами</li>
                            <li>Содержит инструкции по запуску контейнера(ов)</li>
                            <li>Упрощает автоматизацию запуска контейнеров</li>
                            <li>Описывается в YAML файле: docker-compose.yml</li>
                        </ul>

                        <p>Пример формирования docker-compose.yml:</p>
                        <div class="smallScreenContainer">
                            <img src="./assets/dockerCompose.png" alt="dockerCompose">
                        </div>

                        <p>Пример docker-compose.yml для фулстэк приложения:</p>

                        <div class="smallScreenContainer">
                            <img src="./assets/dockerComposeMultiservices.png" alt="dockerComposeMultiservices">
                        </div>
                        <p>Запуск docker compose(текущая директория): <code>docker compose up -d</code></p>
                        <p>остановка docker compose: <code>docker compose down/stop</code></p>
                    </div>
                </section>

                <section>
                    <h4 id="portainer">Portainer - Web UI для управления Docker</h4>

                    <div>
                        <p>Portainer - web-ориентированный графический интерфейс Docker для Windows и Linux</p>
                        <p>Видео гайд по <a href="https://youtu.be/O8N1lvkIjig?si=sgo3DolAHL52oVUv&t=16349"
                                            target="_blank">portainer</a></p>
                        <p>Установка <a href="https://docs.portainer.io/start/install/server" target="_blank">portainer.io</a>
                        </p>
                        <p>Для быстрого запуска portainer.io можно так же сделать docker compose:</p>
                        <pre>
#docker run -d
#  -p 8000:8000
#  -p 9443:9443
#  --name portainer
#  --restart=always
#  -v /var/run/docker.sock:/var/run/docker.sock
#  -v portainer_data:/data
#  portainer/portainer-ee:2.21.5

services:
  portainer:
    image: portainer/portainer-ee:2.21.5
    container_name: portainer
    environment:
      - TZ=Europe/Berlin
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - ./portainer_data:/data
    ports:
      - "8000:8000"
      - "9000:9000" // или " 9443:9443"
    restart: always
                        </pre>
                    </div>
                </section>
            </section>
        </section>

        <section id="functionalProgrammingNav">
            <h2 id="functionalProgramming">Функциональное программирование</h2>

            <section>
                <h4 id="procedures_functions">Общие понятия. Процедуры и функции</h4>

                <div>
                    <p>JavaScript - мультипарадигменный язык программирования.
                        Поддерживает объектно-ориентированный, императивный и функциональный стили.</p>

                    <p>Четыре основные вытекающие из ФП концепции:</p>
                    <ol>
                        <li>Декларативность</li>
                        <li>Чистые функции</li>
                        <li>Функции первого класса/ Функции высшего порядка</li>
                        <li>Иммутабельность</li>
                    </ol>

                    <p>Условный псевдо-код процедуры:</p>
                    <pre>
procedure(a,b): void {
    number = read();
    result = sqrt(variable);
    writeFile(result);
}
                    </pre>

                    <p>Условный псевдо-код функции:</p>
                    <pre>
function(a,b): number {
    number = read();
    result = sqrt(variable);
    return result;
}
                    </pre>

                    <p>В функциональном программировании с функциями работают как с математическими функциями.</p>
                    <pre>
f(x) = x*x + x + 5;
f(5) = 25 + 5 + 5;
f(x,y) = x*y + 10;
f(5,0) = 5*0 + 10;
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="declarativeness">Декларативность</h4>

                <div>
                    <p>Код можно писать в декларативном и императивном стиле.
                        Декларативность простыми словами - что хотим получить? - Т.е. Описываем результат.
                        Императивность - как хотим получить? - Описываем действия.</p>

                    <p>В любом случае, на верхнем уровне будет императивный код, но, чем выше мы его будем поднимать,
                        тем проще нам будет переиспользовать определенные куски кода и соответственно уменьшить общее
                        его количество.</p>
                    <p>Пример декларативного подхода:</p>
                    <pre>
const filterUserByField = (country) => (user): boolean => users.country === country;
const calcAvgAge = (avg, user) => (avg += user.age);

function calcUsersAverageAge(users, country) {
    return sortByAge(users)
        .filter(filterUsersByField(country))
        .reduce(calcAvgAge)
}
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="pureFunctions">Чистые функции и сайд эффекты</h4>

                <div>
                    <p>Ярким примером чистой функции - обычная математическая функция:</p>
                    <pre>
f(x) = x*x + 5;
                    </pre>

                    <p>Суть чистой функции заключается в том, что если мы в нее передаем одни и те же аргументы,
                        она <span class="underlinedT">всегда</span> возвращает один и тот же ответ.
                        НО при этом у нее не должно быть никаких сайд эффектов!</p>
                    <p>Тривиальный пример чистой функции:</p>
                    <pre>
function multiplyPure(a,b) {
    return a*b;
}
                    </pre>

                    <p>Пример не чистой функции:</p>
                    <pre>
function multiplyImpure(a,b) {
    return a * b * Math.random();
}
                    </pre>
                    <p>Так же такие функции не зависят от внешнего состояния и глобальных переменных.</p>

                    <p>Пример не чистой функции с глобальной переменной:</p>
                    <pre>
const MODIFIER = 5;

function multiplyImpureWithModifier(a, b) {
    return a * b * MODIFIER;
}
                    </pre>

                    <p>Т.к. внешняя переменная может быть переписана, такая функция не может быть чистой!</p>

                    <p>Так же функция не будет чистой если мы взяли глобальную переменную и изменили ее.
                        Отпадает риск того что кто-то сломает функцию при изменении переменной, но теперь поломать код
                        можем уже мы.</p>

                    <pre>
let MODIFIER = 10;

function multiplyImpureWithLet(a, b) {
    MODIFIER = 15;
    return a * b * modifier;
}
                    </pre>

                    <p>Последний критерий чистоты - отсутствие сайд эффектов:</p>

                    <pre>
async function multiplyImpureWithFetch(a,b) {
    const response = await fetch(input: '/get/modifier');
    const {modifier} = response.json;
    return a * b * modifier;
}
                    </pre>

                    <p>Даже если сервер всегда возвращает одно и то же число, тем не менее, функция не может считаться
                        чистой, ибо нет гарантии результата.</p>

                    <p>Хороший пример чистой функции - стандартные redux редьюсеры:</p>
                    <pre>
function reducer(state = initialState, action) {
    switch(action.type) {
        case 'INCREASE_VALUE': {
            return {...state, value: state.value + action.value}
        }
        case 'SET_DATA': {
            return {...state, value: action.data}
        }
        default:
            return state;
    }
}
                    </pre>
                    <p>(P.s. Слава Аллаху в redux-toolkit в store завезли Immer.) Immer оборачивает объект в Proxy,
                        благодаря чему функции можно писать в мутабельном стиле ибо proxy самостоятельно оперирует
                        иммутабельностью под капотом.</p>
                </div>

            </section>

            <section>
                <h4 id="immutability">Иммутабельность</h4>

                <div>
                    <p>Иммутабельность - неизменяемость данных, в функциональных языкак программирования из коробки.
                        В ФП - это аксиома, что данные мутировать НЕЛЬЗЯ.</p>

                    <pre>
const users = [{name: 'John'}, {name: 'Peter'}];

function actionWIthUsers(userList) {
    userList.splice(1);
}

console.log(actionWithUsers(users)); // [{name: 'Peter'}]
console.log(users); // [{name: 'John'}]
                    </pre>
                </div>

                <p>splice функция является мутабельным методом, она вырезает элементы из массива с индекса переданного
                    первым аргументом
                    и возвращает массив с этим элементом по элемент с индексом переданным вторым аргументом.
                    Без глубокой копии объектов данным методом оперировать не рекомендуется.</p>

                <p>Мутабельные методы массивов:</p>
                <ul>
                    <li>push() – добавляет элементы в конец</li>
                    <li>pop() – удаляет последний элемент</li>
                    <li>shift() – удаляет первый элемент</li>
                    <li>unshift() – добавляет элементы в начало</li>
                    <li>splice(start, deleteCount, ...items) – удаляет/добавляет элементы</li>
                    <li>sort(compareFn) – сортирует элементы (меняет порядок)</li>
                    <li>reverse() – переворачивает массив</li>
                    <li>fill(value, start, end) – заполняет массив значениями</li>
                    <li>copyWithin(target, start, end) – копирует элементы внутри массива</li>
                </ul>

                <p>Иммутабельные методы массивов</p>
                <ul>
                    <li>map(callbackFn) – создает новый массив, применяя функцию</li>
                    <li>filter(callbackFn) – создает новый массив с отфильтрованными элементами</li>
                    <li>slice(start, end) – создает новый массив из части старого</li>
                    <li>concat(...arrays) – объединяет массивы в новый</li>
                    <li>reduce(callbackFn, initialValue) – сводит массив к одному значению</li>
                    <li>flat(depth) – возвращает новый массив, разворачивая вложенные массивы</li>
                    <li>flatMap(callbackFn) – аналог map(), но с объединением вложенных массивов</li>
                    <li>toSorted(compareFn) – возвращает отсортированную копию массива (ES2023)</li>
                    <li>toReversed() – возвращает перевернутую копию массива (ES2023)</li>
                    <li>toSpliced(start, deleteCount, ...items) – изменяет копию массива (ES2023)</li>
                </ul>

                <p>Мутабельные методы объектов</p>
                <ul>
                    <li>Object.assign(target, source) – изменяет target, копируя свойства source
                    <li>
                    <li>Object.defineProperty(obj, key, descriptor) – изменяет свойства объекта
                    <li>
                    <li>Object.defineProperties(obj, descriptors) – изменяет несколько свойств
                    <li>
                    <li>delete obj.key – удаляет свойство из объекта
                    <li>
                    <li>Reflect.set(obj, key, value) – устанавливает значение свойства
                    <li>
                    <li>Reflect.deleteProperty(obj, key) – удаляет свойство объекта
                    <li>
                </ul>

                <p>Иммутабельные методы объектов</p>
                <ul>
                    <li>Object.assign({}, obj) – создает копию объекта
                    <li>
                    <li>structuredClone(obj) – создает глубокую копию объекта
                    <li>
                    <li>{ ...obj } (spread) – поверхностное копирование объекта
                    <li>
                    <li>Object.create(proto, propertiesObject) – создает новый объект с указанным прототипом
                    <li>
                    <li>Object.freeze(obj) – делает объект неизменяемым
                    <li>
                    <li>Object.seal(obj) – запрещает добавление/удаление свойств, но разрешает изменение
                    <li>
                    <li>Object.getOwnPropertyDescriptors(obj) – получает все дескрипторы свойств
                    <li>
                    <li>JSON.parse(JSON.stringify(obj)) – глубокая копия (не всегда корректная)
                    <li>
                </ul>

                <p>Пример неправильной функции сортировки:</p>
                <pre>
function actionWithUsers(userList) {
    const copyUsers = userList.sort();
    return copyUsers;
}
                </pre>
                <p>Как было бы правильно:</p>
                <pre>
function actionWithUsers(userList) {
    const sortedUsersCopy = [...userList].sort();
    return sortedUsersCopy;
}
                </pre>

                <p>Так же не стоит забывать, что spread, Object.assign создают <span
                        class="underlinedT">не глубокие</span> копии!
                    Глубокую копию создает structuredClone, но его поддержка еще не 100%.
                    Метод JSON.stringify(JSON.parse(obj)) хорош где нет linked list и в целом ссылочных зависимостей.
                    Для остальных кастомные библиотеки.</p>

                <p>Почему мутировать данные плохо?</p>
                <ul>
                    <li>Несогласованность данных</li>
                    <li>Неявные побочные эффекты</li>
                    <li>Усложняет дебаг и тестирование</li>
                </ul>

                <p>Плюсы иммутабельности:</p>
                <ul>
                    <li>Иммутабельные структуры данных потокобезопасны</li>
                    <li>Проще отслеживать жизненный цикл объекта</li>
                </ul>

                <p>(P.s. К плюсам так же можно отнести большое спасибо от клиентов с низкой частотой ЦП,
                    офисники вообще в восторге будут, цветы слать, звонить поблагодарить за хороший сайт.
                    Цикличный возврат глубокого клона конского массива объектов при заполнении новыми объектами это прям
                    bestpractice.
                    И ошибок самое главное нет.)</p>

                <p>Желательно анализировать, где применять иммутабельность, иногда дешевле запушить новый объект в
                    большой массив,
                    нежели чем возвращать dipClone с изменениями на каждой итерации ибо сложность у пуша O(1),
                    а при иммутабельном способе O(n * m * ... зависит от структуры).</p>


            </section>

            <section>
                <h4 id="firstOrderFunctions">Функции первого класса</h4>

                <div>
                    <p>Функции - объекты первого класса, объект типа Function.
                        Функции первого класса означают, что функции на этом языке рассматриваются как любая другая
                        переменная.
                        Т.е. мы можем возвращать ее в другой функции, передавать аргументом, присваивать переменной и
                        т.д.</p>
                </div>
            </section>

            <section>
                <h4 id="highOrderFunctions">Функции высшего/первого порядка</h4>

                <div>
                    <p>Функции высшего порядка - функции которые принимают аргументом или возвращают другую функцию.</p>

                    <pre>
const firstOrderFunc = () => console.log("Hello, I am a First order function");
const higherOrder = (ReturnFirstOrderFunc) => ReturnFirstOrderFunc();
higherOrder(firstOrderFunc);
                    </pre>

                    <p>Функция первого порядка — это функция, которая не принимает другую функцию
                        в качестве аргумента и не возвращает функцию в качестве возвращаемого значения.</p>
                    <pre>
const firstOrder = () => console.log("I am a first order function!");
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="Composition_Pipe">Композиция/конвейер</h4>

                <div>
                    <p>Композиция(compose) - это функция, которая создает новую функцию в которой СПРАВА НА ЛЕВО
                        передается результат
                        выполнения переданным в качестве аргумента массиву функций</p>

                    <pre>
function compose(...functions: Function[]): Function {
    return function (firstArgument) {
        return functions.reduceRight((acc,fn) => fn(acc), firstArgument);
    }
}

const doubleSortedArray = compose(doubleNumbers, sortArr, compact);
doubleSortedArray([1,5,3,1,2,4,undefined,0,null]) // [0,2,2,4,6,8,10]
                    </pre>

                    <p>Конвейер(pipe) - это функция, которая создает новую функцию, в которой СЛЕВА НА ПРАВО передается
                        результат
                        выполнения переданным в качестве аргумента массиву функций</p>

                    <pre>
function Pipe(...functions: Function[]): Function {
    return function (firstArgument) {
        return functions.reduce((acc,fn) => fn(acc), firstArgument);
    }
}

const doubleSortedArray = compose(compact, sortArr, doubleNumbers);
doubleSortedArray([1,5,3,1,2,4,undefined,0,null]) // [0,2,2,4,6,8,10]
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="partialApplication_Currying">Частичное применение и каррирование</h4>

                <div>
                    <a href="#JSbasicsForEmployment14">Определение написано выше.</a>
                    <p>Код функции каррирования:</p>
                    <pre>
function curry(fn) {
    return function curried(...args) {
        if (args.length => fn.length) {
            return fn.apply(this, args);
        } else {
            return function(...newArgs) {
                return curried.apply(this, args.concat(newArgs));
            }
        }
    }
}
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="chaining">Chaining</h4>

                <div>
                    <p>Chaining - любые цепочки вызовов функций.</p>

                    <p>Тривиальный пример кода с chaining</p>
                    <pre>
new Array(20)
    .map(callback)
    .filter(callback)
    .reduce(callback)
    .map(callback)
                    </pre>
                </div>
            </section>

            <section>
                <h4 id="containers">Контейнеры</h4>

                <div>
                    <p>Код контейнера:</p>
                    <pre>
class Container {
    protected $value: number;

    private constructor(x: number) {
        this.$value = x;
    }

    static of(x: number) {
        return new Container(x);
    }

    map(fn: Function) {
        return Container.of(fn(this.$value));
    }

    join() {
        return this.$value;
    }

    chain(fn: Function) {
        return this.map(fn).join();
    }
}

const add5 = (x: number) => x + 5;
const square = (x: number) => x * x;
const contOf100 = Container.of(5).map(add5).chain(square);
console.log(contOf100); // 100
                    </pre>

                    <p>Получается "инкапсуляция" данных внутри контейнера</p>
                </div>
            </section>

            <section>
                <h4 id="functors_applicativeFunctors">Функторы и аппликативные функторы</h4>

                <div>
                    <p>Контейнер который написан в предыдущем разделе уже является функтором.</p>
                    <p>Функтор - класс типов, для которых определена map функция и выполняется ряд правил:</p>
                    <ul>
                        <li>x.map(f).map(g) = f(g(x)) - закон композиции</li>
                        <li>x.map(value => value) = x - закон идентичности</li>
                    </ul>
                    <p>Map - применяет функцию к внутреннему состоянию, сохраняя при этом свою структуру и поведение.</p>
                </div>
            </section>

            <section>
                <h4 id="monads">Монады</h4>

                <div>
                    <p>Монады - реализация интерфейса функтора.(Either/Maybe)</p>
                    <p>Из спецификации fantasy-land следует, что монады должны содержать в себе следующие методы:</p>
                    <ul>
                        <li>chain</li>
                        <li>аппликативный функтор</li>
                        <li>apply</li>
                    </ul>

                    <p>Пример монады Maybe</p>

                    <pre>
class Maybe {
    protected $value: any;
    constructor(x: any) {
        this.$value = x;
    }

    static of(x: number) {
        return new Maybe(x);
    }

    get isNothing() {
        return this.$value === null || this.$value === undefined;
    }

    join() {
        return this.$value;
    }

    map(fn: Function): Maybe {
        return this.isNothing ? this : Maybe.of(fn(this.$value));
    }

    chain(fn: Function) {
        return this.map(fn).join();
    }

    orElse(defaultValue: any, fn: Function) {
        return this.isNothing ? Maybe.of(defaultValue).map(fn) : this.map(fn);
    }
}
                    </pre>
                </div>
            </section>

            <section>
                <h4>Аппликативный функтор</h4>

                <div>
                    <p>Аппликативный функтор(Applicative functor) - функтор, который реализует метод apply (ap)</p>
                    <pre>
map(fn: Function) {
    return this.isNothing ? this : Maybe.of(fn(this.$value));
}

ap(functor: Maybe) {
    return functor.map(this.$value);
}
                    </pre>

                    <pre>
Maybe.of(curriedSum).ap(Maybe.of(25)).ap(Maybe.of(7)); {$value: 32};
                    </pre>

                    <p>ap работает с КОНТЕЙНЕРАМИ!</p>
                </div>
            </section>

            <section>
                <h4 id="fantasy-land-specification">Спецификация Fantasy-Land</h4>

                <div>
                    <div class="smallScreenContainer">
                        <img src="./assets/fantasyLand.png" alt="fantasyLand">
                    </div>
                </div>
            </section>
        </section>
    </div>
</main>

<div id="navMenu" class="navButtonsStyles">
    <div id="navMenuButtons" class="displayNoneClass"></div>
</div>

<aside>
    <div class="sideBarContainer"></div>
</aside>

<footer>
    <p>Учебное пособие <a href="https://github.com/Slipbang" style="background-color: transparent" target="_blank">Slipbang</a>
    </p>
</footer>
</body>
</html>